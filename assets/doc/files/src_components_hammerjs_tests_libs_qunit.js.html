<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/components/hammerjs/tests/libs/qunit.js - lavaca</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="lavaca"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.3.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/lavaca.env.Device.html">lavaca.env.Device</a></li>
            
                <li><a href="../classes/lavaca.events.EventDispatcher.html">lavaca.events.EventDispatcher</a></li>
            
                <li><a href="../classes/lavaca.fx.Animation.html">lavaca.fx.Animation</a></li>
            
                <li><a href="../classes/lavaca.fx.Spring.html">lavaca.fx.Spring</a></li>
            
                <li><a href="../classes/lavaca.fx.Transform.html">lavaca.fx.Transform</a></li>
            
                <li><a href="../classes/lavaca.fx.Transition.html">lavaca.fx.Transition</a></li>
            
                <li><a href="../classes/lavaca.mvc.Application.html">lavaca.mvc.Application</a></li>
            
                <li><a href="../classes/lavaca.mvc.AttributeEvent.html">lavaca.mvc.AttributeEvent</a></li>
            
                <li><a href="../classes/lavaca.mvc.Collection.html">lavaca.mvc.Collection</a></li>
            
                <li><a href="../classes/lavaca.mvc.Controller.html">lavaca.mvc.Controller</a></li>
            
                <li><a href="../classes/lavaca.mvc.ItemEvent.html">lavaca.mvc.ItemEvent</a></li>
            
                <li><a href="../classes/lavaca.mvc.Model.html">lavaca.mvc.Model</a></li>
            
                <li><a href="../classes/lavaca.mvc.Route.html">lavaca.mvc.Route</a></li>
            
                <li><a href="../classes/lavaca.mvc.Router.html">lavaca.mvc.Router</a></li>
            
                <li><a href="../classes/lavaca.mvc.View.html">lavaca.mvc.View</a></li>
            
                <li><a href="../classes/lavaca.mvc.ViewManager.html">lavaca.mvc.ViewManager</a></li>
            
                <li><a href="../classes/lavaca.net.Connectivity.html">lavaca.net.Connectivity</a></li>
            
                <li><a href="../classes/lavaca.net.History.html">lavaca.net.History</a></li>
            
                <li><a href="../classes/lavaca.storage.LocalStore.html">lavaca.storage.LocalStore</a></li>
            
                <li><a href="../classes/lavaca.storage.Store.html">lavaca.storage.Store</a></li>
            
                <li><a href="../classes/lavaca.ui.DustTemplate.html">lavaca.ui.DustTemplate</a></li>
            
                <li><a href="../classes/lavaca.ui.Form.html">lavaca.ui.Form</a></li>
            
                <li><a href="../classes/lavaca.ui.LoadingIndicator.html">lavaca.ui.LoadingIndicator</a></li>
            
                <li><a href="../classes/lavaca.ui.Template.html">lavaca.ui.Template</a></li>
            
                <li><a href="../classes/lavaca.ui.Widget.html">lavaca.ui.Widget</a></li>
            
                <li><a href="../classes/lavaca.util.ArrayUtils.html">lavaca.util.ArrayUtils</a></li>
            
                <li><a href="../classes/lavaca.util.Cache.html">lavaca.util.Cache</a></li>
            
                <li><a href="../classes/lavaca.util.Config.html">lavaca.util.Config</a></li>
            
                <li><a href="../classes/lavaca.util.DateUtils.html">lavaca.util.DateUtils</a></li>
            
                <li><a href="../classes/lavaca.util.Disposable.html">lavaca.util.Disposable</a></li>
            
                <li><a href="../classes/lavaca.util.extend.html">lavaca.util.extend</a></li>
            
                <li><a href="../classes/lavaca.util.Map.html">lavaca.util.Map</a></li>
            
                <li><a href="../classes/lavaca.util.Promise.html">lavaca.util.Promise</a></li>
            
                <li><a href="../classes/lavaca.util.resolve.html">lavaca.util.resolve</a></li>
            
                <li><a href="../classes/lavaca.util.StringUtils.html">lavaca.util.StringUtils</a></li>
            
                <li><a href="../classes/lavaca.util.Translation.html">lavaca.util.Translation</a></li>
            
                <li><a href="../classes/lavaca.util.uuid.html">lavaca.util.uuid</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/components/hammerjs/tests/libs/qunit.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * QUnit v1.4.0 - A JavaScript Unit Testing Framework
 *
 * http://docs.jquery.com/QUnit
 *
 * Copyright (c) 2012 John Resig, Jörn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * or GPL (GPL-LICENSE.txt) licenses.
 */

(function(window) {

var defined = {
  setTimeout: typeof window.setTimeout !== &quot;undefined&quot;,
  sessionStorage: (function() {
    var x = &quot;qunit-test-string&quot;;
    try {
      sessionStorage.setItem(x, x);
      sessionStorage.removeItem(x);
      return true;
    } catch(e) {
      return false;
    }
  }())
};

var testId = 0,
  toString = Object.prototype.toString,
  hasOwn = Object.prototype.hasOwnProperty;

var Test = function(name, testName, expected, async, callback) {
  this.name = name;
  this.testName = testName;
  this.expected = expected;
  this.async = async;
  this.callback = callback;
  this.assertions = [];
};
Test.prototype = {
  init: function() {
    var tests = id(&quot;qunit-tests&quot;);
    if (tests) {
      var b = document.createElement(&quot;strong&quot;);
        b.innerHTML = &quot;Running &quot; + this.name;
      var li = document.createElement(&quot;li&quot;);
        li.appendChild( b );
        li.className = &quot;running&quot;;
        li.id = this.id = &quot;test-output&quot; + testId++;
      tests.appendChild( li );
    }
  },
  setup: function() {
    if (this.module != config.previousModule) {
      if ( config.previousModule ) {
        runLoggingCallbacks(&#x27;moduleDone&#x27;, QUnit, {
          name: config.previousModule,
          failed: config.moduleStats.bad,
          passed: config.moduleStats.all - config.moduleStats.bad,
          total: config.moduleStats.all
        } );
      }
      config.previousModule = this.module;
      config.moduleStats = { all: 0, bad: 0 };
      runLoggingCallbacks( &#x27;moduleStart&#x27;, QUnit, {
        name: this.module
      } );
    } else if (config.autorun) {
      runLoggingCallbacks( &#x27;moduleStart&#x27;, QUnit, {
        name: this.module
      } );
    }

    config.current = this;
    this.testEnvironment = extend({
      setup: function() {},
      teardown: function() {}
    }, this.moduleTestEnvironment);

    runLoggingCallbacks( &#x27;testStart&#x27;, QUnit, {
      name: this.testName,
      module: this.module
    });

    // allow utility functions to access the current test environment
    // TODO why??
    QUnit.current_testEnvironment = this.testEnvironment;

    if ( !config.pollution ) {
      saveGlobal();
    }
    if ( config.notrycatch ) {
      this.testEnvironment.setup.call(this.testEnvironment);
      return;
    }
    try {
      this.testEnvironment.setup.call(this.testEnvironment);
    } catch(e) {
      QUnit.pushFailure( &quot;Setup failed on &quot; + this.testName + &quot;: &quot; + e.message, extractStacktrace( e, 1 ) );
    }
  },
  run: function() {
    config.current = this;
    if ( this.async ) {
      QUnit.stop();
    }

    if ( config.notrycatch ) {
      this.callback.call(this.testEnvironment);
      return;
    }
    try {
      this.callback.call(this.testEnvironment);
    } catch(e) {
      QUnit.pushFailure( &quot;Died on test #&quot; + (this.assertions.length + 1) + &quot;: &quot; + e.message, extractStacktrace( e, 1 ) );
      // else next test will carry the responsibility
      saveGlobal();

      // Restart the tests if they&#x27;re blocking
      if ( config.blocking ) {
        QUnit.start();
      }
    }
  },
  teardown: function() {
    config.current = this;
    if ( config.notrycatch ) {
      this.testEnvironment.teardown.call(this.testEnvironment);
      return;
    } else {
      try {
        this.testEnvironment.teardown.call(this.testEnvironment);
      } catch(e) {
        QUnit.pushFailure( &quot;Teardown failed on &quot; + this.testName + &quot;: &quot; + e.message, extractStacktrace( e, 1 ) );
      }
    }
    checkPollution();
  },
  finish: function() {
    config.current = this;
    if ( this.expected != null &amp;&amp; this.expected != this.assertions.length ) {
      QUnit.pushFailure( &quot;Expected &quot; + this.expected + &quot; assertions, but &quot; + this.assertions.length + &quot; were run&quot; );
    } else if ( this.expected == null &amp;&amp; !this.assertions.length ) {
      QUnit.pushFailure( &quot;Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.&quot; );
    }

    var good = 0, bad = 0,
      li, i,
      tests = id(&quot;qunit-tests&quot;);

    config.stats.all += this.assertions.length;
    config.moduleStats.all += this.assertions.length;

    if ( tests ) {
      var ol = document.createElement(&quot;ol&quot;);

      for ( i = 0; i &lt; this.assertions.length; i++ ) {
        var assertion = this.assertions[i];

        li = document.createElement(&quot;li&quot;);
        li.className = assertion.result ? &quot;pass&quot; : &quot;fail&quot;;
        li.innerHTML = assertion.message || (assertion.result ? &quot;okay&quot; : &quot;failed&quot;);
        ol.appendChild( li );

        if ( assertion.result ) {
          good++;
        } else {
          bad++;
          config.stats.bad++;
          config.moduleStats.bad++;
        }
      }

      // store result when possible
      if ( QUnit.config.reorder &amp;&amp; defined.sessionStorage ) {
        if (bad) {
          sessionStorage.setItem(&quot;qunit-test-&quot; + this.module + &quot;-&quot; + this.testName, bad);
        } else {
          sessionStorage.removeItem(&quot;qunit-test-&quot; + this.module + &quot;-&quot; + this.testName);
        }
      }

      if (bad === 0) {
        ol.style.display = &quot;none&quot;;
      }

      var b = document.createElement(&quot;strong&quot;);
      b.innerHTML = this.name + &quot; &lt;b class=&#x27;counts&#x27;&gt;(&lt;b class=&#x27;failed&#x27;&gt;&quot; + bad + &quot;&lt;/b&gt;, &lt;b class=&#x27;passed&#x27;&gt;&quot; + good + &quot;&lt;/b&gt;, &quot; + this.assertions.length + &quot;)&lt;/b&gt;&quot;;

      var a = document.createElement(&quot;a&quot;);
      a.innerHTML = &quot;Rerun&quot;;
      a.href = QUnit.url({ filter: getText([b]).replace(/\([^)]+\)$/, &quot;&quot;).replace(/(^\s*|\s*$)/g, &quot;&quot;) });

      addEvent(b, &quot;click&quot;, function() {
        var next = b.nextSibling.nextSibling,
          display = next.style.display;
        next.style.display = display === &quot;none&quot; ? &quot;block&quot; : &quot;none&quot;;
      });

      addEvent(b, &quot;dblclick&quot;, function(e) {
        var target = e &amp;&amp; e.target ? e.target : window.event.srcElement;
        if ( target.nodeName.toLowerCase() == &quot;span&quot; || target.nodeName.toLowerCase() == &quot;b&quot; ) {
          target = target.parentNode;
        }
        if ( window.location &amp;&amp; target.nodeName.toLowerCase() === &quot;strong&quot; ) {
          window.location = QUnit.url({ filter: getText([target]).replace(/\([^)]+\)$/, &quot;&quot;).replace(/(^\s*|\s*$)/g, &quot;&quot;) });
        }
      });

      li = id(this.id);
      li.className = bad ? &quot;fail&quot; : &quot;pass&quot;;
      li.removeChild( li.firstChild );
      li.appendChild( b );
      li.appendChild( a );
      li.appendChild( ol );

    } else {
      for ( i = 0; i &lt; this.assertions.length; i++ ) {
        if ( !this.assertions[i].result ) {
          bad++;
          config.stats.bad++;
          config.moduleStats.bad++;
        }
      }
    }

    QUnit.reset();

    runLoggingCallbacks( &#x27;testDone&#x27;, QUnit, {
      name: this.testName,
      module: this.module,
      failed: bad,
      passed: this.assertions.length - bad,
      total: this.assertions.length
    } );
  },

  queue: function() {
    var test = this;
    synchronize(function() {
      test.init();
    });
    function run() {
      // each of these can by async
      synchronize(function() {
        test.setup();
      });
      synchronize(function() {
        test.run();
      });
      synchronize(function() {
        test.teardown();
      });
      synchronize(function() {
        test.finish();
      });
    }
    // defer when previous test run passed, if storage is available
    var bad = QUnit.config.reorder &amp;&amp; defined.sessionStorage &amp;&amp; +sessionStorage.getItem(&quot;qunit-test-&quot; + this.module + &quot;-&quot; + this.testName);
    if (bad) {
      run();
    } else {
      synchronize(run, true);
    }
  }

};

var QUnit = {

  // call on start of module test to prepend name to all tests
  module: function(name, testEnvironment) {
    config.currentModule = name;
    config.currentModuleTestEnviroment = testEnvironment;
  },

  asyncTest: function(testName, expected, callback) {
    if ( arguments.length === 2 ) {
      callback = expected;
      expected = null;
    }

    QUnit.test(testName, expected, callback, true);
  },

  test: function(testName, expected, callback, async) {
    var name = &#x27;&lt;span class=&quot;test-name&quot;&gt;&#x27; + escapeInnerText(testName) + &#x27;&lt;/span&gt;&#x27;;

    if ( arguments.length === 2 ) {
      callback = expected;
      expected = null;
    }

    if ( config.currentModule ) {
      name = &#x27;&lt;span class=&quot;module-name&quot;&gt;&#x27; + config.currentModule + &quot;&lt;/span&gt;: &quot; + name;
    }

    if ( !validTest(config.currentModule + &quot;: &quot; + testName) ) {
      return;
    }

    var test = new Test(name, testName, expected, async, callback);
    test.module = config.currentModule;
    test.moduleTestEnvironment = config.currentModuleTestEnviroment;
    test.queue();
  },

  // Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don&#x27;t slip through.
  expect: function(asserts) {
    config.current.expected = asserts;
  },

  // Asserts true.
  // @example ok( &quot;asdfasdf&quot;.length &gt; 5, &quot;There must be at least 5 chars&quot; );
  ok: function(result, msg) {
    if (!config.current) {
      throw new Error(&quot;ok() assertion outside test context, was &quot; + sourceFromStacktrace(2));
    }
    result = !!result;
    var details = {
      result: result,
      message: msg
    };
    msg = escapeInnerText(msg || (result ? &quot;okay&quot; : &quot;failed&quot;));
    if ( !result ) {
      var source = sourceFromStacktrace(2);
      if (source) {
        details.source = source;
        msg += &#x27;&lt;table&gt;&lt;tr class=&quot;test-source&quot;&gt;&lt;th&gt;Source: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + escapeInnerText(source) + &#x27;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#x27;;
      }
    }
    runLoggingCallbacks( &#x27;log&#x27;, QUnit, details );
    config.current.assertions.push({
      result: result,
      message: msg
    });
  },

  // Checks that the first two arguments are equal, with an optional message. Prints out both actual and expected values.
  // @example equal( format(&quot;Received {0} bytes.&quot;, 2), &quot;Received 2 bytes.&quot; );
  equal: function(actual, expected, message) {
    QUnit.push(expected == actual, actual, expected, message);
  },

  notEqual: function(actual, expected, message) {
    QUnit.push(expected != actual, actual, expected, message);
  },

  deepEqual: function(actual, expected, message) {
    QUnit.push(QUnit.equiv(actual, expected), actual, expected, message);
  },

  notDeepEqual: function(actual, expected, message) {
    QUnit.push(!QUnit.equiv(actual, expected), actual, expected, message);
  },

  strictEqual: function(actual, expected, message) {
    QUnit.push(expected === actual, actual, expected, message);
  },

  notStrictEqual: function(actual, expected, message) {
    QUnit.push(expected !== actual, actual, expected, message);
  },

  raises: function(block, expected, message) {
    var actual, ok = false;

    if (typeof expected === &#x27;string&#x27;) {
      message = expected;
      expected = null;
    }

    try {
      block();
    } catch (e) {
      actual = e;
    }

    if (actual) {
      // we don&#x27;t want to validate thrown error
      if (!expected) {
        ok = true;
      // expected is a regexp
      } else if (QUnit.objectType(expected) === &quot;regexp&quot;) {
        ok = expected.test(actual);
      // expected is a constructor
      } else if (actual instanceof expected) {
        ok = true;
      // expected is a validation function which returns true is validation passed
      } else if (expected.call({}, actual) === true) {
        ok = true;
      }
    }

    QUnit.ok(ok, message);
  },

  start: function(count) {
    config.semaphore -= count || 1;
    if (config.semaphore &gt; 0) {
      // don&#x27;t start until equal number of stop-calls
      return;
    }
    if (config.semaphore &lt; 0) {
      // ignore if start is called more often then stop
      config.semaphore = 0;
    }
    // A slight delay, to avoid any current callbacks
    if ( defined.setTimeout ) {
      window.setTimeout(function() {
        if (config.semaphore &gt; 0) {
          return;
        }
        if ( config.timeout ) {
          clearTimeout(config.timeout);
        }

        config.blocking = false;
        process(true);
      }, 13);
    } else {
      config.blocking = false;
      process(true);
    }
  },

  stop: function(count) {
    config.semaphore += count || 1;
    config.blocking = true;

    if ( config.testTimeout &amp;&amp; defined.setTimeout ) {
      clearTimeout(config.timeout);
      config.timeout = window.setTimeout(function() {
        QUnit.ok( false, &quot;Test timed out&quot; );
        config.semaphore = 1;
        QUnit.start();
      }, config.testTimeout);
    }
  }
};

//We want access to the constructor&#x27;s prototype
(function() {
  function F(){}
  F.prototype = QUnit;
  QUnit = new F();
  //Make F QUnit&#x27;s constructor so that we can add to the prototype later
  QUnit.constructor = F;
}());

// deprecated; still export them to window to provide clear error messages
// next step: remove entirely
QUnit.equals = function() {
  QUnit.push(false, false, false, &quot;QUnit.equals has been deprecated since 2009 (e88049a0), use QUnit.equal instead&quot;);
};
QUnit.same = function() {
  QUnit.push(false, false, false, &quot;QUnit.same has been deprecated since 2009 (e88049a0), use QUnit.deepEqual instead&quot;);
};

// Maintain internal state
var config = {
  // The queue of tests to run
  queue: [],

  // block until document ready
  blocking: true,

  // when enabled, show only failing tests
  // gets persisted through sessionStorage and can be changed in UI via checkbox
  hidepassed: false,

  // by default, run previously failed tests first
  // very useful in combination with &quot;Hide passed tests&quot; checked
  reorder: true,

  // by default, modify document.title when suite is done
  altertitle: true,

  urlConfig: [&#x27;noglobals&#x27;, &#x27;notrycatch&#x27;],

  //logging callback queues
  begin: [],
  done: [],
  log: [],
  testStart: [],
  testDone: [],
  moduleStart: [],
  moduleDone: []
};

// Load paramaters
(function() {
  var location = window.location || { search: &quot;&quot;, protocol: &quot;file:&quot; },
    params = location.search.slice( 1 ).split( &quot;&amp;&quot; ),
    length = params.length,
    urlParams = {},
    current;

  if ( params[ 0 ] ) {
    for ( var i = 0; i &lt; length; i++ ) {
      current = params[ i ].split( &quot;=&quot; );
      current[ 0 ] = decodeURIComponent( current[ 0 ] );
      // allow just a key to turn on a flag, e.g., test.html?noglobals
      current[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;
      urlParams[ current[ 0 ] ] = current[ 1 ];
    }
  }

  QUnit.urlParams = urlParams;
  config.filter = urlParams.filter;

  // Figure out if we&#x27;re running the tests from a server or not
  QUnit.isLocal = location.protocol === &#x27;file:&#x27;;
}());

// Expose the API as global variables, unless an &#x27;exports&#x27;
// object exists, in that case we assume we&#x27;re in CommonJS - export everything at the end
if ( typeof exports === &quot;undefined&quot; || typeof require === &quot;undefined&quot; ) {
  extend(window, QUnit);
  window.QUnit = QUnit;
}

// define these after exposing globals to keep them in these QUnit namespace only
extend(QUnit, {
  config: config,

  // Initialize the configuration options
  init: function() {
    extend(config, {
      stats: { all: 0, bad: 0 },
      moduleStats: { all: 0, bad: 0 },
      started: +new Date(),
      updateRate: 1000,
      blocking: false,
      autostart: true,
      autorun: false,
      filter: &quot;&quot;,
      queue: [],
      semaphore: 0
    });

    var qunit = id( &quot;qunit&quot; );
    if ( qunit ) {
      qunit.innerHTML =
        &#x27;&lt;h1 id=&quot;qunit-header&quot;&gt;&#x27; + escapeInnerText( document.title ) + &#x27;&lt;/h1&gt;&#x27; +
        &#x27;&lt;h2 id=&quot;qunit-banner&quot;&gt;&lt;/h2&gt;&#x27; +
        &#x27;&lt;div id=&quot;qunit-testrunner-toolbar&quot;&gt;&lt;/div&gt;&#x27; +
        &#x27;&lt;h2 id=&quot;qunit-userAgent&quot;&gt;&lt;/h2&gt;&#x27; +
        &#x27;&lt;ol id=&quot;qunit-tests&quot;&gt;&lt;/ol&gt;&#x27;;
    }

    var tests = id( &quot;qunit-tests&quot; ),
      banner = id( &quot;qunit-banner&quot; ),
      result = id( &quot;qunit-testresult&quot; );

    if ( tests ) {
      tests.innerHTML = &quot;&quot;;
    }

    if ( banner ) {
      banner.className = &quot;&quot;;
    }

    if ( result ) {
      result.parentNode.removeChild( result );
    }

    if ( tests ) {
      result = document.createElement( &quot;p&quot; );
      result.id = &quot;qunit-testresult&quot;;
      result.className = &quot;result&quot;;
      tests.parentNode.insertBefore( result, tests );
      result.innerHTML = &#x27;Running...&lt;br/&gt;&amp;nbsp;&#x27;;
    }
  },

  // Resets the test setup. Useful for tests that modify the DOM.
  // If jQuery is available, uses jQuery&#x27;s html(), otherwise just innerHTML.
  reset: function() {
    if ( window.jQuery ) {
      jQuery( &quot;#qunit-fixture&quot; ).html( config.fixture );
    } else {
      var main = id( &#x27;qunit-fixture&#x27; );
      if ( main ) {
        main.innerHTML = config.fixture;
      }
    }
  },

  // Trigger an event on an element.
  // @example triggerEvent( document.body, &quot;click&quot; );
  triggerEvent: function( elem, type, event ) {
    if ( document.createEvent ) {
      event = document.createEvent(&quot;MouseEvents&quot;);
      event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
        0, 0, 0, 0, 0, false, false, false, false, 0, null);
      elem.dispatchEvent( event );

    } else if ( elem.fireEvent ) {
      elem.fireEvent(&quot;on&quot;+type);
    }
  },

  // Safe object type checking
  is: function( type, obj ) {
    return QUnit.objectType( obj ) == type;
  },

  objectType: function( obj ) {
    if (typeof obj === &quot;undefined&quot;) {
        return &quot;undefined&quot;;

    // consider: typeof null === object
    }
    if (obj === null) {
        return &quot;null&quot;;
    }

    var type = toString.call( obj ).match(/^\[object\s(.*)\]$/)[1] || &#x27;&#x27;;

    switch (type) {
      case &#x27;Number&#x27;:
        if (isNaN(obj)) {
          return &quot;nan&quot;;
        }
        return &quot;number&quot;;
      case &#x27;String&#x27;:
      case &#x27;Boolean&#x27;:
      case &#x27;Array&#x27;:
      case &#x27;Date&#x27;:
      case &#x27;RegExp&#x27;:
      case &#x27;Function&#x27;:
          return type.toLowerCase();
    }
    if (typeof obj === &quot;object&quot;) {
        return &quot;object&quot;;
    }
    return undefined;
  },

  push: function(result, actual, expected, message) {
    if (!config.current) {
      throw new Error(&quot;assertion outside test context, was &quot; + sourceFromStacktrace());
    }
    var details = {
      result: result,
      message: message,
      actual: actual,
      expected: expected
    };

    message = escapeInnerText(message) || (result ? &quot;okay&quot; : &quot;failed&quot;);
    message = &#x27;&lt;span class=&quot;test-message&quot;&gt;&#x27; + message + &quot;&lt;/span&gt;&quot;;
    var output = message;
    if (!result) {
      expected = escapeInnerText(QUnit.jsDump.parse(expected));
      actual = escapeInnerText(QUnit.jsDump.parse(actual));
      output += &#x27;&lt;table&gt;&lt;tr class=&quot;test-expected&quot;&gt;&lt;th&gt;Expected: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + expected + &#x27;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#x27;;
      if (actual != expected) {
        output += &#x27;&lt;tr class=&quot;test-actual&quot;&gt;&lt;th&gt;Result: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + actual + &#x27;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#x27;;
        output += &#x27;&lt;tr class=&quot;test-diff&quot;&gt;&lt;th&gt;Diff: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + QUnit.diff(expected, actual) +&#x27;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#x27;;
      }
      var source = sourceFromStacktrace();
      if (source) {
        details.source = source;
        output += &#x27;&lt;tr class=&quot;test-source&quot;&gt;&lt;th&gt;Source: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + escapeInnerText(source) + &#x27;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&#x27;;
      }
      output += &quot;&lt;/table&gt;&quot;;
    }

    runLoggingCallbacks( &#x27;log&#x27;, QUnit, details );

    config.current.assertions.push({
      result: !!result,
      message: output
    });
  },

  pushFailure: function(message, source) {
    var details = {
      result: false,
      message: message
    };
    var output = escapeInnerText(message);
    if (source) {
      details.source = source;
      output += &#x27;&lt;table&gt;&lt;tr class=&quot;test-source&quot;&gt;&lt;th&gt;Source: &lt;/th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + escapeInnerText(source) + &#x27;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#x27;;
    }
    runLoggingCallbacks( &#x27;log&#x27;, QUnit, details );
    config.current.assertions.push({
      result: false,
      message: output
    });
  },

  url: function( params ) {
    params = extend( extend( {}, QUnit.urlParams ), params );
    var querystring = &quot;?&quot;,
      key;
    for ( key in params ) {
      if ( !hasOwn.call( params, key ) ) {
        continue;
      }
      querystring += encodeURIComponent( key ) + &quot;=&quot; +
        encodeURIComponent( params[ key ] ) + &quot;&amp;&quot;;
    }
    return window.location.pathname + querystring.slice( 0, -1 );
  },

  extend: extend,
  id: id,
  addEvent: addEvent
});

//QUnit.constructor is set to the empty F() above so that we can add to it&#x27;s prototype later
//Doing this allows us to tell if the following methods have been overwritten on the actual
//QUnit object, which is a deprecated way of using the callbacks.
extend(QUnit.constructor.prototype, {
  // Logging callbacks; all receive a single argument with the listed properties
  // run test/logs.html for any related changes
  begin: registerLoggingCallback(&#x27;begin&#x27;),
  // done: { failed, passed, total, runtime }
  done: registerLoggingCallback(&#x27;done&#x27;),
  // log: { result, actual, expected, message }
  log: registerLoggingCallback(&#x27;log&#x27;),
  // testStart: { name }
  testStart: registerLoggingCallback(&#x27;testStart&#x27;),
  // testDone: { name, failed, passed, total }
  testDone: registerLoggingCallback(&#x27;testDone&#x27;),
  // moduleStart: { name }
  moduleStart: registerLoggingCallback(&#x27;moduleStart&#x27;),
  // moduleDone: { name, failed, passed, total }
  moduleDone: registerLoggingCallback(&#x27;moduleDone&#x27;)
});

if ( typeof document === &quot;undefined&quot; || document.readyState === &quot;complete&quot; ) {
  config.autorun = true;
}

QUnit.load = function() {
  runLoggingCallbacks( &#x27;begin&#x27;, QUnit, {} );

  // Initialize the config, saving the execution queue
  var oldconfig = extend({}, config);
  QUnit.init();
  extend(config, oldconfig);

  config.blocking = false;

  var urlConfigHtml = &#x27;&#x27;, len = config.urlConfig.length;
  for ( var i = 0, val; i &lt; len; i++ ) {
    val = config.urlConfig[i];
    config[val] = QUnit.urlParams[val];
    urlConfigHtml += &#x27;&lt;label&gt;&lt;input name=&quot;&#x27; + val + &#x27;&quot; type=&quot;checkbox&quot;&#x27; + ( config[val] ? &#x27; checked=&quot;checked&quot;&#x27; : &#x27;&#x27; ) + &#x27;&gt;&#x27; + val + &#x27;&lt;/label&gt;&#x27;;
  }

  var userAgent = id(&quot;qunit-userAgent&quot;);
  if ( userAgent ) {
    userAgent.innerHTML = navigator.userAgent;
  }
  var banner = id(&quot;qunit-header&quot;);
  if ( banner ) {
    banner.innerHTML = &#x27;&lt;a href=&quot;&#x27; + QUnit.url({ filter: undefined }) + &#x27;&quot;&gt; &#x27; + banner.innerHTML + &#x27;&lt;/a&gt; &#x27; + urlConfigHtml;
    addEvent( banner, &quot;change&quot;, function( event ) {
      var params = {};
      params[ event.target.name ] = event.target.checked ? true : undefined;
      window.location = QUnit.url( params );
    });
  }

  var toolbar = id(&quot;qunit-testrunner-toolbar&quot;);
  if ( toolbar ) {
    var filter = document.createElement(&quot;input&quot;);
    filter.type = &quot;checkbox&quot;;
    filter.id = &quot;qunit-filter-pass&quot;;
    addEvent( filter, &quot;click&quot;, function() {
      var ol = document.getElementById(&quot;qunit-tests&quot;);
      if ( filter.checked ) {
        ol.className = ol.className + &quot; hidepass&quot;;
      } else {
        var tmp = &quot; &quot; + ol.className.replace( /[\n\t\r]/g, &quot; &quot; ) + &quot; &quot;;
        ol.className = tmp.replace(/ hidepass /, &quot; &quot;);
      }
      if ( defined.sessionStorage ) {
        if (filter.checked) {
          sessionStorage.setItem(&quot;qunit-filter-passed-tests&quot;, &quot;true&quot;);
        } else {
          sessionStorage.removeItem(&quot;qunit-filter-passed-tests&quot;);
        }
      }
    });
    if ( config.hidepassed || defined.sessionStorage &amp;&amp; sessionStorage.getItem(&quot;qunit-filter-passed-tests&quot;) ) {
      filter.checked = true;
      var ol = document.getElementById(&quot;qunit-tests&quot;);
      ol.className = ol.className + &quot; hidepass&quot;;
    }
    toolbar.appendChild( filter );

    var label = document.createElement(&quot;label&quot;);
    label.setAttribute(&quot;for&quot;, &quot;qunit-filter-pass&quot;);
    label.innerHTML = &quot;Hide passed tests&quot;;
    toolbar.appendChild( label );
  }

  var main = id(&#x27;qunit-fixture&#x27;);
  if ( main ) {
    config.fixture = main.innerHTML;
  }

  if (config.autostart) {
    QUnit.start();
  }
};

addEvent(window, &quot;load&quot;, QUnit.load);

// addEvent(window, &quot;error&quot;) gives us a useless event object
window.onerror = function( message, file, line ) {
  if ( QUnit.config.current ) {
    QUnit.pushFailure( message, file + &quot;:&quot; + line );
  } else {
    QUnit.test( &quot;global failure&quot;, function() {
      QUnit.pushFailure( message, file + &quot;:&quot; + line );
    });
  }
};

function done() {
  config.autorun = true;

  // Log the last module results
  if ( config.currentModule ) {
    runLoggingCallbacks( &#x27;moduleDone&#x27;, QUnit, {
      name: config.currentModule,
      failed: config.moduleStats.bad,
      passed: config.moduleStats.all - config.moduleStats.bad,
      total: config.moduleStats.all
    } );
  }

  var banner = id(&quot;qunit-banner&quot;),
    tests = id(&quot;qunit-tests&quot;),
    runtime = +new Date() - config.started,
    passed = config.stats.all - config.stats.bad,
    html = [
      &#x27;Tests completed in &#x27;,
      runtime,
      &#x27; milliseconds.&lt;br/&gt;&#x27;,
      &#x27;&lt;span class=&quot;passed&quot;&gt;&#x27;,
      passed,
      &#x27;&lt;/span&gt; tests of &lt;span class=&quot;total&quot;&gt;&#x27;,
      config.stats.all,
      &#x27;&lt;/span&gt; passed, &lt;span class=&quot;failed&quot;&gt;&#x27;,
      config.stats.bad,
      &#x27;&lt;/span&gt; failed.&#x27;
    ].join(&#x27;&#x27;);

  if ( banner ) {
    banner.className = (config.stats.bad ? &quot;qunit-fail&quot; : &quot;qunit-pass&quot;);
  }

  if ( tests ) {
    id( &quot;qunit-testresult&quot; ).innerHTML = html;
  }

  if ( config.altertitle &amp;&amp; typeof document !== &quot;undefined&quot; &amp;&amp; document.title ) {
    // show ✖ for good, ✔ for bad suite result in title
    // use escape sequences in case file gets loaded with non-utf-8-charset
    document.title = [
      (config.stats.bad ? &quot;\u2716&quot; : &quot;\u2714&quot;),
      document.title.replace(/^[\u2714\u2716] /i, &quot;&quot;)
    ].join(&quot; &quot;);
  }

  // clear own sessionStorage items if all tests passed
  if ( config.reorder &amp;&amp; defined.sessionStorage &amp;&amp; config.stats.bad === 0 ) {
    for (var key in sessionStorage) {
      if (sessionStorage.hasOwnProperty(key) &amp;&amp; key.indexOf(&quot;qunit-test-&quot;) === 0 ) {
        sessionStorage.removeItem(key);
      }
    }
  }

  runLoggingCallbacks( &#x27;done&#x27;, QUnit, {
    failed: config.stats.bad,
    passed: passed,
    total: config.stats.all,
    runtime: runtime
  } );
}

function validTest( name ) {
  var filter = config.filter,
    run = false;

  if ( !filter ) {
    return true;
  }

  var not = filter.charAt( 0 ) === &quot;!&quot;;
  if ( not ) {
    filter = filter.slice( 1 );
  }

  if ( name.indexOf( filter ) !== -1 ) {
    return !not;
  }

  if ( not ) {
    run = true;
  }

  return run;
}

// so far supports only Firefox, Chrome and Opera (buggy)
// could be extended in the future to use something like https://github.com/csnover/TraceKit
function extractStacktrace( e, offset ) {
  offset = offset || 3;
  if (e.stacktrace) {
    // Opera
    return e.stacktrace.split(&quot;\n&quot;)[offset + 3];
  } else if (e.stack) {
    // Firefox, Chrome
    var stack = e.stack.split(&quot;\n&quot;);
    if (/^error$/i.test(stack[0])) {
      stack.shift();
    }
    return stack[offset];
  } else if (e.sourceURL) {
    // Safari, PhantomJS
    // hopefully one day Safari provides actual stacktraces
    // exclude useless self-reference for generated Error objects
    if ( /qunit.js$/.test( e.sourceURL ) ) {
      return;
    }
    // for actual exceptions, this is useful
    return e.sourceURL + &quot;:&quot; + e.line;
  }
}
function sourceFromStacktrace(offset) {
  try {
    throw new Error();
  } catch ( e ) {
    return extractStacktrace( e, offset );
  }
}

function escapeInnerText(s) {
  if (!s) {
    return &quot;&quot;;
  }
  s = s + &quot;&quot;;
  return s.replace(/[\&amp;&lt;&gt;]/g, function(s) {
    switch(s) {
      case &quot;&amp;&quot;: return &quot;&amp;amp;&quot;;
      case &quot;&lt;&quot;: return &quot;&amp;lt;&quot;;
      case &quot;&gt;&quot;: return &quot;&amp;gt;&quot;;
      default: return s;
    }
  });
}

function synchronize( callback, last ) {
  config.queue.push( callback );

  if ( config.autorun &amp;&amp; !config.blocking ) {
    process(last);
  }
}

function process( last ) {
  function next() {
    process( last );
  }
  var start = new Date().getTime();
  config.depth = config.depth ? config.depth + 1 : 1;

  while ( config.queue.length &amp;&amp; !config.blocking ) {
    if ( !defined.setTimeout || config.updateRate &lt;= 0 || ( ( new Date().getTime() - start ) &lt; config.updateRate ) ) {
      config.queue.shift()();
    } else {
      window.setTimeout( next, 13 );
      break;
    }
  }
  config.depth--;
  if ( last &amp;&amp; !config.blocking &amp;&amp; !config.queue.length &amp;&amp; config.depth === 0 ) {
    done();
  }
}

function saveGlobal() {
  config.pollution = [];

  if ( config.noglobals ) {
    for ( var key in window ) {
      if ( !hasOwn.call( window, key ) ) {
        continue;
      }
      config.pollution.push( key );
    }
  }
}

function checkPollution( name ) {
  var old = config.pollution;
  saveGlobal();

  var newGlobals = diff( config.pollution, old );
  if ( newGlobals.length &gt; 0 ) {
    QUnit.pushFailure( &quot;Introduced global variable(s): &quot; + newGlobals.join(&quot;, &quot;) );
  }

  var deletedGlobals = diff( old, config.pollution );
  if ( deletedGlobals.length &gt; 0 ) {
    QUnit.pushFailure( &quot;Deleted global variable(s): &quot; + deletedGlobals.join(&quot;, &quot;) );
  }
}

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
  var result = a.slice();
  for ( var i = 0; i &lt; result.length; i++ ) {
    for ( var j = 0; j &lt; b.length; j++ ) {
      if ( result[i] === b[j] ) {
        result.splice(i, 1);
        i--;
        break;
      }
    }
  }
  return result;
}

function extend(a, b) {
  for ( var prop in b ) {
    if ( b[prop] === undefined ) {
      delete a[prop];

    // Avoid &quot;Member not found&quot; error in IE8 caused by setting window.constructor
    } else if ( prop !== &quot;constructor&quot; || a !== window ) {
      a[prop] = b[prop];
    }
  }

  return a;
}

function addEvent(elem, type, fn) {
  if ( elem.addEventListener ) {
    elem.addEventListener( type, fn, false );
  } else if ( elem.attachEvent ) {
    elem.attachEvent( &quot;on&quot; + type, fn );
  } else {
    fn();
  }
}

function id(name) {
  return !!(typeof document !== &quot;undefined&quot; &amp;&amp; document &amp;&amp; document.getElementById) &amp;&amp;
    document.getElementById( name );
}

function registerLoggingCallback(key){
  return function(callback){
    config[key].push( callback );
  };
}

// Supports deprecated method of completely overwriting logging callbacks
function runLoggingCallbacks(key, scope, args) {
  //debugger;
  var callbacks;
  if ( QUnit.hasOwnProperty(key) ) {
    QUnit[key].call(scope, args);
  } else {
    callbacks = config[key];
    for( var i = 0; i &lt; callbacks.length; i++ ) {
      callbacks[i].call( scope, args );
    }
  }
}

// Test for equality any JavaScript type.
// Author: Philippe Rathé &lt;prathe@gmail.com&gt;
QUnit.equiv = (function() {

  var innerEquiv; // the real equiv function
  var callers = []; // stack to decide between skip/abort functions
  var parents = []; // stack to avoiding loops from circular referencing

  // Call the o related callback with the given arguments.
  function bindCallbacks(o, callbacks, args) {
    var prop = QUnit.objectType(o);
    if (prop) {
      if (QUnit.objectType(callbacks[prop]) === &quot;function&quot;) {
        return callbacks[prop].apply(callbacks, args);
      } else {
        return callbacks[prop]; // or undefined
      }
    }
  }

  var getProto = Object.getPrototypeOf || function (obj) {
    return obj.__proto__;
  };

  var callbacks = (function () {

    // for string, boolean, number and null
    function useStrictEquality(b, a) {
      if (b instanceof a.constructor || a instanceof b.constructor) {
        // to catch short annotaion VS &#x27;new&#x27; annotation of a
        // declaration
        // e.g. var i = 1;
        // var j = new Number(1);
        return a == b;
      } else {
        return a === b;
      }
    }

    return {
      &quot;string&quot; : useStrictEquality,
      &quot;boolean&quot; : useStrictEquality,
      &quot;number&quot; : useStrictEquality,
      &quot;null&quot; : useStrictEquality,
      &quot;undefined&quot; : useStrictEquality,

      &quot;nan&quot; : function(b) {
        return isNaN(b);
      },

      &quot;date&quot; : function(b, a) {
        return QUnit.objectType(b) === &quot;date&quot; &amp;&amp; a.valueOf() === b.valueOf();
      },

      &quot;regexp&quot; : function(b, a) {
        return QUnit.objectType(b) === &quot;regexp&quot; &amp;&amp;
          // the regex itself
          a.source === b.source &amp;&amp;
          // and its modifers
          a.global === b.global &amp;&amp;
          // (gmi) ...
          a.ignoreCase === b.ignoreCase &amp;&amp;
          a.multiline === b.multiline;
      },

      // - skip when the property is a method of an instance (OOP)
      // - abort otherwise,
      // initial === would have catch identical references anyway
      &quot;function&quot; : function() {
        var caller = callers[callers.length - 1];
        return caller !== Object &amp;&amp; typeof caller !== &quot;undefined&quot;;
      },

      &quot;array&quot; : function(b, a) {
        var i, j, loop;
        var len;

        // b could be an object literal here
        if (QUnit.objectType(b) !== &quot;array&quot;) {
          return false;
        }

        len = a.length;
        if (len !== b.length) { // safe and faster
          return false;
        }

        // track reference to avoid circular references
        parents.push(a);
        for (i = 0; i &lt; len; i++) {
          loop = false;
          for (j = 0; j &lt; parents.length; j++) {
            if (parents[j] === a[i]) {
              loop = true;// dont rewalk array
            }
          }
          if (!loop &amp;&amp; !innerEquiv(a[i], b[i])) {
            parents.pop();
            return false;
          }
        }
        parents.pop();
        return true;
      },

      &quot;object&quot; : function(b, a) {
        var i, j, loop;
        var eq = true; // unless we can proove it
        var aProperties = [], bProperties = []; // collection of
                            // strings

        // comparing constructors is more strict than using
        // instanceof
        if (a.constructor !== b.constructor) {
          // Allow objects with no prototype to be equivalent to
          // objects with Object as their constructor.
          if (!((getProto(a) === null &amp;&amp; getProto(b) === Object.prototype) ||
            (getProto(b) === null &amp;&amp; getProto(a) === Object.prototype)))
          {
            return false;
          }
        }

        // stack constructor before traversing properties
        callers.push(a.constructor);
        // track reference to avoid circular references
        parents.push(a);

        for (i in a) { // be strict: don&#x27;t ensures hasOwnProperty
                // and go deep
          loop = false;
          for (j = 0; j &lt; parents.length; j++) {
            if (parents[j] === a[i]) {
              // don&#x27;t go down the same path twice
              loop = true;
            }
          }
          aProperties.push(i); // collect a&#x27;s properties

          if (!loop &amp;&amp; !innerEquiv(a[i], b[i])) {
            eq = false;
            break;
          }
        }

        callers.pop(); // unstack, we are done
        parents.pop();

        for (i in b) {
          bProperties.push(i); // collect b&#x27;s properties
        }

        // Ensures identical properties name
        return eq &amp;&amp; innerEquiv(aProperties.sort(), bProperties.sort());
      }
    };
  }());

  innerEquiv = function() { // can take multiple arguments
    var args = Array.prototype.slice.apply(arguments);
    if (args.length &lt; 2) {
      return true; // end transition
    }

    return (function(a, b) {
      if (a === b) {
        return true; // catch the most you can
      } else if (a === null || b === null || typeof a === &quot;undefined&quot; ||
          typeof b === &quot;undefined&quot; ||
          QUnit.objectType(a) !== QUnit.objectType(b)) {
        return false; // don&#x27;t lose time with error prone cases
      } else {
        return bindCallbacks(a, callbacks, [ b, a ]);
      }

      // apply transition with (1..n) arguments
    }(args[0], args[1]) &amp;&amp; arguments.callee.apply(this, args.splice(1, args.length - 1)));
  };

  return innerEquiv;

}());

/**
 * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |
 * http://flesler.blogspot.com Licensed under BSD
 * (http://www.opensource.org/licenses/bsd-license.php) Date: 5/15/2008
 *
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
 */
QUnit.jsDump = (function() {
  function quote( str ) {
    return &#x27;&quot;&#x27; + str.toString().replace(/&quot;/g, &#x27;\\&quot;&#x27;) + &#x27;&quot;&#x27;;
  }
  function literal( o ) {
    return o + &#x27;&#x27;;
  }
  function join( pre, arr, post ) {
    var s = jsDump.separator(),
      base = jsDump.indent(),
      inner = jsDump.indent(1);
    if ( arr.join ) {
      arr = arr.join( &#x27;,&#x27; + s + inner );
    }
    if ( !arr ) {
      return pre + post;
    }
    return [ pre, inner + arr, base + post ].join(s);
  }
  function array( arr, stack ) {
    var i = arr.length, ret = new Array(i);
    this.up();
    while ( i-- ) {
      ret[i] = this.parse( arr[i] , undefined , stack);
    }
    this.down();
    return join( &#x27;[&#x27;, ret, &#x27;]&#x27; );
  }

  var reName = /^function (\w+)/;

  var jsDump = {
    parse: function( obj, type, stack ) { //type is used mostly internally, you can fix a (custom)type in advance
      stack = stack || [ ];
      var parser = this.parsers[ type || this.typeOf(obj) ];
      type = typeof parser;
      var inStack = inArray(obj, stack);
      if (inStack != -1) {
        return &#x27;recursion(&#x27;+(inStack - stack.length)+&#x27;)&#x27;;
      }
      //else
      if (type == &#x27;function&#x27;)  {
          stack.push(obj);
          var res = parser.call( this, obj, stack );
          stack.pop();
          return res;
      }
      // else
      return (type == &#x27;string&#x27;) ? parser : this.parsers.error;
    },
    typeOf: function( obj ) {
      var type;
      if ( obj === null ) {
        type = &quot;null&quot;;
      } else if (typeof obj === &quot;undefined&quot;) {
        type = &quot;undefined&quot;;
      } else if (QUnit.is(&quot;RegExp&quot;, obj)) {
        type = &quot;regexp&quot;;
      } else if (QUnit.is(&quot;Date&quot;, obj)) {
        type = &quot;date&quot;;
      } else if (QUnit.is(&quot;Function&quot;, obj)) {
        type = &quot;function&quot;;
      } else if (typeof obj.setInterval !== undefined &amp;&amp; typeof obj.document !== &quot;undefined&quot; &amp;&amp; typeof obj.nodeType === &quot;undefined&quot;) {
        type = &quot;window&quot;;
      } else if (obj.nodeType === 9) {
        type = &quot;document&quot;;
      } else if (obj.nodeType) {
        type = &quot;node&quot;;
      } else if (
        // native arrays
        toString.call( obj ) === &quot;[object Array]&quot; ||
        // NodeList objects
        ( typeof obj.length === &quot;number&quot; &amp;&amp; typeof obj.item !== &quot;undefined&quot; &amp;&amp; ( obj.length ? obj.item(0) === obj[0] : ( obj.item( 0 ) === null &amp;&amp; typeof obj[0] === &quot;undefined&quot; ) ) )
      ) {
        type = &quot;array&quot;;
      } else {
        type = typeof obj;
      }
      return type;
    },
    separator: function() {
      return this.multiline ? this.HTML ? &#x27;&lt;br /&gt;&#x27; : &#x27;\n&#x27; : this.HTML ? &#x27;&amp;nbsp;&#x27; : &#x27; &#x27;;
    },
    indent: function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing
      if ( !this.multiline ) {
        return &#x27;&#x27;;
      }
      var chr = this.indentChar;
      if ( this.HTML ) {
        chr = chr.replace(/\t/g,&#x27;   &#x27;).replace(/ /g,&#x27;&amp;nbsp;&#x27;);
      }
      return new Array( this._depth_ + (extra||0) ).join(chr);
    },
    up: function( a ) {
      this._depth_ += a || 1;
    },
    down: function( a ) {
      this._depth_ -= a || 1;
    },
    setParser: function( name, parser ) {
      this.parsers[name] = parser;
    },
    // The next 3 are exposed so you can use them
    quote: quote,
    literal: literal,
    join: join,
    //
    _depth_: 1,
    // This is the list of parsers, to modify them, use jsDump.setParser
    parsers: {
      window: &#x27;[Window]&#x27;,
      document: &#x27;[Document]&#x27;,
      error: &#x27;[ERROR]&#x27;, //when no parser is found, shouldn&#x27;t happen
      unknown: &#x27;[Unknown]&#x27;,
      &#x27;null&#x27;: &#x27;null&#x27;,
      &#x27;undefined&#x27;: &#x27;undefined&#x27;,
      &#x27;function&#x27;: function( fn ) {
        var ret = &#x27;function&#x27;,
          name = &#x27;name&#x27; in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE
        if ( name ) {
          ret += &#x27; &#x27; + name;
        }
        ret += &#x27;(&#x27;;

        ret = [ ret, QUnit.jsDump.parse( fn, &#x27;functionArgs&#x27; ), &#x27;){&#x27;].join(&#x27;&#x27;);
        return join( ret, QUnit.jsDump.parse(fn,&#x27;functionCode&#x27;), &#x27;}&#x27; );
      },
      array: array,
      nodelist: array,
      &#x27;arguments&#x27;: array,
      object: function( map, stack ) {
        var ret = [ ], keys, key, val, i;
        QUnit.jsDump.up();
        if (Object.keys) {
          keys = Object.keys( map );
        } else {
          keys = [];
          for (key in map) { keys.push( key ); }
        }
        keys.sort();
        for (i = 0; i &lt; keys.length; i++) {
          key = keys[ i ];
          val = map[ key ];
          ret.push( QUnit.jsDump.parse( key, &#x27;key&#x27; ) + &#x27;: &#x27; + QUnit.jsDump.parse( val, undefined, stack ) );
        }
        QUnit.jsDump.down();
        return join( &#x27;{&#x27;, ret, &#x27;}&#x27; );
      },
      node: function( node ) {
        var open = QUnit.jsDump.HTML ? &#x27;&amp;lt;&#x27; : &#x27;&lt;&#x27;,
          close = QUnit.jsDump.HTML ? &#x27;&amp;gt;&#x27; : &#x27;&gt;&#x27;;

        var tag = node.nodeName.toLowerCase(),
          ret = open + tag;

        for ( var a in QUnit.jsDump.DOMAttrs ) {
          var val = node[QUnit.jsDump.DOMAttrs[a]];
          if ( val ) {
            ret += &#x27; &#x27; + a + &#x27;=&#x27; + QUnit.jsDump.parse( val, &#x27;attribute&#x27; );
          }
        }
        return ret + close + open + &#x27;/&#x27; + tag + close;
      },
      functionArgs: function( fn ) {//function calls it internally, it&#x27;s the arguments part of the function
        var l = fn.length;
        if ( !l ) {
          return &#x27;&#x27;;
        }

        var args = new Array(l);
        while ( l-- ) {
          args[l] = String.fromCharCode(97+l);//97 is &#x27;a&#x27;
        }
        return &#x27; &#x27; + args.join(&#x27;, &#x27;) + &#x27; &#x27;;
      },
      key: quote, //object calls it internally, the key part of an item in a map
      functionCode: &#x27;[code]&#x27;, //function calls it internally, it&#x27;s the content of the function
      attribute: quote, //node calls it internally, it&#x27;s an html attribute value
      string: quote,
      date: quote,
      regexp: literal, //regex
      number: literal,
      &#x27;boolean&#x27;: literal
    },
    DOMAttrs:{//attributes to dump from nodes, name=&gt;realName
      id:&#x27;id&#x27;,
      name:&#x27;name&#x27;,
      &#x27;class&#x27;:&#x27;className&#x27;
    },
    HTML:false,//if true, entities are escaped ( &lt;, &gt;, \t, space and \n )
    indentChar:&#x27;  &#x27;,//indentation unit
    multiline:true //if true, items in a collection, are separated by a \n, else just a space.
  };

  return jsDump;
}());

// from Sizzle.js
function getText( elems ) {
  var ret = &quot;&quot;, elem;

  for ( var i = 0; elems[i]; i++ ) {
    elem = elems[i];

    // Get the text from text nodes and CDATA nodes
    if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
      ret += elem.nodeValue;

    // Traverse everything else, except comment nodes
    } else if ( elem.nodeType !== 8 ) {
      ret += getText( elem.childNodes );
    }
  }

  return ret;
}

//from jquery.js
function inArray( elem, array ) {
  if ( array.indexOf ) {
    return array.indexOf( elem );
  }

  for ( var i = 0, length = array.length; i &lt; length; i++ ) {
    if ( array[ i ] === elem ) {
      return i;
    }
  }

  return -1;
}

/*
 * Javascript Diff Algorithm
 *  By John Resig (http://ejohn.org/)
 *  Modified by Chu Alan &quot;sprite&quot;
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http://ejohn.org/projects/javascript-diff-algorithm/
 *
 * Usage: QUnit.diff(expected, actual)
 *
 * QUnit.diff(&quot;the quick brown fox jumped over&quot;, &quot;the quick fox jumps over&quot;) == &quot;the  quick &lt;del&gt;brown &lt;/del&gt; fox &lt;del&gt;jumped &lt;/del&gt;&lt;ins&gt;jumps &lt;/ins&gt; over&quot;
 */
QUnit.diff = (function() {
  function diff(o, n) {
    var ns = {};
    var os = {};
    var i;

    for (i = 0; i &lt; n.length; i++) {
      if (ns[n[i]] == null) {
        ns[n[i]] = {
          rows: [],
          o: null
        };
      }
      ns[n[i]].rows.push(i);
    }

    for (i = 0; i &lt; o.length; i++) {
      if (os[o[i]] == null) {
        os[o[i]] = {
          rows: [],
          n: null
        };
      }
      os[o[i]].rows.push(i);
    }

    for (i in ns) {
      if ( !hasOwn.call( ns, i ) ) {
        continue;
      }
      if (ns[i].rows.length == 1 &amp;&amp; typeof(os[i]) != &quot;undefined&quot; &amp;&amp; os[i].rows.length == 1) {
        n[ns[i].rows[0]] = {
          text: n[ns[i].rows[0]],
          row: os[i].rows[0]
        };
        o[os[i].rows[0]] = {
          text: o[os[i].rows[0]],
          row: ns[i].rows[0]
        };
      }
    }

    for (i = 0; i &lt; n.length - 1; i++) {
      if (n[i].text != null &amp;&amp; n[i + 1].text == null &amp;&amp; n[i].row + 1 &lt; o.length &amp;&amp; o[n[i].row + 1].text == null &amp;&amp;
      n[i + 1] == o[n[i].row + 1]) {
        n[i + 1] = {
          text: n[i + 1],
          row: n[i].row + 1
        };
        o[n[i].row + 1] = {
          text: o[n[i].row + 1],
          row: i + 1
        };
      }
    }

    for (i = n.length - 1; i &gt; 0; i--) {
      if (n[i].text != null &amp;&amp; n[i - 1].text == null &amp;&amp; n[i].row &gt; 0 &amp;&amp; o[n[i].row - 1].text == null &amp;&amp;
      n[i - 1] == o[n[i].row - 1]) {
        n[i - 1] = {
          text: n[i - 1],
          row: n[i].row - 1
        };
        o[n[i].row - 1] = {
          text: o[n[i].row - 1],
          row: i - 1
        };
      }
    }

    return {
      o: o,
      n: n
    };
  }

  return function(o, n) {
    o = o.replace(/\s+$/, &#x27;&#x27;);
    n = n.replace(/\s+$/, &#x27;&#x27;);
    var out = diff(o === &quot;&quot; ? [] : o.split(/\s+/), n === &quot;&quot; ? [] : n.split(/\s+/));

    var str = &quot;&quot;;
    var i;

    var oSpace = o.match(/\s+/g);
    if (oSpace == null) {
      oSpace = [&quot; &quot;];
    }
    else {
      oSpace.push(&quot; &quot;);
    }
    var nSpace = n.match(/\s+/g);
    if (nSpace == null) {
      nSpace = [&quot; &quot;];
    }
    else {
      nSpace.push(&quot; &quot;);
    }

    if (out.n.length === 0) {
      for (i = 0; i &lt; out.o.length; i++) {
        str += &#x27;&lt;del&gt;&#x27; + out.o[i] + oSpace[i] + &quot;&lt;/del&gt;&quot;;
      }
    }
    else {
      if (out.n[0].text == null) {
        for (n = 0; n &lt; out.o.length &amp;&amp; out.o[n].text == null; n++) {
          str += &#x27;&lt;del&gt;&#x27; + out.o[n] + oSpace[n] + &quot;&lt;/del&gt;&quot;;
        }
      }

      for (i = 0; i &lt; out.n.length; i++) {
        if (out.n[i].text == null) {
          str += &#x27;&lt;ins&gt;&#x27; + out.n[i] + nSpace[i] + &quot;&lt;/ins&gt;&quot;;
        }
        else {
          var pre = &quot;&quot;;

          for (n = out.n[i].row + 1; n &lt; out.o.length &amp;&amp; out.o[n].text == null; n++) {
            pre += &#x27;&lt;del&gt;&#x27; + out.o[n] + oSpace[n] + &quot;&lt;/del&gt;&quot;;
          }
          str += &quot; &quot; + out.n[i].text + nSpace[i] + pre;
        }
      }
    }

    return str;
  };
}());

// for CommonJS enviroments, export everything
if ( typeof exports !== &quot;undefined&quot; || typeof require !== &quot;undefined&quot; ) {
  extend(exports, QUnit);
}

// get at whatever the global object is, like window in browsers
}( (function() {return this;}.call()) ));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
