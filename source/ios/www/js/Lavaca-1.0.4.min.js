/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Contains components from or inspired by:

Simple Reset
(c) 2011 Eric Meyer
Released to public domain

jQuery v1.7.1
(c) 2011, John Resig
Dual licensed under the MIT or GPL Version 2 licenses.

Sizzle.js
(c) 2011, The Dojo Foundation
Released under the MIT, BSD, and GPL licenses.

Backbone.js 0.9.1 and Underscore.js 1.3.1
(c) 2012, Jeremy Ashkenas, DocumentCloud Inc
Released under the MIT license.

Dust.js v0.3.0
(c) 2010, Aleksander Williams
Released under the MIT license.

Zepto.js 0.8.0
(c) 2011 Thomas Fuchs
Released under the MIT license

ChildBrowser
(c) 2012 Jesse MacFadyen, Nitobi
Released under the MIT license

lz77.js
(c) 2009 Olle Törnström
Released under the MIT license

iScroll 4.1.9
(c) 2011 Matteo Spinelli
Released under the MIT license
*/

/* Zepto v1.0rc1 - polyfill zepto event detect fx ajax form touch - zeptojs.com/license */
;(function(undefined){
  if (String.prototype.trim === undefined) // fix for iOS 3.2
    String.prototype.trim = function(){ return this.replace(/^\s+/, '').replace(/\s+$/, '') }

  // For iOS 3.x
  // from https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduce
  if (Array.prototype.reduce === undefined)
    Array.prototype.reduce = function(fun){
      if(this === void 0 || this === null) throw new TypeError()
      var t = Object(this), len = t.length >>> 0, k = 0, accumulator
      if(typeof fun != 'function') throw new TypeError()
      if(len == 0 && arguments.length == 1) throw new TypeError()

      if(arguments.length >= 2)
       accumulator = arguments[1]
      else
        do{
          if(k in t){
            accumulator = t[k++]
            break
          }
          if(++k >= len) throw new TypeError()
        } while (true)

      while (k < len){
        if(k in t) accumulator = fun.call(undefined, accumulator, t[k], k, t)
        k++
      }
      return accumulator
    }

})()
var Zepto = (function() {
  var undefined, key, $, classList, emptyArray = [], slice = emptyArray.slice,
    document = window.document,
    elementDisplay = {}, classCache = {},
    getComputedStyle = document.defaultView.getComputedStyle,
    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },
    fragmentRE = /^\s*<(\w+|!)[^>]*>/,

    // Used by `$.zepto.init` to wrap elements, text/comment nodes, document,
    // and document fragment node types.
    elementTypes = [1, 3, 8, 9, 11],

    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],
    table = document.createElement('table'),
    tableRow = document.createElement('tr'),
    containers = {
      'tr': document.createElement('tbody'),
      'tbody': table, 'thead': table, 'tfoot': table,
      'td': tableRow, 'th': tableRow,
      '*': document.createElement('div')
    },
    readyRE = /complete|loaded|interactive/,
    classSelectorRE = /^\.([\w-]+)$/,
    idSelectorRE = /^#([\w-]+)$/,
    tagSelectorRE = /^[\w-]+$/,
    toString = ({}).toString,
    zepto = {},
    camelize, uniq,
    tempParent = document.createElement('div')

  zepto.matches = function(element, selector) {
    if (!element || element.nodeType !== 1) return false
    var matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector ||
                          element.oMatchesSelector || element.matchesSelector
    if (matchesSelector) return matchesSelector.call(element, selector)
    // fall back to performing a selector:
    var match, parent = element.parentNode, temp = !parent
    if (temp) (parent = tempParent).appendChild(element)
    match = ~zepto.qsa(parent, selector).indexOf(element)
    temp && tempParent.removeChild(element)
    return match
  }

  function isFunction(value) { return toString.call(value) == "[object Function]" }
  function isObject(value) { return value instanceof Object }
  function isPlainObject(value) {
    var key, ctor
    if (toString.call(value) !== "[object Object]") return false
    ctor = (isFunction(value.constructor) && value.constructor.prototype)
    if (!ctor || !hasOwnProperty.call(ctor, 'isPrototypeOf')) return false
    for (key in value);
    return key === undefined || hasOwnProperty.call(value, key)
  }
  function isArray(value) { return value instanceof Array }
  function likeArray(obj) { return typeof obj.length == 'number' }

  function compact(array) { return array.filter(function(item){ return item !== undefined && item !== null }) }
  function flatten(array) { return array.length > 0 ? [].concat.apply([], array) : array }
  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }
  function dasherize(str) {
    return str.replace(/::/g, '/')
           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
           .replace(/([a-z\d])([A-Z])/g, '$1_$2')
           .replace(/_/g, '-')
           .toLowerCase()
  }
  uniq = function(array){ return array.filter(function(item, idx){ return array.indexOf(item) == idx }) }

  function classRE(name) {
    return name in classCache ?
      classCache[name] : (classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'))
  }

  function maybeAddPx(name, value) {
    return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
  }

  function defaultDisplay(nodeName) {
    var element, display
    if (!elementDisplay[nodeName]) {
      element = document.createElement(nodeName)
      document.body.appendChild(element)
      display = getComputedStyle(element, '').getPropertyValue("display")
      element.parentNode.removeChild(element)
      display == "none" && (display = "block")
      elementDisplay[nodeName] = display
    }
    return elementDisplay[nodeName]
  }

  // `$.zepto.fragment` takes a html string and an optional tag name
  // to generate DOM nodes nodes from the given html string.
  // The generated DOM nodes are returned as an array.
  // This function can be overriden in plugins for example to make
  // it compatible with browsers that don't support the DOM fully.
  zepto.fragment = function(html, name) {
    if (name === undefined) name = fragmentRE.test(html) && RegExp.$1
    if (!(name in containers)) name = '*'
    var container = containers[name]
    container.innerHTML = '' + html
    return $.each(slice.call(container.childNodes), function(){
      container.removeChild(this)
    })
  }

  // `$.zepto.Z` swaps out the prototype of the given `dom` array
  // of nodes with `$.fn` and thus supplying all the Zepto functions
  // to the array. Note that `__proto__` is not supported on Internet
  // Explorer. This method can be overriden in plugins.
  zepto.Z = function(dom, selector) {
    dom = dom || []
    dom.__proto__ = arguments.callee.prototype
    dom.selector = selector || ''
    return dom
  }

  // `$.zepto.isZ` should return `true` if the given object is a Zepto
  // collection. This method can be overriden in plugins.
  zepto.isZ = function(object) {
    return object instanceof zepto.Z
  }

  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and
  // takes a CSS selector and an optional context (and handles various
  // special cases).
  // This method can be overriden in plugins.
  zepto.init = function(selector, context) {
    // If nothing given, return an empty Zepto collection
    if (!selector) return zepto.Z()
    // If a function is given, call it when the DOM is ready
    else if (isFunction(selector)) return $(document).ready(selector)
    // If a Zepto collection is given, juts return it
    else if (zepto.isZ(selector)) return selector
    else {
      var dom
      // normalize array if an array of nodes is given
      if (isArray(selector)) dom = compact(selector)
      // if a JavaScript object is given, return a copy of it
      // this is a somewhat peculiar option, but supported by
      // jQuery so we'll do it, too
      else if (isPlainObject(selector))
        dom = [$.extend({}, selector)], selector = null
      // wrap stuff like `document` or `window`
      else if (elementTypes.indexOf(selector.nodeType) >= 0 || selector === window)
        dom = [selector], selector = null
      // If it's a html fragment, create nodes from it
      else if (fragmentRE.test(selector))
        dom = zepto.fragment(selector.trim(), RegExp.$1), selector = null
      // If there's a context, create a collection on that context first, and select
      // nodes from there
      else if (context !== undefined) return $(context).find(selector)
      // And last but no least, if it's a CSS selector, use it to select nodes.
      else dom = zepto.qsa(document, selector)
      // create a new Zepto collection from the nodes found
      return zepto.Z(dom, selector)
    }
  }

  // `$` will be the base `Zepto` object. When calling this
  // function just call `$.zepto.init, whichs makes the implementation
  // details of selecting nodes and creating Zepto collections
  // patchable in plugins.
  $ = function(selector, context){
    return zepto.init(selector, context)
  }

  // Copy all but undefined properties from one or more
  // objects to the `target` object.
  $.extend = function(target){
    slice.call(arguments, 1).forEach(function(source) {
      for (key in source)
        if (source[key] !== undefined)
          target[key] = source[key]
    })
    return target
  }

  // `$.zepto.qsa` is Zepto's CSS selector implementation which
  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
  // This method can be overriden in plugins.
  zepto.qsa = function(element, selector){
    var found
    return (element === document && idSelectorRE.test(selector)) ?
      ( (found = element.getElementById(RegExp.$1)) ? [found] : emptyArray ) :
      (element.nodeType !== 1 && element.nodeType !== 9) ? emptyArray :
      slice.call(
        classSelectorRE.test(selector) ? element.getElementsByClassName(RegExp.$1) :
        tagSelectorRE.test(selector) ? element.getElementsByTagName(selector) :
        element.querySelectorAll(selector)
      )
  }

  function filtered(nodes, selector) {
    return selector === undefined ? $(nodes) : $(nodes).filter(selector)
  }

  function funcArg(context, arg, idx, payload) {
   return isFunction(arg) ? arg.call(context, idx, payload) : arg
  }

  $.isFunction = isFunction
  $.isObject = isObject
  $.isArray = isArray
  $.isPlainObject = isPlainObject

  $.inArray = function(elem, array, i){
    return emptyArray.indexOf.call(array, elem, i)
  }

  $.trim = function(str) { return str.trim() }

  // plugin compatibility
  $.uuid = 0

  $.map = function(elements, callback){
    var value, values = [], i, key
    if (likeArray(elements))
      for (i = 0; i < elements.length; i++) {
        value = callback(elements[i], i)
        if (value != null) values.push(value)
      }
    else
      for (key in elements) {
        value = callback(elements[key], key)
        if (value != null) values.push(value)
      }
    return flatten(values)
  }

  $.each = function(elements, callback){
    var i, key
    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++)
        if (callback.call(elements[i], i, elements[i]) === false) return elements
    } else {
      for (key in elements)
        if (callback.call(elements[key], key, elements[key]) === false) return elements
    }

    return elements
  }

  // Define methods that will be available on all
  // Zepto collections
  $.fn = {
    // Because a collection acts like an array
    // copy over these useful array functions.
    forEach: emptyArray.forEach,
    reduce: emptyArray.reduce,
    push: emptyArray.push,
    indexOf: emptyArray.indexOf,
    concat: emptyArray.concat,

    // `map` and `slice` in the jQuery API work differently
    // from their array counterparts
    map: function(fn){
      return $.map(this, function(el, i){ return fn.call(el, i, el) })
    },
    slice: function(){
      return $(slice.apply(this, arguments))
    },

    ready: function(callback){
      if (readyRE.test(document.readyState)) callback($)
      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)
      return this
    },
    get: function(idx){
      return idx === undefined ? slice.call(this) : this[idx]
    },
    toArray: function(){ return this.get() },
    size: function(){
      return this.length
    },
    remove: function(){
      return this.each(function(){
        if (this.parentNode != null)
          this.parentNode.removeChild(this)
      })
    },
    each: function(callback){
      this.forEach(function(el, idx){ callback.call(el, idx, el) })
      return this
    },
    filter: function(selector){
      return $([].filter.call(this, function(element){
        return zepto.matches(element, selector)
      }))
    },
    add: function(selector,context){
      return $(uniq(this.concat($(selector,context))))
    },
    is: function(selector){
      return this.length > 0 && zepto.matches(this[0], selector)
    },
    not: function(selector){
      var nodes=[]
      if (isFunction(selector) && selector.call !== undefined)
        this.each(function(idx){
          if (!selector.call(this,idx)) nodes.push(this)
        })
      else {
        var excludes = typeof selector == 'string' ? this.filter(selector) :
          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
        this.forEach(function(el){
          if (excludes.indexOf(el) < 0) nodes.push(el)
        })
      }
      return $(nodes)
    },
    eq: function(idx){
      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)
    },
    first: function(){
      var el = this[0]
      return el && !isObject(el) ? el : $(el)
    },
    last: function(){
      var el = this[this.length - 1]
      return el && !isObject(el) ? el : $(el)
    },
    find: function(selector){
      var result
      if (this.length == 1) result = zepto.qsa(this[0], selector)
      else result = this.map(function(){ return zepto.qsa(this, selector) })
      return $(result)
    },
    closest: function(selector, context){
      var node = this[0]
      while (node && !zepto.matches(node, selector))
        node = node !== context && node !== document && node.parentNode
      return $(node)
    },
    parents: function(selector){
      var ancestors = [], nodes = this
      while (nodes.length > 0)
        nodes = $.map(nodes, function(node){
          if ((node = node.parentNode) && node !== document && ancestors.indexOf(node) < 0) {
            ancestors.push(node)
            return node
          }
        })
      return filtered(ancestors, selector)
    },
    parent: function(selector){
      return filtered(uniq(this.pluck('parentNode')), selector)
    },
    children: function(selector){
      return filtered(this.map(function(){ return slice.call(this.children) }), selector)
    },
    siblings: function(selector){
      return filtered(this.map(function(i, el){
        return slice.call(el.parentNode.children).filter(function(child){ return child!==el })
      }), selector)
    },
    empty: function(){
      return this.each(function(){ this.innerHTML = '' })
    },
    // `pluck` is borrowed from Prototype.js
    pluck: function(property){
      return this.map(function(){ return this[property] })
    },
    show: function(){
      return this.each(function(){
        this.style.display == "none" && (this.style.display = null)
        if (getComputedStyle(this, '').getPropertyValue("display") == "none")
          this.style.display = defaultDisplay(this.nodeName)
      })
    },
    replaceWith: function(newContent){
      return this.before(newContent).remove()
    },
    wrap: function(newContent){
      return this.each(function(){
        $(this).wrapAll($(newContent)[0].cloneNode(false))
      })
    },
    wrapAll: function(newContent){
      if (this[0]) {
        $(this[0]).before(newContent = $(newContent))
        newContent.append(this)
      }
      return this
    },
    unwrap: function(){
      this.parent().each(function(){
        $(this).replaceWith($(this).children())
      })
      return this
    },
    clone: function(){
      return $(this.map(function(){ return this.cloneNode(true) }))
    },
    hide: function(){
      return this.css("display", "none")
    },
    toggle: function(setting){
      return (setting === undefined ? this.css("display") == "none" : setting) ? this.show() : this.hide()
    },
    prev: function(){ return $(this.pluck('previousElementSibling')) },
    next: function(){ return $(this.pluck('nextElementSibling')) },
    html: function(html){
      return html === undefined ?
        (this.length > 0 ? this[0].innerHTML : null) :
        this.each(function(idx){
          var originHtml = this.innerHTML
          $(this).empty().append( funcArg(this, html, idx, originHtml) )
        })
    },
    text: function(text){
      return text === undefined ?
        (this.length > 0 ? this[0].textContent : null) :
        this.each(function(){ this.textContent = text })
    },
    attr: function(name, value){
      var result
      return (typeof name == 'string' && value === undefined) ?
        (this.length == 0 || this[0].nodeType !== 1 ? undefined :
          (name == 'value' && this[0].nodeName == 'INPUT') ? this.val() :
          (!(result = this[0].getAttribute(name)) && name in this[0]) ? this[0][name] : result
        ) :
        this.each(function(idx){
          if (this.nodeType !== 1) return
          if (isObject(name)) for (key in name) this.setAttribute(key, name[key])
          else this.setAttribute(name, funcArg(this, value, idx, this.getAttribute(name)))
        })
    },
    removeAttr: function(name){
      return this.each(function(){ if (this.nodeType === 1) this.removeAttribute(name) })
    },
    prop: function(name, value){
      return (value === undefined) ?
        (this[0] ? this[0][name] : undefined) :
        this.each(function(idx){
          this[name] = funcArg(this, value, idx, this[name])
        })
    },
    data: function(name, value){
      var data = this.attr('data-' + dasherize(name), value)
      return data !== null ? data : undefined
    },
    val: function(value){
      return (value === undefined) ?
        (this.length > 0 ? this[0].value : undefined) :
        this.each(function(idx){
          this.value = funcArg(this, value, idx, this.value)
        })
    },
    offset: function(){
      if (this.length==0) return null
      var obj = this[0].getBoundingClientRect()
      return {
        left: obj.left + window.pageXOffset,
        top: obj.top + window.pageYOffset,
        width: obj.width,
        height: obj.height
      }
    },
    css: function(property, value){
      if (value === undefined && typeof property == 'string')
        return (
          this.length == 0
            ? undefined
            : this[0].style[camelize(property)] || getComputedStyle(this[0], '').getPropertyValue(property))

      var css = ''
      for (key in property)
        if(typeof property[key] == 'string' && property[key] == '')
          this.each(function(){ this.style.removeProperty(dasherize(key)) })
        else
          css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'

      if (typeof property == 'string')
        if (value == '')
          this.each(function(){ this.style.removeProperty(dasherize(property)) })
        else
          css = dasherize(property) + ":" + maybeAddPx(property, value)

      return this.each(function(){ this.style.cssText += ';' + css })
    },
    index: function(element){
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])
    },
    hasClass: function(name){
      if (this.length < 1) return false
      else return classRE(name).test(this[0].className)
    },
    addClass: function(name){
      return this.each(function(idx){
        classList = []
        var cls = this.className, newName = funcArg(this, name, idx, cls)
        newName.split(/\s+/g).forEach(function(klass){
          if (!$(this).hasClass(klass)) classList.push(klass)
        }, this)
        classList.length && (this.className += (cls ? " " : "") + classList.join(" "))
      })
    },
    removeClass: function(name){
      return this.each(function(idx){
        if (name === undefined)
          return this.className = ''
        classList = this.className
        funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass){
          classList = classList.replace(classRE(klass), " ")
        })
        this.className = classList.trim()
      })
    },
    toggleClass: function(name, when){
      return this.each(function(idx){
        var newName = funcArg(this, name, idx, this.className)
        ;(when === undefined ? !$(this).hasClass(newName) : when) ?
          $(this).addClass(newName) : $(this).removeClass(newName)
      })
    }
  }

  // Generate the `width` and `height` functions
  ;['width', 'height'].forEach(function(dimension){
    $.fn[dimension] = function(value){
      var offset, Dimension = dimension.replace(/./, function(m){ return m[0].toUpperCase() })
      if (value === undefined) return this[0] == window ? window['inner' + Dimension] :
        this[0] == document ? document.documentElement['offset' + Dimension] :
        (offset = this.offset()) && offset[dimension]
      else return this.each(function(idx){
        var el = $(this)
        el.css(dimension, funcArg(this, value, idx, el[dimension]()))
      })
    }
  })

  function insert(operator, target, node) {
    var parent = (operator % 2) ? target : target.parentNode
    parent ? parent.insertBefore(node,
      !operator ? target.nextSibling :      // after
      operator == 1 ? parent.firstChild :   // prepend
      operator == 2 ? target :              // before
      null) :                               // append
      $(node).remove()
  }

  function traverseNode(node, fun) {
    fun(node)
    for (var key in node.childNodes) traverseNode(node.childNodes[key], fun)
  }

  // Generate the `after`, `prepend`, `before`, `append`,
  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
  adjacencyOperators.forEach(function(key, operator) {
    $.fn[key] = function(){
      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings
      var nodes = $.map(arguments, function(n){ return isObject(n) ? n : zepto.fragment(n) })
      if (nodes.length < 1) return this
      var size = this.length, copyByClone = size > 1, inReverse = operator < 2

      return this.each(function(index, target){
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[inReverse ? nodes.length-i-1 : i]
          traverseNode(node, function(node){
            if (node.nodeName != null && node.nodeName.toUpperCase() === 'SCRIPT' && (!node.type || node.type === 'text/javascript'))
              window['eval'].call(window, node.innerHTML)
          })
          if (copyByClone && index < size - 1) node = node.cloneNode(true)
          insert(operator, target, node)
        }
      })
    }

    $.fn[(operator % 2) ? key+'To' : 'insert'+(operator ? 'Before' : 'After')] = function(html){
      $(html)[key](this)
      return this
    }
  })

  zepto.Z.prototype = $.fn

  // Export internal API functions in the `$.zepto` namespace
  zepto.camelize = camelize
  zepto.uniq = uniq
  $.zepto = zepto

  return $
})()

// If `$` is not yet defined, point it to `Zepto`
window.Zepto = Zepto
'$' in window || (window.$ = Zepto)
;(function($){
  var $$ = $.zepto.qsa, handlers = {}, _zid = 1, specialEvents={}

  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'

  function zid(element) {
    return element._zid || (element._zid = _zid++)
  }
  function findHandlers(element, event, fn, selector) {
    event = parse(event)
    if (event.ns) var matcher = matcherFor(event.ns)
    return (handlers[zid(element)] || []).filter(function(handler) {
      return handler
        && (!event.e  || handler.e == event.e)
        && (!event.ns || matcher.test(handler.ns))
        && (!fn       || zid(handler.fn) === zid(fn))
        && (!selector || handler.sel == selector)
    })
  }
  function parse(event) {
    var parts = ('' + event).split('.')
    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}
  }
  function matcherFor(ns) {
    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')
  }

  function eachEvent(events, fn, iterator){
    if ($.isObject(events)) $.each(events, iterator)
    else events.split(/\s/).forEach(function(type){ iterator(type, fn) })
  }

  function add(element, events, fn, selector, getDelegate, capture){
    capture = !!capture
    var id = zid(element), set = (handlers[id] || (handlers[id] = []))
    eachEvent(events, fn, function(event, fn){
      var delegate = getDelegate && getDelegate(fn, event),
        callback = delegate || fn
      var proxyfn = function (event) {
        var result = callback.apply(element, [event].concat(event.data))
        if (result === false) event.preventDefault()
        return result
      }
      var handler = $.extend(parse(event), {fn: fn, proxy: proxyfn, sel: selector, del: delegate, i: set.length})
      set.push(handler)
      element.addEventListener(handler.e, proxyfn, capture)
    })
  }
  function remove(element, events, fn, selector){
    var id = zid(element)
    eachEvent(events || '', fn, function(event, fn){
      findHandlers(element, event, fn, selector).forEach(function(handler){
        delete handlers[id][handler.i]
        element.removeEventListener(handler.e, handler.proxy, false)
      })
    })
  }

  $.event = { add: add, remove: remove }

  $.proxy = function(fn, context) {
    if ($.isFunction(fn)) {
      var proxyFn = function(){ return fn.apply(context, arguments) }
      proxyFn._zid = zid(fn)
      return proxyFn
    } else if (typeof context == 'string') {
      return $.proxy(fn[context], fn)
    } else {
      throw new TypeError("expected function")
    }
  }

  $.fn.bind = function(event, callback){
    return this.each(function(){
      add(this, event, callback)
    })
  }
  $.fn.unbind = function(event, callback){
    return this.each(function(){
      remove(this, event, callback)
    })
  }
  $.fn.one = function(event, callback){
    return this.each(function(i, element){
      add(this, event, callback, null, function(fn, type){
        return function(){
          var result = fn.apply(element, arguments)
          remove(element, type, fn)
          return result
        }
      })
    })
  }

  var returnTrue = function(){return true},
      returnFalse = function(){return false},
      eventMethods = {
        preventDefault: 'isDefaultPrevented',
        stopImmediatePropagation: 'isImmediatePropagationStopped',
        stopPropagation: 'isPropagationStopped'
      }
  function createProxy(event) {
    var proxy = $.extend({originalEvent: event}, event)
    $.each(eventMethods, function(name, predicate) {
      proxy[name] = function(){
        this[predicate] = returnTrue
        return event[name].apply(event, arguments)
      }
      proxy[predicate] = returnFalse
    })
    return proxy
  }

  // emulates the 'defaultPrevented' property for browsers that have none
  function fix(event) {
    if (!('defaultPrevented' in event)) {
      event.defaultPrevented = false
      var prevent = event.preventDefault
      event.preventDefault = function() {
        this.defaultPrevented = true
        prevent.call(this)
      }
    }
  }

  $.fn.delegate = function(selector, event, callback){
    var capture = false
    if(event == 'blur' || event == 'focus'){
      if($.iswebkit)
        event = event == 'blur' ? 'focusout' : event == 'focus' ? 'focusin' : event
      else
        capture = true
    }

    return this.each(function(i, element){
      add(element, event, callback, selector, function(fn){
        return function(e){
          var evt, match = $(e.target).closest(selector, element).get(0)
          if (match) {
            evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})
            return fn.apply(match, [evt].concat([].slice.call(arguments, 1)))
          }
        }
      }, capture)
    })
  }
  $.fn.undelegate = function(selector, event, callback){
    return this.each(function(){
      remove(this, event, callback, selector)
    })
  }

  $.fn.live = function(event, callback){
    $(document.body).delegate(this.selector, event, callback)
    return this
  }
  $.fn.die = function(event, callback){
    $(document.body).undelegate(this.selector, event, callback)
    return this
  }

  $.fn.on = function(event, selector, callback){
    return selector == undefined || $.isFunction(selector) ?
      this.bind(event, selector) : this.delegate(selector, event, callback)
  }
  $.fn.off = function(event, selector, callback){
    return selector == undefined || $.isFunction(selector) ?
      this.unbind(event, selector) : this.undelegate(selector, event, callback)
  }

  $.fn.trigger = function(event, data){
    if (typeof event == 'string') event = $.Event(event)
    fix(event)
    event.data = data
    return this.each(function(){
      // items in the collection might not be DOM elements
      // (todo: possibly support events on plain old objects)
      if('dispatchEvent' in this) this.dispatchEvent(event)
    })
  }

  // triggers event handlers on current element just as if an event occurred,
  // doesn't trigger an actual event, doesn't bubble
  $.fn.triggerHandler = function(event, data){
    var e, result
    this.each(function(i, element){
      e = createProxy(typeof event == 'string' ? $.Event(event) : event)
      e.data = data
      e.target = element
      $.each(findHandlers(element, event.type || event), function(i, handler){
        result = handler.proxy(e)
        if (e.isImmediatePropagationStopped()) return false
      })
    })
    return result
  }

  // shortcut methods for `.bind(event, fn)` for each event type
  ;('focusin focusout load resize scroll unload click dblclick '+
  'mousedown mouseup mousemove mouseover mouseout '+
  'change select keydown keypress keyup error').split(' ').forEach(function(event) {
    $.fn[event] = function(callback){ return this.bind(event, callback) }
  })

  ;['focus', 'blur'].forEach(function(name) {
    $.fn[name] = function(callback) {
      if (callback) this.bind(name, callback)
      else if (this.length) try { this.get(0)[name]() } catch(e){}
      return this
    }
  })

  $.Event = function(type, props) {
    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true
    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])
    event.initEvent(type, bubbles, true, null, null, null, null, null, null, null, null, null, null, null, null)
    return event
  }

})(Zepto)
;(function($){
  function detect(ua){
    var os = this.os = {}, browser = this.browser = {},
      webkit = ua.match(/WebKit\/([\d.]+)/),
      android = ua.match(/(Android)\s+([\d.]+)/),
      ipad = ua.match(/(iPad).*OS\s([\d_]+)/),
      iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/),
      webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),
      touchpad = webos && ua.match(/TouchPad/),
      kindle = ua.match(/Kindle\/([\d.]+)/),
      silk = ua.match(/Silk\/([\d._]+)/),
      blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/)

    // todo clean this up with a better OS/browser
    // separation. we need to discern between multiple
    // browsers on android, and decide if kindle fire in
    // silk mode is android or not

    if (browser.webkit = !!webkit) browser.version = webkit[1]

    if (android) os.android = true, os.version = android[2]
    if (iphone) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.')
    if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.')
    if (webos) os.webos = true, os.version = webos[2]
    if (touchpad) os.touchpad = true
    if (blackberry) os.blackberry = true, os.version = blackberry[2]
    if (kindle) os.kindle = true, os.version = kindle[1]
    if (silk) browser.silk = true, browser.version = silk[1]
    if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true
  }

  detect.call($, navigator.userAgent)
  // make available to unit tests
  $.__detect = detect

})(Zepto)
;(function($, undefined){
  var prefix = '', eventPrefix, endEventName, endAnimationName,
    vendors = { Webkit: 'webkit', Moz: '', O: 'o', ms: 'MS' },
    document = window.document, testEl = document.createElement('div'),
    supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,
    clearProperties = {}

  function downcase(str) { return str.toLowerCase() }
  function normalizeEvent(name) { return eventPrefix ? eventPrefix + name : downcase(name) }

  $.each(vendors, function(vendor, event){
    if (testEl.style[vendor + 'TransitionProperty'] !== undefined) {
      prefix = '-' + downcase(vendor) + '-'
      eventPrefix = event
      return false
    }
  })

  clearProperties[prefix + 'transition-property'] =
  clearProperties[prefix + 'transition-duration'] =
  clearProperties[prefix + 'transition-timing-function'] =
  clearProperties[prefix + 'animation-name'] =
  clearProperties[prefix + 'animation-duration'] = ''

  $.fx = {
    off: (eventPrefix === undefined && testEl.style.transitionProperty === undefined),
    cssPrefix: prefix,
    transitionEnd: normalizeEvent('TransitionEnd'),
    animationEnd: normalizeEvent('AnimationEnd')
  }

  $.fn.animate = function(properties, duration, ease, callback){
    if ($.isObject(duration))
      ease = duration.easing, callback = duration.complete, duration = duration.duration
    if (duration) duration = duration / 1000
    return this.anim(properties, duration, ease, callback)
  }

  $.fn.anim = function(properties, duration, ease, callback){
    var transforms, cssProperties = {}, key, that = this, wrappedCallback, endEvent = $.fx.transitionEnd
    if (duration === undefined) duration = 0.4
    if ($.fx.off) duration = 0

    if (typeof properties == 'string') {
      // keyframe animation
      cssProperties[prefix + 'animation-name'] = properties
      cssProperties[prefix + 'animation-duration'] = duration + 's'
      endEvent = $.fx.animationEnd
    } else {
      // CSS transitions
      for (key in properties)
        if (supportedTransforms.test(key)) {
          transforms || (transforms = [])
          transforms.push(key + '(' + properties[key] + ')')
        }
        else cssProperties[key] = properties[key]

      if (transforms) cssProperties[prefix + 'transform'] = transforms.join(' ')
      if (!$.fx.off && typeof properties === 'object') {
        cssProperties[prefix + 'transition-property'] = Object.keys(properties).join(', ')
        cssProperties[prefix + 'transition-duration'] = duration + 's'
        cssProperties[prefix + 'transition-timing-function'] = (ease || 'linear')
      }
    }

    wrappedCallback = function(event){
      if (typeof event !== 'undefined') {
        if (event.target !== event.currentTarget) return // makes sure the event didn't bubble from "below"
        $(event.target).unbind(endEvent, arguments.callee)
      }
      $(this).css(clearProperties)
      callback && callback.call(this)
    }
    if (duration > 0) this.bind(endEvent, wrappedCallback)

    setTimeout(function() {
      that.css(cssProperties)
      if (duration <= 0) setTimeout(function() {
        that.each(function(){ wrappedCallback.call(this) })
      }, 0)
    }, 0)

    return this
  }

  testEl = null
})(Zepto)
;(function($){
  var jsonpID = 0,
      isObject = $.isObject,
      document = window.document,
      key,
      name,
      rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      scriptTypeRE = /^(?:text|application)\/javascript/i,
      xmlTypeRE = /^(?:text|application)\/xml/i,
      jsonType = 'application/json',
      htmlType = 'text/html',
      blankRE = /^\s*$/

  // trigger a custom event and return false if it was cancelled
  function triggerAndReturn(context, eventName, data) {
    var event = $.Event(eventName)
    $(context).trigger(event, data)
    return !event.defaultPrevented
  }

  // trigger an Ajax "global" event
  function triggerGlobal(settings, context, eventName, data) {
    if (settings.global) return triggerAndReturn(context || document, eventName, data)
  }

  // Number of active Ajax requests
  $.active = 0

  function ajaxStart(settings) {
    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')
  }
  function ajaxStop(settings) {
    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')
  }

  // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
  function ajaxBeforeSend(xhr, settings) {
    var context = settings.context
    if (settings.beforeSend.call(context, xhr, settings) === false ||
        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)
      return false

    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])
  }
  function ajaxSuccess(data, xhr, settings) {
    var context = settings.context, status = 'success'
    settings.success.call(context, data, status, xhr)
    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])
    ajaxComplete(status, xhr, settings)
  }
  // type: "timeout", "error", "abort", "parsererror"
  function ajaxError(error, type, xhr, settings) {
    var context = settings.context
    settings.error.call(context, xhr, type, error)
    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error])
    ajaxComplete(type, xhr, settings)
  }
  // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
  function ajaxComplete(status, xhr, settings) {
    var context = settings.context
    settings.complete.call(context, xhr, status)
    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])
    ajaxStop(settings)
  }

  // Empty function, used as default callback
  function empty() {}

  $.ajaxJSONP = function(options){
    var callbackName = 'jsonp' + (++jsonpID),
      script = document.createElement('script'),
      abort = function(){
        $(script).remove()
        if (callbackName in window) window[callbackName] = empty
        ajaxComplete('abort', xhr, options)
      },
      xhr = { abort: abort }, abortTimeout

    if (options.error) script.onerror = function() {
      xhr.abort()
      options.error()
    }

    window[callbackName] = function(data){
      clearTimeout(abortTimeout)
      $(script).remove()
      delete window[callbackName]
      ajaxSuccess(data, xhr, options)
    }

    serializeData(options)
    script.src = options.url.replace(/=\?/, '=' + callbackName)
    $('head').append(script)

    if (options.timeout > 0) abortTimeout = setTimeout(function(){
        xhr.abort()
        ajaxComplete('timeout', xhr, options)
      }, options.timeout)

    return xhr
  }

  $.ajaxSettings = {
    // Default type of request
    type: 'GET',
    // Callback that is executed before request
    beforeSend: empty,
    // Callback that is executed if the request succeeds
    success: empty,
    // Callback that is executed the the server drops error
    error: empty,
    // Callback that is executed on request complete (both: error and success)
    complete: empty,
    // The context for the callbacks
    context: null,
    // Whether to trigger "global" Ajax events
    global: true,
    // Transport
    xhr: function () {
      return new window.XMLHttpRequest()
    },
    // MIME types mapping
    accepts: {
      script: 'text/javascript, application/javascript',
      json:   jsonType,
      xml:    'application/xml, text/xml',
      html:   htmlType,
      text:   'text/plain'
    },
    // Whether the request is to another domain
    crossDomain: false,
    // Default timeout
    timeout: 0
  }

  function mimeToDataType(mime) {
    return mime && ( mime == htmlType ? 'html' :
      mime == jsonType ? 'json' :
      scriptTypeRE.test(mime) ? 'script' :
      xmlTypeRE.test(mime) && 'xml' ) || 'text'
  }

  function appendQuery(url, query) {
    return (url + '&' + query).replace(/[&?]{1,2}/, '?')
  }

  // serialize payload and append it to the URL for GET requests
  function serializeData(options) {
    if (isObject(options.data)) options.data = $.param(options.data)
    if (options.data && (!options.type || options.type.toUpperCase() == 'GET'))
      options.url = appendQuery(options.url, options.data)
  }

  $.ajax = function(options){
    var settings = $.extend({}, options || {})
    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]

    ajaxStart(settings)

    if (!settings.crossDomain) settings.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(settings.url) &&
      RegExp.$2 != window.location.host

    var dataType = settings.dataType, hasPlaceholder = /=\?/.test(settings.url)
    if (dataType == 'jsonp' || hasPlaceholder) {
      if (!hasPlaceholder) settings.url = appendQuery(settings.url, 'callback=?')
      return $.ajaxJSONP(settings)
    }

    if (!settings.url) settings.url = window.location.toString()
    serializeData(settings)

    var mime = settings.accepts[dataType],
        baseHeaders = { },
        protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
        xhr = $.ajaxSettings.xhr(), abortTimeout

    if (!settings.crossDomain) baseHeaders['X-Requested-With'] = 'XMLHttpRequest'
    if (mime) {
      baseHeaders['Accept'] = mime
      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]
      xhr.overrideMimeType && xhr.overrideMimeType(mime)
    }
    if (settings.contentType || (settings.data && settings.type.toUpperCase() != 'GET'))
      baseHeaders['Content-Type'] = (settings.contentType || 'application/x-www-form-urlencoded')
    settings.headers = $.extend(baseHeaders, settings.headers || {})

    xhr.onreadystatechange = function(){
      if (xhr.readyState == 4) {
        clearTimeout(abortTimeout)
        var result, error = false
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {
          dataType = dataType || mimeToDataType(xhr.getResponseHeader('content-type'))
          result = xhr.responseText

          try {
            if (dataType == 'script')    (1,eval)(result)
            else if (dataType == 'xml')  result = xhr.responseXML
            else if (dataType == 'json') result = blankRE.test(result) ? null : JSON.parse(result)
          } catch (e) { error = e }

          if (error) ajaxError(error, 'parsererror', xhr, settings)
          else ajaxSuccess(result, xhr, settings)
        } else {
          ajaxError(null, 'error', xhr, settings)
        }
      }
    }

    var async = 'async' in settings ? settings.async : true
    xhr.open(settings.type, settings.url, async)

    for (name in settings.headers) xhr.setRequestHeader(name, settings.headers[name])

    if (ajaxBeforeSend(xhr, settings) === false) {
      xhr.abort()
      return false
    }

    if (settings.timeout > 0) abortTimeout = setTimeout(function(){
        xhr.onreadystatechange = empty
        xhr.abort()
        ajaxError(null, 'timeout', xhr, settings)
      }, settings.timeout)

    // avoid sending empty string (#319)
    xhr.send(settings.data ? settings.data : null)
    return xhr
  }

  $.get = function(url, success){ return $.ajax({ url: url, success: success }) }

  $.post = function(url, data, success, dataType){
    if ($.isFunction(data)) dataType = dataType || success, success = data, data = null
    return $.ajax({ type: 'POST', url: url, data: data, success: success, dataType: dataType })
  }

  $.getJSON = function(url, success){
    return $.ajax({ url: url, success: success, dataType: 'json' })
  }

  $.fn.load = function(url, success){
    if (!this.length) return this
    var self = this, parts = url.split(/\s/), selector
    if (parts.length > 1) url = parts[0], selector = parts[1]
    $.get(url, function(response){
      self.html(selector ?
        $(document.createElement('div')).html(response.replace(rscript, "")).find(selector).html()
        : response)
      success && success.call(self)
    })
    return this
  }

  var escape = encodeURIComponent

  function serialize(params, obj, traditional, scope){
    var array = $.isArray(obj)
    $.each(obj, function(key, value) {
      if (scope) key = traditional ? scope : scope + '[' + (array ? '' : key) + ']'
      // handle data in serializeArray() format
      if (!scope && array) params.add(value.name, value.value)
      // recurse into nested objects
      else if (traditional ? $.isArray(value) : isObject(value))
        serialize(params, value, traditional, key)
      else params.add(key, value)
    })
  }

  $.param = function(obj, traditional){
    var params = []
    params.add = function(k, v){ this.push(escape(k) + '=' + escape(v)) }
    serialize(params, obj, traditional)
    return params.join('&').replace('%20', '+')
  }
})(Zepto)
;(function ($) {
  $.fn.serializeArray = function () {
    var result = [], el
    $( Array.prototype.slice.call(this.get(0).elements) ).each(function () {
      el = $(this)
      var type = el.attr('type')
      if (this.nodeName.toLowerCase() != 'fieldset' &&
        !this.disabled && type != 'submit' && type != 'reset' && type != 'button' &&
        ((type != 'radio' && type != 'checkbox') || this.checked))
        result.push({
          name: el.attr('name'),
          value: el.val()
        })
    })
    return result
  }

  $.fn.serialize = function () {
    var result = []
    this.serializeArray().forEach(function (elm) {
      result.push( encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value) )
    })
    return result.join('&')
  }

  $.fn.submit = function (callback) {
    if (callback) this.bind('submit', callback)
    else if (this.length) {
      var event = $.Event('submit')
      this.eq(0).trigger(event)
      if (!event.defaultPrevented) this.get(0).submit()
    }
    return this
  }

})(Zepto)
;(function($){
  var touch = {}, touchTimeout

  function parentIfText(node){
    return 'tagName' in node ? node : node.parentNode
  }

  function swipeDirection(x1, x2, y1, y2){
    var xDelta = Math.abs(x1 - x2), yDelta = Math.abs(y1 - y2)
    return xDelta >= yDelta ? (x1 - x2 > 0 ? 'Left' : 'Right') : (y1 - y2 > 0 ? 'Up' : 'Down')
  }

  var longTapDelay = 750, longTapTimeout

  function longTap(){
    longTapTimeout = null
    if (touch.last) {
      touch.el.trigger('longTap')
      touch = {}
    }
  }

  function cancelLongTap(){
    if (longTapTimeout) clearTimeout(longTapTimeout)
    longTapTimeout = null
  }

  $(document).ready(function(){
    var now, delta

    $(document.body).bind('touchstart', function(e){
      now = Date.now()
      delta = now - (touch.last || now)
      touch.el = $(parentIfText(e.touches[0].target))
      touchTimeout && clearTimeout(touchTimeout)
      touch.x1 = e.touches[0].pageX
      touch.y1 = e.touches[0].pageY
      if (delta > 0 && delta <= 250) touch.isDoubleTap = true
      touch.last = now
      longTapTimeout = setTimeout(longTap, longTapDelay)
    }).bind('touchmove', function(e){
      cancelLongTap()
      touch.x2 = e.touches[0].pageX
      touch.y2 = e.touches[0].pageY
    }).bind('touchend', function(e){
       cancelLongTap()

      // double tap (tapped twice within 250ms)
      if (touch.isDoubleTap) {
        touch.el.trigger('doubleTap')
        touch = {}

      // swipe
      } else if ((touch.x2 && Math.abs(touch.x1 - touch.x2) > 30) ||
                 (touch.y2 && Math.abs(touch.y1 - touch.y2) > 30)) {
        touch.el.trigger('swipe') &&
          touch.el.trigger('swipe' + (swipeDirection(touch.x1, touch.x2, touch.y1, touch.y2)))
        touch = {}

      // normal tap
      } else if ('last' in touch) {
        touch.el.trigger('tap')

        touchTimeout = setTimeout(function(){
          touchTimeout = null
          touch.el.trigger('singleTap')
          touch = {}
        }, 250)
      }
    }).bind('touchcancel', function(){
      if (touchTimeout) clearTimeout(touchTimeout)
      if (longTapTimeout) clearTimeout(longTapTimeout)
      longTapTimeout = touchTimeout = null
      touch = {}
    })
  })

  ;['swipe', 'swipeLeft', 'swipeRight', 'swipeUp', 'swipeDown', 'doubleTap', 'tap', 'singleTap', 'longTap'].forEach(function(m){
    $.fn[m] = function(callback){ return this.bind(m, callback) }
  })
})(Zepto);
/*
x-dust 0.5.3

Copyright (c) 2012 Dan Nichols

Released under the MIT license.

dust.js 0.3.0

Copyright (c) 2010 Aleksander Williams

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

 */
(function() {

var BREAK = false,
    UNDEFINED,
    OPERATORS = ['~', '#', '?', '@', ':', '<', '>', '+', '/', '^'],
    OPERATORS_WITH_BODY = ['#', '?', '@', ':', '+', '<'],
    dust;

function _hasProp(obj, name) {
  return obj.hasOwnProperty(name);
}

function _isInstance(obj, T) {
  return obj instanceof T;
}

function _isObject(obj) {
  return typeof obj == 'object' && !_isInstance(obj, Array);
}

function _updateDict(dst, src) {
  if (src) {
    for (var name in src) {
      dst[name] = src[name];
    }
  }
  return dst;
}

function _startsWith(str, seq) {
  return str.indexOf(seq) == 0;
}

function _endsWith(str, seq) {
  return str.slice(-seq.length) == seq;
}

function _each(list, fn, thisp) {
  for (var i = 0, j = list.length; i < j; i++) {
    if (fn.call(thisp, i, list[i]) === BREAK) {
      break;
    }
  }
}

function _contains(list, item) {
  if (list.indexOf) {
    return list.indexOf(item) > -1;
  } else {
    for (var i = 0, j = list.length; i < j; i++) {
      if (list[i] == item) {
        return true;
      }
    }
  }
  return false;
}

function _stringify(o) {
  if (o === UNDEFINED) {
    return 'null';
  } else if (o === UNDEFINED || o === null || typeof o == 'number' || typeof o == 'string' || _isInstance(o, Date)) {
    return JSON.stringify(o);
  } else if (_isInstance(o, XDustNode)) {
    return o.toJSON();
  } else if (_isInstance(o, Array)) {
    var result = ['['],
        j = o.length - 1;
    _each(o, function(i, item) {
      result.push(_stringify(item));
      if (i < j) {
        result.push(',');
      }
    });
    result.push(']');
    return result.join('');
  } else {
    var result = ['{'],
        hadKeys = false,
        n;
    for (n in o) {
      result.push('"', dust.escapeJS(n), '":', _stringify(o[n]), ',');
      hadKeys = true;
    }
    if (hadKeys) {
      result.pop();
    }
    result.push('}');
    return result.join('');
  }
}

function _extend(TSuper, TSub, overrides) {
  if (!overrides) {
    overrides = TSub;
    TSub = TSuper;
    TSuper = {};
  }
  function ctor() {}
  ctor.prototype = TSuper.prototype;
  TSub.prototype = new ctor;
  if (overrides) {
    for (var prop in overrides) {
      TSub.prototype[prop] = overrides[prop];
    }
  }
  return TSub;
}

var XDustContext = _extend(function(head, tail, params) {
    this.head = head;
    this.tail = {};
    this.tailIsValue = !_isObject(tail);
    this.params = _updateDict({}, params);
    this.update(tail);
  }, {
    get: function(name) {
      if (!this.tailIsValue && _hasProp(this.tail, name)) {
        return this.tail[name];
      } else if (_hasProp(this.params, name)) {
        return this.params[name];
      } else if (this.head) {
        return this.head.get(name);
      } else {
        return UNDEFINED;
      }
    },
    set: function(name, value) {
      if (this.tailIsValue) {
        throw 'Cannot get property on value type';
      } else {
        this.tail[name] = value;
      }
    },
    update: function(other) {
      if (other !== UNDEFINED) {
        if (_isInstance(other, XDustContext)) {
          this.tailIsValue = other.tailIsValue;
          if (other.tailIsValue) {
            this.tail = other.tail;
          } else {
            if (this.tailIsValue) {
              this.tail = {};
              this.tailIsValue = false;
            }
            _updateDict(this.tail, other.tail);
          }
          _updateDict(this.params, other.params);
        } else if (_isObject(other)) {
          if (this.tailIsValue) {
            this.tail = {};
            this.tailIsValue = false;
          }
          for (var name in other) {
            this.set(name, other[name]);
          }
        } else {
          this.tailIsValue = true;
          this.tail = other;
        }
      }
    }
  }),
  XDustContextResolver = _extend(function(path) {
    if (_isInstance(path, Array)) {
      path = path.join('.');  
    }
    if (_startsWith(path, '.')) {
      this.path = ['.'].concat(path.slice(1).split('.'));
    } else {
      this.path = path.split('.');
    }
  }, {
    resolve: function(context, model) {
      var copy = new XDustContext(context, model, UNDEFINED);
      if (model) {
        if (_isInstance(model, Array)) {
          copy = [].concat(model);
        } else {
          _each(this.path, function(i, segment) {
            if (segment) {
              if (segment == '.') {
                if (copy.tailIsValue) {
                  copy = copy.tail;
                  return BREAK;
                } else {
                  copy.parent = UNDEFINED;
                }
              } else {
                var value = copy.get(segment);
                if (value !== UNDEFINED) {
                  copy = new XDustContext(copy, value, UNDEFINED);
                  if (copy.tailIsValue) {
                    copy = copy.tail;
                  }
                } else {
                  copy = UNDEFINED;
                  return BREAK;
                }
              }
            } else {
              copy = copy.tail;
              return BREAK;
            }
          }, this);
        }
      } else {
        copy = UNDEFINED;
      }
      return copy;
    }/*,
    toJSON: function() {
      return _stringify(this.path.join('.'));
    }*/
  }),
  XDustRenderChain = _extend(function(head, tail) {
    this.tail = tail;
    this.head = head;
  }, {
    getBlock: function(name) {
      var block = this.tail.getBlock(name);
      if (block) {
        return block;
      } else if (this.head) {
        return this.head.getBlock(name);
      } else {
        return UNDEFINED;
      }
    }
  }),
  XDustNode = _extend(function(blocks) {
    this.blocks = blocks || {};
  }, {
    render: function(chain, context, model) {
      throw 'Abstract';
    },
    getBlock: function(name) {
      if (this.hasBlock(name)) {
        return this.blocks[name].asBlock();
      } else {
        return UNDEFINED;
      }
    },
    setBlock: function(name, value) {
      this.blocks[name] = value;
    },
    hasBlock: function(name) {
      return this.blocks[name] !== UNDEFINED;
    },
    asBlock: function() {
      return this;
    }/*,
    toJSON: function() {
      throw 'Abstract';
    }*/
  }),
  XDustNodeList = _extend(XDustNode, function(blocks, nodes) {
    XDustNode.call(this, blocks, nodes);
    this.nodes = [].concat(nodes || []);
  }, {
    each: function(fn, thisp) {
      _each(this.nodes, fn, thisp || this);
    },
    add: function(node) {
      this.nodes[this.nodes.length] = node;
    },
    last: function() {
      return this.nodes[this.nodes.length - 1];
    },
    prepareModel: function(chain, context, model) {
      return new XDustContext(context, model, UNDEFINED);
    },
    render: function(chain, context, model) {
      chain = new XDustRenderChain(chain, this);
      model = this.prepareModel(chain, context, model);
      var sb = [];
      if (model !== UNDEFINED) {
        this.each(function(i, node) {
          sb[sb.length] = node.render(chain, context, model);
        });
      }
      return sb.join('');
    }/*,
    toJSON: function() {
      var result = [this.alias, '(['],
          i,
          j,
          node;
      for (i = 0, j = this.nodes.length; i < j; i++) {
        node = this.nodes[i];
        result.push(node.toJSON(), ',');
      }
      result.pop();
      result.push('])');
      return result.join('');
    }*/
  }),
  XDustTextNode = _extend(XDustNode, function(value, blocks) {
    XDustNode.call(this, blocks);
    value = value || '';
    this.buffer = [value];
    this.value = value;
  }, {
    write: function(value) {
      if (this.buffer) {
        this.buffer.push(value);
      } else {
        throw 'TextNode buffer is closed';
      }
    },
    close: function() {
      if (this.buffer) {
        this.value = this.buffer.join('');
        this.buffer = UNDEFINED;
      }
    },
    render: function(chain, context, model) {
      this.close();
      return this.value;
    }/*,
    toJSON: function() {
      return [this.alias, '(', _stringify(this.render()), ')'].join('');
    }*/
  }),
  XDustVariableNode = _extend(XDustNode, function(path, blocks, filters) {
    XDustNode.call(this, blocks);
    this.context = new XDustContextResolver(path);
    this.filters = [].concat(filters || []);
  }, {
    render: function(chain, context, model) {
      chain = new XDustRenderChain(chain, this);
      var origModel = model,
          result = '',
          flag;
      model = this.context.resolve(context, model);
      if (model !== UNDEFINED) {
        if (_isInstance(model, XDustNode)) {
          result = model.render(chain, context, origModel);
        } else if (_isInstance(model, XDustContextResolver)) {
          result = model.resolve(context, origModel);
        } else if (_isInstance(model, XDustContext)) {
          result = model.tail;
        } else {
          result = model.toString();
        }
        if (this.filters.length) {
          _each(this.filters, function(i, flag) {
            if (dust.filters[flag]) {
              result = dust.filters[flag](result);
            }
          });
        } else {
          result = dust.escapeHTML(result);
        }
      }
      return result;
    }/*,
    toJSON: function() {
      return [this.alias, '(', this.context.toJSON(), ',', _stringify(this.blocks), ',', _stringify(this.filters), ')'].join('');
    }*/
  }),
  XDustLogicNode = _extend(XDustNode, function(path, scope, params, blocks, bodies) {
    XDustNode.call(this, blocks);
    this.bodies = {};
    if (bodies) {
      _updateDict(this.bodies, bodies);
    } else {
      this.startBody('block');
    }
    this.params = _updateDict({}, params);
    this.context = path ? new XDustContextResolver(path) : UNDEFINED;
    this.scope = scope ? new XDustContextResolver(scope) : UNDEFINED;
  }, {
    allowIter: true,
    startBody: function(name) {
      return this.currentBody = this.bodies[name] = new XDustNodeList();
    },
    endBody: function() {
      this.currentBody = UNDEFINED;
    },
    prepareModel: function(chain, context, model) {
      var params = {},
          name,
          result;
      if (this.params) {
        for (name in this.params) {
          params[name] = this.params[name].render(chain, context, context);
        }
      }
      result = new XDustContext(context, model, params);
      result.update(model);
      return result;
    },
    renderBody: function(name, chain, context, model) {
      var sb = [],
          body = this.bodies[name];
      context = new XDustContext(context, model, this.params);
      if (this.scope) {
        model = this.scope.resolve(context, model);
      } else if (this.context && typeof this.context != 'string') {
        model = this.context.resolve(context, model);
      }
      if (body) {
        chain = new XDustRenderChain(chain, body);
        if (this.allowIter && _isInstance(model, Array)) {
          var length = model.length;
          if (name == 'else' && length < 1) {
            sb.push(body.render(chain, context, UNDEFINED));
          } else {
            _each(model, function(i, iterModel) {
              iterModel = this.prepareModel(chain, context, iterModel);
              _updateDict(iterModel.params, {
                "@idx": i,
                "@sep": i != length - 1
              });
              sb.push(body.render(chain, context, iterModel));
            }, this);
          }
        } else {
          model = this.prepareModel(chain, context, model);
          sb.push(body.render(chain, context, model));
        }
      }
      return sb.join('');
    },
    chooseBodyName: function(context, model) {
      var resolved = this.context.resolve(context, model);
      if (_isInstance(resolved, Array) && resolved.length < 1) {
        resolved = false;
      }
      return resolved ? 'block' : 'else';
    },
    render: function(chain, context, model) {
      chain = new XDustRenderChain(chain, this);
      context = new XDustContext(context, UNDEFINED, this.params);
      var bodyName = this.chooseBodyName(context, model);
      return this.renderBody(bodyName, chain, context, model);
    }/*,
    toJSON: function() {
      return [this.alias, '(', this.context.toJSON(), ',', (this.scope ? this.scope.toJSON() : 'null'), ',', _stringify(this.params), ',', _stringify(this.blocks), ',', _stringify(this.bodies), ')'].join('');
    }*/
  }),
  XDustExistsNode = _extend(XDustLogicNode, function() {
    XDustLogicNode.apply(this, arguments);
  }, {
    operator: '?',
    allowIter: false,
    prepareModel: function(chain, context, model) {
      return new XDustContext(context, context, this.params);
    }
  }),
  XDustNotExistsNode = _extend(XDustExistsNode, function() {
    XDustExistsNode.apply(this, arguments);
  }, {
    prepareModel: function(chain, context, model) {
      return this.context.resolve(context, model) ? 'else' : 'block';
    }
  }),
  XDustHelperNode = _extend(XDustLogicNode, function(name, scope, params, blocks, bodies) {
    XDustLogicNode.call(this, UNDEFINED, scope, params, blocks, bodies);
    this.context = name;
  }, {
    render: function(chain, context, model) {
      chain = new XDustRenderChain(chain, this);
      context = new XDustContext(this.params, context);
      return dust.helpers[this.context](chain, context, model);
    }
  }),
  XDustIndexNode = _extend(XDustNodeList, function() {
    XDustNodeList.apply(this, arguments);
  }, {
    prepareModel: function(chain, context, model) {
      if (model.get('@idx') !== UNDEFINED) {
        return model.get('@idx').toString();
      } else {
        return UNDEFINED;
      }
    }
  }),
  XDustSepNode = _extend(XDustNodeList, function() {
    XDustNodeList.apply(this, arguments);
  }, {
    prepareModel: function(chain, context, model) {
      if (model.get('@sep')) {
        return XDustNodeList.prototype.prepareModel.apply(this, arguments);
      } else {
        return UNDEFINED;
      }
    }
  }),
  XDustEscapedCharacterNode = _extend(XDustNode, function(code, blocks) {
    XDustNode.call(this, blocks);
    this.code = code;
    this.character = this.characters[code];
  }, {
    characters: {
      n: '\n',
      r: '\r',
      s: ' ',
      lb: '{',
      rb: '}'
    },
    render: function(chain, context, model) {
      return this.character;
    }/*,
    toJSON: function() {
      return [this.alias, '(', _stringify(this.code), ')'].join('');
    }*/
  }),
  XDustPartialNode = _extend(XDustNode, function(include, scope, blocks) {
    XDustNode.call(this, blocks);
    this.include = include;
    this.scope = scope ? new XDustContextResolver(scope) : UNDEFINED;
  }, {
    render: function(chain, context, model) {
      if (this.scope) {
        model = this.scope.resolve(context, model);
      }
      chain = new XDustRenderChain(chain, this);
      name = this.include;
      if (_isInstance(this.include, XDustNodeList)) {
        name = this.include.render(chain, context, model);
      }
      return dust.load(name).render(chain, context, model);
    }/*,
    toJSON: function() {
      return [this.alias, '(', _stringify(this.include), ',', _stringify(this.scope), ',', _stringify(this.blocks), ')'].join('');
    }*/
  }),
  XDustBlockNode = _extend(XDustNodeList, function(name, blocks, nodes) {
    XDustNodeList.call(this, blocks, nodes);
    this.name = name;
  }, {
    render: function(chain, context, model) {
      block = chain.getBlock(this.name);
      if (block) {
        return block.render(chain, context, model);
      } else {
        return XDustNodeList.prototype.render.apply(this, arguments);
      }
    }/*,
    toJSON: function() {
      return [this.alias, '(', _stringify(this.name), ',', _stringify(this.blocks), ',', _stringify(this.nodes), ')'].join('');
    }*/
  }),
  XDustInlinePartialNode = _extend(XDustNodeList, function(name, blocks, nodes) {
    XDustNodeList.call(this, blocks, nodes);
    this.name = name;
  }, {
    asBlock: function() {
      return new XDustNodeList(null, this.nodes);
    },
    render: function(chain, context, model) {
      return '';
    }/*,
    toJSON: function() {
      return [this.alias, '(', _stringify(this.name), ',', _stringify(this.blocks), ',', _stringify(this.nodes), ')'].join('');
    }*/
  }),
  XDustNodeListParser = _extend(function() {
    // pass
  }, {
    parse: function(str) {
      str = str.replace(/(\{![\s\S]+?!\})|(^\s+)|(\s+$)/g, '');
      var nodes = [new XDustNodeList()],
          depth = 0,
          exp = /(\{[\~\#\?\@\:\<\>\+\/\^]?([a-zA-Z0-9_\$\.]+|"[^"]+")(\:[a-zA-Z0-9\$\.]+)?(\|[a-z]+)*?( \w+\=(("[^"]*?")|([\w\.]+)))*?\/?\})/mg,
          lastEnd = 0,
          start,
          end,
          match,
          depthChange,
          node,
          head,
          tag,
          operator,
          tagName,
          scope,
          params,
          selfClosed,
          root,
          filters,
          tail,
          s,
          currentStr = str;
      function domatch(s) {
        return new RegExp('(\\{[\\~\\#\\?\\@\\:\\<\\>\\+\\/\\^]?([a-zA-Z0-9_\\$\\.]+|"[^"]+")(\\:[a-zA-Z0-9\\$\\.]+)?(\\|[a-z]+)*?( \\w+\\=(("[^"]*?")|([\\w\\.]+)))*?\\/?\\})', 'g').exec(s);
      }
      while (match = domatch(currentStr)) {
        depthChange = false;
        start = match.index;
        end = start + match[0].length;
        if (lastEnd != start) {
          head = currentStr.slice(0, start);
          if (head) {
            nodes[depth].add(new XDustTextNode(head));
          }
        }
        lastEnd = end;
        node = UNDEFINED;
        tag = currentStr.slice(start + 1, end - 1);
        operator = tag.charAt(0);
        tag = tag.split(' ');
        if (_contains(OPERATORS, operator)) {
          tagName = tag[0].slice(1).split(':');
          scope = tagName.length > 1 ? tagName[1] : UNDEFINED;
          tagName = tagName[0];
          params = UNDEFINED;
          s = tag[tag.length - 1];
          selfClosed = _endsWith(tagName, '/');
          if (selfClosed) {
            tagName = tagName.slice(0, -1);
          } else if (scope && _endsWith(scope, '/')) {
            scope = scope.slice(0, -1);
            selfClosed = true;
          } else if (s && _endsWith(s, '/')) {
            tag[tag.length - 1] = s.slice(0, -1);
            selfClosed = true;
          }
          if (operator == '~') {
            node = new XDustEscapedCharacterNode(tagName);
          } else if (operator == '#') {
            if (_hasProp(dust.helpers, tagName)) {
              node = new XDustHelperNode(tagName, scope, params);
            } else {
              node = new XDustLogicNode(tagName, scope, params);
            }
          } else if (operator == '?') {
            node = new XDustExistsNode(tagName, scope, params);
          } else if (operator == '@') {
            name = tag[0].slice(1);
            if (name == 'idx') {
              node = new XDustIndexNode();
            } else if (name == 'sep') {
              node = new XDustSepNode();
            }
          } else if (operator == '>') {
            if (tagName.charAt(0) == '"') {
              tagName = this.parse(tagName.replace(/^"|"$/g, ''));
            }
            node = new XDustPartialNode(tagName, scope);
          } else if (operator == '+') {
            node = new XDustBlockNode(tagName);
          } else if (operator == '<') {
            node = new XDustInlinePartialNode(tagName);
          } else {
            node = new XDustTextNode('UNDEFINED:' + tag.join(' '));
          }
          _each(tag.slice(1), function(i, param) {
            param = param.split('=');
            var name = param[0],
                value = param.slice(1).join('=');
            if (value.charAt(0) != '"') {
              value = new XDustVariableNode(value);
            } else {
              value = this.parse(value.replace(/(^")|("$)|("\/$)/g, ''));
            }
            node.params[name] = value;
          }, this);
          if (!selfClosed) {
            if (_contains(OPERATORS_WITH_BODY, operator)) {
              depthChange = true;
              if (_isInstance(node, XDustNodeList)) {
                if (_isInstance(node, XDustInlinePartialNode)) {
                  nodes[depth].setBlock(node.name, node);
                }
                nodes[depth].add(node);
                depth += 1;
                nodes[depth] = node;
              } else if (_isInstance(node, XDustLogicNode)) {
                nodes[depth].add(node);
                nodes[++depth] = node.currentBody;
              } else {
                root = nodes[depth - 1].last();
                root.endBody();
                nodes[depth] = root.startBody(tagName);
              }
            } else if (operator == '/') {
              depthChange = true;
              if (depth > 0) {
                nodes.splice(depth--, 1);
              }
            }
          }
        } else {
          tag = tag[0].split('|');
          filters = tag.splice(1);
          tag = tag[0];
          node = new XDustVariableNode(tag, null, filters);
        }
        if (node && !depthChange) {
          nodes[depth].add(node);
        }
        currentStr = currentStr.slice(lastEnd);
      }
      tail = currentStr;
      if (tail) {
        nodes[depth].add(new XDustTextNode(tail));
      }
      return nodes[0];
    }
  }),
  XDustTemplate = _extend(function(name, rootNode, srcFile) {
    this.name = name;
    this.rootNode = rootNode;
    this.srcFile = srcFile;
  }, {
    render: function(model, chain, context) {
      return this.rootNode.render(chain, context, model);
    }/*,
    toJSON: function() {
      return ['(function(d){var x=d.nodeTypes;d.register(', _stringify(this.name), ',', _stringify(this.rootNode), ')})(window.dust);'].join('');
    }*/
  }),
  /**
   * @class XDust
   * The x-dust templating engine type
   *
   * @constructor
   */
  XDust = _extend(function() {
    /**
     * @field {XDustNodeListParser} parser
     * The parser (used to convert string code to node lists)
     */
    this.parser = new XDustNodeListParser();
    /**
     * @field {Object} templates
     * A hash of template names to node list objects
     */
    this.templates = {};
    /**
     * @field {Object} helpers
     * A hash of helper functions
     */
    this.helpers = {};
    /**
     * @field {Object} filters
     * A hash of variable value filters
     */
    this.filters = {
      h: this.escapeHTML,
      j: this.escapeJS,
      u: this.escapeURI,
      uc: this.escapeURIComponent
    };
    var contextPath = null;
    /**
     * @method getContextPath
     * Gets the base URL for templates
     * @return {String}  The current base URL
     */
    this.getContextPath = function() {
      if (!contextPath) {
        this.setContextPath(window.location.toString());
      }
      return contextPath;
    };
    /**
     * @method setContextPath
     * Sets the base URL for templates
     * @param {String} value  The new base URL
     */
    this.setContextPath = function(value) {
      contextPath = value.split('#')[0].split('?')[0].replace(/\/[^\/]*?\..[^\/]*?$/, '');
    };
  }, {
    /**
     * @method escapeHTML
     * Encodes a string for inclusion in HTML
     *
     * @param {String} str  The string to encode
     * @return {String}  The encoded string
     */
    escapeHTML: function(str) {
      str = str + '';
      if (!/[&<>\"]/.test(str)) {
        return str;
      } else {
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&squot;');
      }
    },
    /**
     * @method escapeJS
     * Encodes a string for inclusion in JavaScript
     *
     * @param {String} str  The string to encode
     * @return {String}  The encoded string
     */
    escapeJS: function(str) {
      str = str + '';
      return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/'/g, "\\'").replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\t/g, '\\t');
    },
    /**
     * @method escapeURI
     * Encodes a string for inclusion in a URL
     *
     * @param {String} str  The string to encode
     * @return {String}  The encoded string
     */
    escapeURI: function(str) {
      return encodeURI(str);
    },
    /**
     * @method escapeURIComponent
     * Encodes a string for inclusion in a URL path
     *
     * @param {String} str  The string to encode
     * @return {String}  The encoded string
     */
    escapeURIComponent: function(str) {
      return encodeURIComponent(str);
    },
    /**
     * @method register
     * Saves an [[XDustNode]] for use as a template
     *
     * @sig
     * @param {String} name  The name of the template
     * @param {XDustNode} rootNode  The root node of the template
     *
     * @sig
     * @param {String} name  The name of the template
     * @param {XDustNode} rootNode  The root node of the template
     * @param {String} srcFile  The file that produced the node
     */
    register: function(name, rootNode, srcFile) {
      this.templates[name] = new XDustTemplate(name, rootNode, srcFile);
    },
    /**
     * @method compile
     * Compiles code into an [[XDustNode]]
     *
     * @sig
     * @param {String} str  The template code
     * @param {String} name  The name of the template
     * @return {XDustNode} The root node of the new template
     *
     * @sig
     * @param {String} str  The template code
     * @param {String} name  The name of the template
     * @param {String} srcFile  The file that produced the code
     * @return {XDustNode} The root node of the new template
     */
    compile: function(str, name, srcFile) {
      var compiled = this.parser.parse(str);
      this.register(name, compiled, srcFile);
      return compiled;
    },
    /*
    compileFn: function(str, name, srcFile) {
      var compiled = this.parser.parse(str);
      return '(function(xd,x){xd.register('
        + JSON.stringify(name)
        + ','
        + compiled.toJSON()
        + (srcFile ? ',' + JSON.stringify(srcFile) : '')
        + ')})(xdust,xdust.nodeTypes);';
    },
    */
    /**
     * @method load
     * Creates a template from a file (or retrieves a cached version
     * of the template if that file has already been loaded)
     *
     * @param {String} srcFile  The URL of the template file
     * @param {String} name  The name of the new template
     * @return {XDustNode}  The root node of the new template
     */
    load: function(srcFile, name) {
      if (name === UNDEFINED) {
        name = srcFile;
      }
      if (_hasProp(this.templates, srcFile)) {
        return this.templates[name].rootNode;
      } else {
        if (srcFile.indexOf('~') == 0) {
          srcFile = srcFile.replace('~', this.getContextPath());
        }
        var xhr = new XMLHttpRequest();
        xhr.open('GET', srcFile, false);
        xhr.send(null);
        if (xhr.status === 200 || xhr.status === 0) {
          return this.compile(xhr.responseText, name, srcFile);
        }
      }
    },
    /**
     * @method render
     * Pairs a model with a template and renders the result
     *
     * @param {String} name  The name of the template to render
     * @param {Object} model  The data object to pass to the template
     * @param {Function} callback  A callback in the form f(err, out)
     *     that accepts an error as its first argument and the string
     *     output of the renderer as the second. If the error is not
     *     null, then a problem occurred during rendering.
     */
    render: function(name, model, callback) {
      var out = null,
          err = null;
      try {
        out = this.templates[name].render(model);
      } catch(e) {
        err = e;
      }
      callback(err, out);
    }
  });

/**
 * @field {XDust} window.xdust
 * @static
 * An instance of the dust templating engine
 */
window.xdust = dust = new XDust();

/*

(function() {
  dust.nodeTypes = {};
  var c = 65,
      types = [
          XDustContext,
          XDustContextResolver,
          XDustRenderChain,
          XDustNode,
          XDustNodeList,
          XDustTextNode,
          XDustVariableNode,
          XDustLogicNode,
          XDustExistsNode,
          XDustNotExistsNode,
          XDustHelperNode,
          XDustIndexNode,
          XDustSepNode,
          XDustEscapedCharacterNode,
          XDustPartialNode,
          XDustBlockNode,
          XDustInlinePartialNode
        ];
  _each(types, function(i, type) {
    var ch = String.fromCharCode(c++);
    type.prototype.alias = 'x.' + ch;
    dust.nodeTypes[ch] = function(a, b, c, d, e, f, g, h) {
      return new type(a, b, c, d, e, f, g, h);
    };
  });
})();

*/

})();
/*!
 * iScroll Lite base on iScroll v4.1.6 ~ Copyright (c) 2011 Matteo Spinelli, http://cubiq.org
 * Released under MIT license, http://cubiq.org/license
 */

(function(){
var m = Math,
	mround = function (r) { return r >> 0; },
	vendor = (/webkit/i).test(navigator.appVersion) ? 'webkit' :
		(/firefox/i).test(navigator.userAgent) ? 'Moz' :
		'opera' in window ? 'O' : '',

    // Browser capabilities
    isAndroid = (/android/gi).test(navigator.appVersion),
    isIDevice = (/iphone|ipad/gi).test(navigator.appVersion),
    isPlaybook = (/playbook/gi).test(navigator.appVersion),
    isTouchPad = (/hp-tablet/gi).test(navigator.appVersion),

    has3d = 'WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix(),
    hasTouch = 'ontouchstart' in window && !isTouchPad,
    hasTransform = vendor + 'Transform' in document.documentElement.style,
    hasTransitionEnd = isIDevice || isPlaybook,

	nextFrame = (function() {
	    return window.requestAnimationFrame
			|| window.webkitRequestAnimationFrame
			|| window.mozRequestAnimationFrame
			|| window.oRequestAnimationFrame
			|| window.msRequestAnimationFrame
			|| function(callback) { return setTimeout(callback, 17); }
	})(),
	cancelFrame = (function () {
	    return window.cancelRequestAnimationFrame
			|| window.webkitCancelAnimationFrame
			|| window.webkitCancelRequestAnimationFrame
			|| window.mozCancelRequestAnimationFrame
			|| window.oCancelRequestAnimationFrame
			|| window.msCancelRequestAnimationFrame
			|| clearTimeout
	})(),

	// Events
	RESIZE_EV = 'onorientationchange' in window ? 'orientationchange' : 'resize',
	START_EV = hasTouch ? 'touchstart' : 'mousedown',
	MOVE_EV = hasTouch ? 'touchmove' : 'mousemove',
	END_EV = hasTouch ? 'touchend' : 'mouseup',
	CANCEL_EV = hasTouch ? 'touchcancel' : 'mouseup',

	// Helpers
	trnOpen = 'translate' + (has3d ? '3d(' : '('),
	trnClose = has3d ? ',0)' : ')',

	// Constructor
	iScroll = function (el, options) {
		var that = this,
			doc = document,
			i;

		that.wrapper = typeof el == 'object' ? el : doc.getElementById(el);
		that.wrapper.style.overflow = 'hidden';
		that.scroller = that.wrapper.children[0];

		// Default options
		that.options = {
			hScroll: true,
			vScroll: true,
			x: 0,
			y: 0,
			bounce: true,
			bounceLock: false,
			momentum: true,
			lockDirection: true,
			useTransform: true,
			useTransition: false,

			// Events
			onRefresh: null,
			onBeforeScrollStart: function (e) { e.preventDefault(); },
			onScrollStart: null,
			onBeforeScrollMove: null,
			onScrollMove: null,
			onBeforeScrollEnd: null,
			onScrollEnd: null,
			onTouchEnd: null,
			onDestroy: null
		};

		// User defined options
		for (i in options) that.options[i] = options[i];

		// Set starting position
		that.x = that.options.x;
		that.y = that.options.y;

		// Normalize options
		that.options.useTransform = hasTransform ? that.options.useTransform : false;
		that.options.hScrollbar = that.options.hScroll && that.options.hScrollbar;
		that.options.vScrollbar = that.options.vScroll && that.options.vScrollbar;
		that.options.useTransition = hasTransitionEnd && that.options.useTransition;

		// Set some default styles
		that.scroller.style[vendor + 'TransitionProperty'] = that.options.useTransform ? '-' + vendor.toLowerCase() + '-transform' : 'top left';
		that.scroller.style[vendor + 'TransitionDuration'] = '0';
		that.scroller.style[vendor + 'TransformOrigin'] = '0 0';
		if (that.options.useTransition) that.scroller.style[vendor + 'TransitionTimingFunction'] = 'cubic-bezier(0.33,0.66,0.66,1)';
		
		if (that.options.useTransform) that.scroller.style[vendor + 'Transform'] = trnOpen + that.x + 'px,' + that.y + 'px' + trnClose;
		else that.scroller.style.cssText += ';position:absolute;top:' + that.y + 'px;left:' + that.x + 'px';

		that.refresh();

		that._bind(RESIZE_EV, window);
		that._bind(START_EV);
		if (!hasTouch) that._bind('mouseout', that.wrapper);
	};

// Prototype
iScroll.prototype = {
	enabled: true,
	x: 0,
	y: 0,
	steps: [],
	scale: 1,
	
	handleEvent: function (e) {
		var that = this;
		switch(e.type) {
			case START_EV:
				if (!hasTouch && e.button !== 0) return;
				that._start(e);
				break;
			case MOVE_EV: that._move(e); break;
			case END_EV:
			case CANCEL_EV: that._end(e); break;
			case RESIZE_EV: that._resize(); break;
			case 'mouseout': that._mouseout(e); break;
			case 'webkitTransitionEnd': that._transitionEnd(e); break;
		}
	},

	_resize: function () {
		this.refresh();
	},
	
	_pos: function (x, y) {
		x = this.hScroll ? x : 0;
		y = this.vScroll ? y : 0;

		if (this.options.useTransform) {
			this.scroller.style[vendor + 'Transform'] = trnOpen + x + 'px,' + y + 'px' + trnClose + ' scale(' + this.scale + ')';
		} else {
			x = mround(x);
			y = mround(y);
			this.scroller.style.left = x + 'px';
			this.scroller.style.top = y + 'px';
		}

		this.x = x;
		this.y = y;
	},

	_start: function (e) {
		var that = this,
			point = hasTouch ? e.touches[0] : e,
			matrix, x, y;

		if (!that.enabled) return;

		if (that.options.onBeforeScrollStart) that.options.onBeforeScrollStart.call(that, e);
		
		if (that.options.useTransition) that._transitionTime(0);

		that.moved = false;
		that.animating = false;
		that.zoomed = false;
		that.distX = 0;
		that.distY = 0;
		that.absDistX = 0;
		that.absDistY = 0;
		that.dirX = 0;
		that.dirY = 0;

		if (that.options.momentum) {
			if (that.options.useTransform) {
				// Very lame general purpose alternative to CSSMatrix
				matrix = getComputedStyle(that.scroller, null)[vendor + 'Transform'].replace(/[^0-9-.,]/g, '').split(',');
				x = matrix[4] * 1;
				y = matrix[5] * 1;
			} else {
				x = getComputedStyle(that.scroller, null).left.replace(/[^0-9-]/g, '') * 1;
				y = getComputedStyle(that.scroller, null).top.replace(/[^0-9-]/g, '') * 1;
			}
			
			if (x != that.x || y != that.y) {
				if (that.options.useTransition) that._unbind('webkitTransitionEnd');
				else cancelFrame(that.aniTime);
				that.steps = [];
				that._pos(x, y);
			}
		}

		that.startX = that.x;
		that.startY = that.y;
		that.pointX = point.pageX;
		that.pointY = point.pageY;

		that.startTime = e.timeStamp || Date.now();

		if (that.options.onScrollStart) that.options.onScrollStart.call(that, e);

		that._bind(MOVE_EV);
		that._bind(END_EV);
		that._bind(CANCEL_EV);
	},
	
	_move: function (e) {
		var that = this,
			point = hasTouch ? e.touches[0] : e,
			deltaX = point.pageX - that.pointX,
			deltaY = point.pageY - that.pointY,
			newX = that.x + deltaX,
			newY = that.y + deltaY,
			timestamp = e.timeStamp || Date.now();

		if (that.options.onBeforeScrollMove) that.options.onBeforeScrollMove.call(that, e);

		that.pointX = point.pageX;
		that.pointY = point.pageY;

		// Slow down if outside of the boundaries
		if (newX > 0 || newX < that.maxScrollX) {
			newX = that.options.bounce ? that.x + (deltaX / 2) : newX >= 0 || that.maxScrollX >= 0 ? 0 : that.maxScrollX;
		}
		if (newY > 0 || newY < that.maxScrollY) { 
			newY = that.options.bounce ? that.y + (deltaY / 2) : newY >= 0 || that.maxScrollY >= 0 ? 0 : that.maxScrollY;
		}

		that.distX += deltaX;
		that.distY += deltaY;
		that.absDistX = m.abs(that.distX);
		that.absDistY = m.abs(that.distY);

		if (that.absDistX < 6 && that.absDistY < 6) {
			return;
		}

		// Lock direction
		if (that.options.lockDirection) {
			if (that.absDistX > that.absDistY + 5) {
				newY = that.y;
				deltaY = 0;
			} else if (that.absDistY > that.absDistX + 5) {
				newX = that.x;
				deltaX = 0;
			}
		}

		that.moved = true;
		that._pos(newX, newY);
		that.dirX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		that.dirY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if (timestamp - that.startTime > 300) {
			that.startTime = timestamp;
			that.startX = that.x;
			that.startY = that.y;
		}
		
		if (that.options.onScrollMove) that.options.onScrollMove.call(that, e);
	},
	
	_end: function (e) {
		if (hasTouch && e.touches.length != 0) return;

		var that = this,
			point = hasTouch ? e.changedTouches[0] : e,
			target, ev,
			momentumX = { dist:0, time:0 },
			momentumY = { dist:0, time:0 },
			duration = (e.timeStamp || Date.now()) - that.startTime,
			newPosX = that.x,
			newPosY = that.y,
			newDuration;

		that._unbind(MOVE_EV);
		that._unbind(END_EV);
		that._unbind(CANCEL_EV);

		if (that.options.onBeforeScrollEnd) that.options.onBeforeScrollEnd.call(that, e);

		if (!that.moved) {
			if (hasTouch) {
				// Find the last touched element
				target = point.target;
				while (target.nodeType != 1) target = target.parentNode;

				if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA') {
					ev = document.createEvent('MouseEvents');
					ev.initMouseEvent('click', true, true, e.view, 1,
						point.screenX, point.screenY, point.clientX, point.clientY,
						e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
						0, null);
					ev._fake = true;
					target.dispatchEvent(ev);
				}
			}

			that._resetPos(200);

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		if (duration < 300 && that.options.momentum) {
			momentumX = newPosX ? that._momentum(newPosX - that.startX, duration, -that.x, that.scrollerW - that.wrapperW + that.x, that.options.bounce ? that.wrapperW : 0) : momentumX;
			momentumY = newPosY ? that._momentum(newPosY - that.startY, duration, -that.y, (that.maxScrollY < 0 ? that.scrollerH - that.wrapperH + that.y : 0), that.options.bounce ? that.wrapperH : 0) : momentumY;

			newPosX = that.x + momentumX.dist;
			newPosY = that.y + momentumY.dist;

 			if ((that.x > 0 && newPosX > 0) || (that.x < that.maxScrollX && newPosX < that.maxScrollX)) momentumX = { dist:0, time:0 };
 			if ((that.y > 0 && newPosY > 0) || (that.y < that.maxScrollY && newPosY < that.maxScrollY)) momentumY = { dist:0, time:0 };
		}

		if (momentumX.dist || momentumY.dist) {
			newDuration = m.max(m.max(momentumX.time, momentumY.time), 10);

			that.scrollTo(mround(newPosX), mround(newPosY), newDuration);

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		that._resetPos(200);
		if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
	},
	
	_resetPos: function (time) {
		var that = this,
			resetX = that.x >= 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x,
			resetY = that.y >= 0 || that.maxScrollY > 0 ? 0 : that.y < that.maxScrollY ? that.maxScrollY : that.y;

		if (resetX == that.x && resetY == that.y) {
			if (that.moved) {
				if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);		// Execute custom code on scroll end
				that.moved = false;
			}

			return;
		}

		that.scrollTo(resetX, resetY, time || 0);
	},
	
	_mouseout: function (e) {
		var t = e.relatedTarget;

		if (!t) {
			this._end(e);
			return;
		}

		while (t = t.parentNode) if (t == this.wrapper) return;
		
		this._end(e);
	},

	_transitionEnd: function (e) {
		var that = this;

		if (e.target != that.scroller) return;

		that._unbind('webkitTransitionEnd');
		
		that._startAni();
	},

	/*!
	 *
	 * Utilities
	 *
	 */
	_startAni: function () {
		var that = this,
			startX = that.x, startY = that.y,
			startTime = Date.now(),
			step, easeOut,
			animate;

		if (that.animating) return;

		if (!that.steps.length) {
			that._resetPos(400);
			return;
		}

		step = that.steps.shift();

		if (step.x == startX && step.y == startY) step.time = 0;

		that.animating = true;
		that.moved = true;

		if (that.options.useTransition) {
			that._transitionTime(step.time);
			that._pos(step.x, step.y);
			that.animating = false;
			if (step.time) that._bind('webkitTransitionEnd');
			else that._resetPos(0);
			return;
		}
		
		animate = function () {
			var now = Date.now(),
				newX, newY;

			if (now >= startTime + step.time) {
				that._pos(step.x, step.y);
				that.animating = false;
				if (that.options.onAnimationEnd) that.options.onAnimationEnd.call(that);			// Execute custom code on animation end
				that._startAni();
				return;
			}

			now = (now - startTime) / step.time - 1;
			easeOut = m.sqrt(1 - now * now);
			newX = (step.x - startX) * easeOut + startX;
			newY = (step.y - startY) * easeOut + startY;
			that._pos(newX, newY);
			if (that.animating) that.aniTime = nextFrame(animate);
		};
		
		animate();
	},

	_transitionTime: function (time) {
		this.scroller.style[vendor + 'TransitionDuration'] = time + 'ms';
	},
	
	_momentum: function (dist, time, maxDistUpper, maxDistLower, size) {
		var deceleration = 0.0006,
			speed = m.abs(dist) / time,
			newDist = (speed * speed) / (2 * deceleration),
			newTime = 0, outsideDist = 0;

		// Proportinally reduce speed if we are outside of the boundaries 
		if (dist > 0 && newDist > maxDistUpper) {
			outsideDist = size / (6 / (newDist / speed * deceleration));
			maxDistUpper = maxDistUpper + outsideDist;
			speed = speed * maxDistUpper / newDist;
			newDist = maxDistUpper;
		} else if (dist < 0 && newDist > maxDistLower) {
			outsideDist = size / (6 / (newDist / speed * deceleration));
			maxDistLower = maxDistLower + outsideDist;
			speed = speed * maxDistLower / newDist;
			newDist = maxDistLower;
		}

		newDist = newDist * (dist < 0 ? -1 : 1);
		newTime = speed / deceleration;

		return { dist: newDist, time: mround(newTime) };
	},

	_offset: function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;
			
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		} 

		return { left: left, top: top };
	},

	_bind: function (type, el, bubble) {
		(el || this.scroller).addEventListener(type, this, !!bubble);
	},

	_unbind: function (type, el, bubble) {
		(el || this.scroller).removeEventListener(type, this, !!bubble);
	},


	/*!
	 *
	 * Public methods
	 *
	 */
	destroy: function () {
		var that = this;

		that.scroller.style[vendor + 'Transform'] = '';

		// Remove the event listeners
		that._unbind(RESIZE_EV, window);
		that._unbind(START_EV);
		that._unbind(MOVE_EV);
		that._unbind(END_EV);
		that._unbind(CANCEL_EV);
		that._unbind('mouseout', that.wrapper);
		if (that.options.useTransition) that._unbind('webkitTransitionEnd');
		
		if (that.options.onDestroy) that.options.onDestroy.call(that);
	},

	refresh: function () {
		var that = this,
			offset;

		that.wrapperW = that.wrapper.clientWidth;
		that.wrapperH = that.wrapper.clientHeight;

		that.scrollerW = that.scroller.offsetWidth;
		that.scrollerH = that.scroller.offsetHeight;
		that.maxScrollX = that.wrapperW - that.scrollerW;
		that.maxScrollY = that.wrapperH - that.scrollerH;
		that.dirX = 0;
		that.dirY = 0;

		that.hScroll = that.options.hScroll && that.maxScrollX < 0;
		that.vScroll = that.options.vScroll && (!that.options.bounceLock && !that.hScroll || that.scrollerH > that.wrapperH);

		offset = that._offset(that.wrapper);
		that.wrapperOffsetLeft = -offset.left;
		that.wrapperOffsetTop = -offset.top;


		that.scroller.style[vendor + 'TransitionDuration'] = '0';

		that._resetPos(200);
	},

	scrollTo: function (x, y, time, relative) {
		var that = this,
			step = x,
			i, l;

		that.stop();

		if (!step.length) step = [{ x: x, y: y, time: time, relative: relative }];
		
		for (i=0, l=step.length; i<l; i++) {
			if (step[i].relative) { step[i].x = that.x - step[i].x; step[i].y = that.y - step[i].y; }
			that.steps.push({ x: step[i].x, y: step[i].y, time: step[i].time || 0 });
		}

		that._startAni();
	},

	scrollToElement: function (el, time) {
		var that = this, pos;
		el = el.nodeType ? el : that.scroller.querySelector(el);
		if (!el) return;

		pos = that._offset(el);
		pos.left += that.wrapperOffsetLeft;
		pos.top += that.wrapperOffsetTop;

		pos.left = pos.left > 0 ? 0 : pos.left < that.maxScrollX ? that.maxScrollX : pos.left;
		pos.top = pos.top > 0 ? 0 : pos.top < that.maxScrollY ? that.maxScrollY : pos.top;
		time = time === undefined ? m.max(m.abs(pos.left)*2, m.abs(pos.top)*2) : time;

		that.scrollTo(pos.left, pos.top, time);
	},

	disable: function () {
		this.stop();
		this._resetPos(0);
		this.enabled = false;

		// If disabled after touchstart we make sure that there are no left over events
		this._unbind(MOVE_EV);
		this._unbind(END_EV);
		this._unbind(CANCEL_EV);
	},
	
	enable: function () {
		this.enabled = true;
	},
	
	stop: function () {
		cancelFrame(this.aniTime);
		this.steps = [];
		this.moved = false;
		this.animating = false;
	}
};

if (typeof exports !== 'undefined') exports.iScroll = iScroll;
else window.iScroll = iScroll;

})();


/*
 * The MIT License
 * 
 * Copyright (c) 2009 Olle Törnström studiomediatech.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * CREDIT: Initially implemented by Diogo Kollross and made publicly available
 *         on the website http://www.geocities.com/diogok_br/lz77.
 */
 
/*!
 * This class provides simple LZ77 compression and decompression. 
 *
 * @author Olle Törnström olle[at]studiomediatech[dot]com
 * @created 2009-02-18 
 */
var LZ77 = function (settings) {

	settings = settings || {};	
	
	// PRIVATE
	
	var referencePrefix = "`";
	var referenceIntBase = settings.referenceIntBase || 96;
	var referenceIntFloorCode = " ".charCodeAt(0);
	var referenceIntCeilCode = referenceIntFloorCode + referenceIntBase - 1;
	var maxStringDistance = Math.pow(referenceIntBase, 2) - 1;
	var minStringLength = settings.minStringLength || 5;
	var maxStringLength = Math.pow(referenceIntBase, 1) - 1 + minStringLength;
	var defaultWindowLength = settings.defaultWindowLength || 144;
	var maxWindowLength = maxStringDistance + minStringLength;
	
	var encodeReferenceInt = function (value, width) {
		if ((value >= 0) && (value < (Math.pow(referenceIntBase, width) - 1))) {
			var encoded = "";
			while (value > 0) {
				encoded = (String.fromCharCode((value % referenceIntBase) + referenceIntFloorCode)) + encoded;
				value = Math.floor(value / referenceIntBase);
			}
			var missingLength = width - encoded.length;
			for (var i = 0; i < missingLength; i++) {
				encoded = String.fromCharCode(referenceIntFloorCode) + encoded;
			}
			return encoded;
		} else {
			throw "Reference int out of range: " + value + " (width = " + width + ")";
		}
	};
	
	var encodeReferenceLength = function (length) {
		return encodeReferenceInt(length - minStringLength, 1);
	};
	
	var decodeReferenceInt = function (data, width) {
		var value = 0;
		for (var i = 0; i < width; i++) {
			value *= referenceIntBase;
			var charCode = data.charCodeAt(i);
			if ((charCode >= referenceIntFloorCode) && (charCode <= referenceIntCeilCode)) {
				value += charCode - referenceIntFloorCode;
			} else {
				throw "Invalid char code in reference int: " + charCode;
			}
		}
		return value;
	};
	
	var decodeReferenceLength = function (data) {
		return decodeReferenceInt(data, 1) + minStringLength;
	};
		
	// PUBLIC
	
	/*!
	 * Compress data using the LZ77 algorithm.
	 *
	 * @param data
	 * @param windowLength
	 */
	this.compress = function (data, windowLength) {
		windowLength = windowLength || defaultWindowLength;
		if (windowLength > maxWindowLength) {
			throw "Window length too large";
		}
		var compressed = "";
		var pos = 0;
		var lastPos = data.length - minStringLength;
		while (pos < lastPos) {
			var searchStart = Math.max(pos - windowLength, 0);
			var matchLength = minStringLength;
			var foundMatch = false;
			var bestMatch = {distance:maxStringDistance, length:0};
			var newCompressed = null;
			while ((searchStart + matchLength) < pos) {
				var isValidMatch = ((data.substr(searchStart, matchLength) == data.substr(pos, matchLength)) && (matchLength < maxStringLength));
				if (isValidMatch) {
					matchLength++;
					foundMatch = true;
				} else {
					var realMatchLength = matchLength - 1;
					if (foundMatch && (realMatchLength > bestMatch.length)) {
						bestMatch.distance = pos - searchStart - realMatchLength;
						bestMatch.length = realMatchLength;
					}
					matchLength = minStringLength;
					searchStart++;
					foundMatch = false;
				}
			}
			if (bestMatch.length) {
				newCompressed = referencePrefix + encodeReferenceInt(bestMatch.distance, 2) + encodeReferenceLength(bestMatch.length);
				pos += bestMatch.length;
			} else {
				if (data.charAt(pos) != referencePrefix) {
					newCompressed = data.charAt(pos);
				} else {
					newCompressed = referencePrefix + referencePrefix;
				}
				pos++;
			}
			compressed += newCompressed;
		}
		return compressed + data.slice(pos).replace(/`/g, "``");
	};
	
	/*!
	 * Decompresses LZ77 compressed data.
	 *
	 * @param data
	 */
	this.decompress = function (data) {
		var decompressed = "";
		var pos = 0;
		while (pos < data.length) {
			var currentChar = data.charAt(pos);
			if (currentChar != referencePrefix) {
				decompressed += currentChar;
				pos++;
			} else {
				var nextChar = data.charAt(pos + 1);
				if (nextChar != referencePrefix) {
					var distance = decodeReferenceInt(data.substr(pos + 1, 2), 2);
					var length = decodeReferenceLength(data.charAt(pos + 3));
					decompressed += decompressed.substr(decompressed.length - distance - length, length);
					pos += minStringLength - 1;
				} else {
					decompressed += referencePrefix;
					pos += 2;
				}
			}
		}
		return decompressed;
	};
};
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**
 * @class Lavaca
 *  Core Lavaca library object
 */
(function(ns, $) {

var _uuid = 0;

/**
 * @field {Function} $
 * @static
 * Abstraction library conforming to jQuery interface
 */
ns.$ = $.noConflict ? $.noConflict() : $;

/**
 * @method resolve
 * @static
 * Looks up or creates an object, given its global path (ie, 'Lavaca.resolve' resolves to this function,
 * 'no.obj.exists' resolves to null)
 *
 * @sig
 * @param {String} name  The fully-qualified name of the object to look up
 * @return {Object}  The resolved object
 *
 * @sig
 * @param {String} name  The fully-qualified name of the object to look up
 * @param {Boolean} createIfNotExists  When true, any part of the name that doesn't already exist will be created
 * as an empty object
 * @return {Object}  The resolved object
 */
ns.resolve = function(name, createIfNotExists) {
  if (!name) {
    return null;
  }
  name = name.split('.');
  var last = window,
      o = window,
      i = -1,
      segment;
  while (segment = name[++i]) {
    o = o[segment];
    if (!o) {
      if (createIfNotExists) {
        o = last[segment] = {};
      } else {
        return null;
      }
    }
    last = o;
  }
  return o;
};

/**
 * @method extend
 * @static
 * Establishes inheritance between types. After a type is extended, it receives its own static
 * convenience method, extend(TSub, overrides).
 *
 * @sig
 * @param {Function} TSub  The child type which will inherit from superType
 * @param {Object} overrides  A hash of key-value pairs that will be added to the subType
 * @return {Function}  The subtype
 *
 * @sig
 * @param {Function} TSuper  The base type to extend
 * @param {Function} TSub  The child type which will inherit from superType
 * @param {Object} overrides  A hash of key-value pairs that will be added to the subType
 * @return {Function}  The subtype
 */
ns.extend = function(TSuper, TSub, overrides) {
  if (typeof TSuper == 'object') {
    overrides = TSuper;
    TSuper = Object;
    TSub = function() {
      // Empty
    };
  } else if (typeof TSub == 'object') {
    overrides = TSub;
    TSub = TSuper;
    TSuper = Object;
  }
  function ctor() {
    // Empty
  }
  ctor.prototype = TSuper.prototype;
  TSub.prototype = new ctor;
  TSub.prototype.constructor = TSub;
  if (overrides) {
    for (var name in overrides) {
      TSub.prototype[name] = overrides[name];
    }
  }
  TSub.extend = function(T, overrides) {
    if (typeof T == 'object') {
      overrides = T;
      T = function() {
        TSub.apply(this, arguments);
      };
    }
    ns.extend(TSub, T, overrides);
    return T;
  };
  return TSub;
};

/**
 * @method log
 * @static
 * Logs to the console (or alerts if no console exists)
 *
 * @params {Object} arg  The content to be logged
 */
ns.log = function() {
  if (window.console) {
    console.log.apply(console, arguments);
  } else {
    alert([].join.call(arguments, ' '));
  }
};

/**
 * @method uuid
 * @static
 * Produces a unique identifier
 *
 * @return {Number}  A number that is unique to this page
 */
ns.uuid = function() {
  return _uuid++;
};

/**
 * @method delay
 * @static
 * Delays the execution of a function
 *
 * @param {Function} callback  A callback to execute on delay
 *
 * @sig
 * @param {Function} callback  A callback to execute on delay
 * @param {Object} thisp  The object to use as the "this" keyword
 * @return {Number}  The timeout ID
 *
 * @sig
 * @param {Function} callback  A callback to execute on delay
 * @param {Object} thisp  The object to use as the "this" keyword
 * @param {Number} ms  The number of milliseconds to delay execution
 * @return {Number}  The timeout ID
 */
ns.delay = function(callback, thisp, ms) {
  return setTimeout(function() {
    callback.call(thisp);
  }, ms || 0);
};

/**
 * @method clone
 * @static
 * Makes a copy of an object
 *
 * @sig
 * @param {Object} obj  The object to copy
 * @return {Object}  The copy
 *
 * @sig
 * @param {Object} obj  The object to copy
 * @param {Boolean} deepCopy  When true, also clone each member of the object
 * @return {Object}  The copy
 */
ns.clone = function(obj, deepCopy) {
  if (!obj) {
    return obj;
  } else if (obj instanceof Array) {
    return obj.slice(0);
  } else if (obj instanceof Date) {
    return new Date(obj.getTime());
  } else if (typeof obj == 'object') {
    return ns.merge(deepCopy, {}, obj);
  } else {
    return obj.valueOf();
  }
};

/**
 * @method merge
 * @static
 * Applies the properties of one or more objects to another. To create a new object
 * with the properties of all others, call <code>Lavaca.merge(true, {}, obj1, obj2, objN)</code>.
 *
 * @sig
 * @param {Object} target  The object to which apply the properties
 * @params {Object} obj  The objects whose properties will be written to target
 * @return Object}  The target
 *
 * @sig
 * @param {Boolean} deepCopy  When true, copy the overload values
 * @param {Object} target  The object to which apply the properties
 * @params {Object} obj  The objects whose properties will be written to target
 * @return {Object}  The target
 */
ns.merge = function(deepCopy, target/*, obj1, obj2, objN*/) {
  var i = -1,
      objs = [].slice.call(arguments, 2),
      obj,
      n;
  if (typeof deepCopy == 'object') {
    objs.unshift(target);
    target = deepCopy;
    deepCopy = false;
  }
  while (obj = objs[++i]) {
    for (n in obj) {
      if (obj.hasOwnProperty(n)) {
        target[n] = deepCopy ? ns.clone(obj[n]) : obj[n];
      }
    }
  }
  return target;
};

/**
 * @method $.fn.dataAttrs
 * @static
 * Collects the values of all data attributes into an object
 *
 * @return {Object}  An object containing all data attribute values, with the "data-" prefix dropped
 */
$.fn.dataAttrs = function() {
  var data = {},
      attrs = this[0].attributes,
      i = -1,
      attr;
  while (attr = attrs[++i]) {
    if (attr.name.indexOf('data-') == 0) {
      data[attr.name.slice(5)] = attr.value;
    }
  }
  return data;
};

/**
 * @method $.proxy
 * @static
 * A jQuery like proxy method for passing in a context
 *
 * @param {Function} fn  The function to proxy
 * @param {Object} context  The execution context for the function
 * @return {Object}  Returns a new function that executes in that context
 */
if (!$.proxy) {
  $.proxy = function(fn, context) {
    return function() {
      fn.apply(context, arguments);
    };
  };
}

if (!$.fn.detach) {
  $.fn.detach = $.fn.remove;
}

})(window.Lavaca = window.Lavaca || {}, window.jQuery || window.Zepto || window.jMiny);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns) {

/**
 * @class Lavaca.util.ArrayUtils
 * Utility class for working with arrays
 */

/**
 * @method indexOf
 * @static
 * Gets the first index of an item in an array
 *
 * @param {Array} a  The array
 * @param {Object} o  The object to look for
 * @return {Number}  The first index of the object, or -1 if not found
 */
ns.indexOf = function(a, o) {
  if (!a) {
    return -1;
  } else if (a.indexOf) {
    return a.indexOf(o);
  } else {
    for (var i = 0, j = a.length; i < j; i++) {
      if (a[i] === o) {
        return i;
      }
    }
    return -1;
  }
};

/**
 * @method contains
 * @static
 * Determines whether an array contains an object
 *
 * @param {Array} a  The array
 * @param {Object} o  The object to look for
 * @return {Boolean}  True when the array contains the object, false otherwise
 */
ns.contains = function(a, o) {
  return ns.indexOf(a, o) > -1;
};

/**
 * @method remove
 * @static
 * Removes the first instance of an item from an array, if it exists
 *
 * @param {Array} a  The array
 * @param {Object} o  The object to remove
 * @return {Number}  The former index of the item (or -1 if the item was not
 *   in the array)
 */
ns.remove = function(a, o) {
  var index = ns.indexOf(a, o);
  if (index > -1) {
    a.splice(index, 1);
  }
  return index;
};

/**
 * @method pushIfNotExists
 * @static
 * @sig  Adds an item to the end of an array, if it was not already in the array
 *
 * @param {Array} a  The array
 * @param {Object} o  The object to add to the array
 * @return {Number}  The index of the item in the array
 */
ns.pushIfNotExists = function(a, o) {
  var index = ns.indexOf(a, o);
  if (index == -1) {
    a[index = a.length] = o;
  }
  return index;
};

})(Lavaca.resolve('Lavaca.util.ArrayUtils', true));
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns) {

/**
 * @class Lavaca.util.DateUtils
 * Utility class for working with dates
 */

function _int(input) {
  return parseInt(input, 10);
}

function _indexOfCode(input, array) {
  input = input.toLowerCase();
  var i = -1,
      code,
      name;
  while (code = array[++i]) {
    if (input == code.toLowerCase() || input == _translate(code).toLowerCase()) {
      return i - 1;
    }
  }
  throw 'Invalid code "' + code + '"';
}

function _pad(n, digits, c) {
  var sign = n < 0 ? '-' : '';
  c = c || '0';
  n = Math.abs(n).toString();
  while (digits - n.length > 0) {
    n = c + n;
  }
  return sign + n;
}

function _translate(s) {
  if (Lavaca.util.Translation) {
    result = Lavaca.util.Translation.get(s);
  }
  return result ? result : s;
}

/**
 * @field {Array} timeOfDayDesignatorAbbr
 * @static
 * @default ["A", "P"]
 * The time of day abbreviation. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.
 */
ns.timeOfDayDesignatorAbbr = [
  'A',
  'P'
];

/**
 * @field {Array} timeOfDayDesignator
 * @static
 * @default ["AM", "PM"]
 * The time of day. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.
 */
ns.timeOfDayDesignator = [
  'AM',
  'PM'
];

/**
 * @field {Array} daysOfWeekAbbr
 * @static
 * @default ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
 * The abbreviated days of the week. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.
 */
ns.daysOfWeekAbbr = [
  'Sun',
  'Mon',
  'Tue',
  'Wed',
  'Thu',
  'Fri',
  'Sat'
];

/**
 * @field {Array} daysOfWeek
 * @static
 * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
 * The days of the week. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.
 */
ns.daysOfWeek = [
  'Sunday',
  'Monday',
  'Tuesday',
  'Wednesday',
  'Thursday',
  'Friday',
  'Saturday'
];

/**
 * @field {Array} monthsAbbr
 * @static
 * @default ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
 * The abbreviated months. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.
 */
ns.monthsAbbr = [
  'Jan',
  'Feb',
  'Mar',
  'Apr',
  'May',
  'Jun',
  'Jul',
  'Aug',
  'Sep',
  'Oct',
  'Nov',
  'Dec'
];

/**
 * @field {Array} months
 * @static
 * @default ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
 * The months. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.
 */
ns.months = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'November',
  'December'
];

/**
 * @field {Object} fn
 * @static
 * Object containing the functions used by each date format code. Default format codes are:
 *
 * <dl>
 * <dt>d</dt> <dd>Day of month (1 - 31)</dd>
 * <dt>dd</dt> <dd>Padded day of month (01 - 31)</dd>
 * <dt>ddd</dt> <dd>Abbreviated day of week (Sun - Sat)</dd>
 * <dt>ddd</dt> <dd>Full day of week (Sunday - Saturday)</dd>
 * <dt>f</dt> <dd>Tenth of a second</dd>
 * <dt>ff</dt> <dd>Hundreth of a second</dd>
 * <dt>fff</dt> <dd>Milliseconds</dd>
 * <dt>h</dt> <dd>Twelve-hour clock hour (1 - 12)</dd>
 * <dt>hh</dt> <dd>Padded twelve-hour clock hour (01 - 12)</dd>
 * <dt>H</dt> <dd>Twenty-four hour clock hour (0 - 23)</dd>
 * <dt>HH</dt> <dd>Padded twenty-four hour clock hour (00 - 23)</dd>
 * <dt>m</dt> <dd>Minute (0 - 59)</dd>
 * <dt>mm</dt> <dd>Padded minute (00 - 59)</dd>
 * <dt>M</dt> <dd>Month (1 - 12)</dd>
 * <dt>MM</dt> <dd>Padded month (01 - 12)</dd>
 * <dt>MMM</dt> <dd>Abbreviated month (Jan - Dec)</dd>
 * <dt>MMMM</dt> <dd>Full month (January - December)</dd>
 * <dt>s</dt> <dd>Second (0 - 59)</dd>
 * <dt>ss</dt> <dd>Padded second (00 - 59)</dd>
 * <dt>t</dt> <dd>Abbreviated AM/PM designator (A or P)</dd>
 * <dt>tt</dt> <dd>Full AM/PM designator (AM or PM)</dd>
 * <dt>y</dt> <dd>Short year (0 - 99)</dd>
 * <dt>yy</dt> <dd>Padded short year (00 - 99)</dd>
 * <dt>yyy</dt> <dd>Full year padded to at least 3 digits (000+)</dd>
 * <dt>yyyy</dt> <dd>Full year padded to at least 4 digits (0000+)</dd>
 * <dt>z</dt> <dd>Hours offset from UTC (-12, 0, 12)</dd>
 * <dt>zz</dt> <dd>Padded hours offset from UTC (-12, 00, 12)</dd>
 * <dt>zzz</dt> <dd>Padded hours and minute offset from UTC (-12:00, 00:00, 12:00)</dd>
 * </dl>
 *
 * To add a custom format code, assign this field an object containing an <code>i</code> function (responsible for parsing)
 * and an <code>o</code> function (responsible for stringifying). The <code>i</code> function
 * should assign to one of the following fields of its second argument: date, month, year,
 * hour, minute, second, ms, or offset. Example: <code>Lavaca.util.DateUtils.fn.QQQ = {i: function(input, dateObj, mappedObj) { dateObj.date = parseInt(input, 10); }, o: function(date, utc) { return (utc ? date.getUTCDate() : date.getDate()).toString(); }};</code>
 */
ns.fn = {
  d: {
    exp: '\\d{1,2}',
    i: function(input, dateObj, mappedObj) {
      dateObj.date = _int(input);
    },
    o: function(date, utc) {
      return (utc ? date.getUTCDate() : date.getDate()).toString();
    }
  },
  dd: {
    exp: '\\d{2}',
    i: function(input, dateObj, mappedObj) {
      dateObj.date = _int(input);
    },
    o: function(date, utc) {
      return _pad(ns.fn.d.o(date, utc), 2);
    }
  },
  ddd: {
    exp: '[a-z]{3}',
    i: function(input, dateObj, mappedObj) {
      // Do nothing
    },
    o: function(date, utc) {
      return _translate(ns.daysOfWeekAbbr[utc ? date.getUTCDay() : date.getDay()]);
    }
  },
  dddd: {
    exp: '[a-z]+',
    i: function(input, dateObj, mappedObj) {
      // Do nothing
    },
    o: function(date, utc) {
      return _translate(ns.daysOfWeek[utc ? date.getUTCDay() : date.getDay()]);
    }
  },
  f: {
    exp: '\\d',
    i: function(input, dateObj, mappedObj) {
      dateObj.ms = _int(input) * 100;
    },
    o: function(date, utc, divisor) {
      divisor = divisor || 100;
      return _pad(Math.floor((utc ? date.getUTCMilliseconds() : date.getMilliseconds()) / divisor), 3 - divisor.toString().length);
    }
  },
  ff: {
    exp: '\\d{2}',
    i: function(input, dateObj, mappedObj) {
      dateObj.ms = _int(input) * 10;
    },
    o: function(date, utc) {
      return _pad(ns.fn.f.o(date, utc, 10), 2);
    }
  },
  fff: {
    exp: '\\d{3}',
    i: function(input, dateObj, mappedObj) {
      dateObj.ms = _int(input, 10);
    },
    o: function(date, utc) {
      return _pad(ns.fn.f.o(date, utc, 1), 3);
    }
  },
  h: {
    exp: '1?\\d',
    i: function(input, dateObj, mappedObj) {
      var h = _int(input) - 1,
          tod = (mappedObj.t || mappedObj.tt || 'A').indexOf('A') == 0 ? 0 : 12;
      dateObj.hour = h + tod;
    },
    o: function(date, utc) {
      return ((utc ? date.getUTCHours() : date.getHours()) % 12 + 1).toString();
    }
  },
  hh: {
    exp: '[0-1]\\d',
    i: function(input, dateObj, mappedObj) {
      ns.fn.h.i(input, dateObj, mappedObj);
    },
    o: function(date, utc) {
      return _pad(ns.fn.h.o(date, utc), 2);
    }
  },
  H: {
    exp: '[0-2]?\\d',
    i: function(input, dateObj, mappedObj) {
      dateObj.hour = _int(input);
    },
    o: function(date, utc) {
      return (utc ? date.getUTCHours() : date.getHours()).toString();
    }
  },
  HH: {
    exp: '[0-2]\\d',
    i: function(input, dateObj, mappedObj) {
      dateObj.hour = _int(input);
    },
    o: function (date, utc) {
      return _pad(ns.fn.H.o(date, utc), 2);
    }
  },
  m: {
    exp: '[1-5]?\\d',
    i: function(input, dateObj, mappedObj) {
      dateObj.minute = _int(input);
    },
    o: function(date, utc) {
      return (utc ? date.getUTCMinutes() : date.getMinutes()).toString();
    }
  },
  mm: {
    exp: '[0-5]\\d',
    i: function(input, dateObj, mappedObj) {
      ns.fn.m.i(input, dateObj, mappedObj);
    },
    o: function(date, utc) {
      return _pad(ns.fn.m.o(date, utc), 2);
    }
  },
  M: {
    exp: '1?\\d',
    i: function(input, dateObj, mappedObj) {
      dateObj.month = _int(input) - 1;
    },
    o: function(date, utc) {
      return ((utc ? date.getUTCMonth() : date.getMonth()) + 1).toString();
    }
  },
  MM: {
    exp: '[0-1]\\d',
    i: function(input, dateObj, mappedObj) {
      ns.fn.M.i(input, dateObj, mappedObj);
    },
    o: function(date, utc) {
      return _pad(ns.fn.M.o(date, utc), 2);
    }
  },
  MMM: {
    exp: '[a-z]{3}',
    i: function(input, dateObj, mappedObj) {
      dateObj.month = _indexOfCode(input, ns.monthsAbbr);
    },
    o: function(date, utc) {
      return _translate(ns.monthsAbbr[utc ? date.getUTCMonth() : date.getMonth()]);
    }
  },
  MMMM: {
    exp: '[a-z]+',
    i: function(input, dateObj, mappedObj) {
      dateObj.month = _indexOfCode(input, ns.months);
    },
    o: function(date, utc) {
      return _translate(ns.months[utc ? date.getUTCMonth() : date.getMonth()]);
    }
  },
  s: {
    exp: '[1-5]?\\d',
    i: function(input, dateObj, mappedObj) {
      dateObj.second = _int(input);
    },
    o: function(date, utc) {
      return (utc ? date.getUTCSeconds() : date.getSeconds()).toString();
    }
  },
  ss: {
    exp: '[0-5]\\d',
    i: function(input, dateObj, mappedObj) {
      ns.fn.s.i(input, dateObj, mappedObj);
    },
    o: function(date, utc) {
      return _pad(ns.fn.s.o(date, utc), 2);
    }
  },
  t: {
    exp: '[a-z]',
    i: function(input, dateObj, mappedObj) {
      // Do nothing
    },
    o: function(date, utc) {
      return _translate(ns.timeOfDayDesignatorAbbr[Math.floor((utc ? date.getUTCHours() : date.getHours()) / 12)]);
    }
  },
  tt: {
    exp: '[a-z]+',
    i: function(input, dateObj, mappedObj) {
      // Do nothing
    },
    o: function(date, utc) {
      return _translate(ns.timeOfDayDesignator[Math.floor((utc ? date.getUTCHours() : date.getHours()) / 12)]);
    }
  },
  y: {
    exp: '\\d?\\d',
    i: function(input, dateObj, mappedObj) {
      dateObj.year = (new Date).getFullYear() % 100 + _int(input);
    },
    o: function(date, utc) {
      return ((utc ? date.getUTCFullYear() : date.getFullYear()) % 100).toString();
    }
  },
  yy: {
    exp: '\\d{2}',
    i: function(input, dateObj, mappedObj) {
      ns.fn.y.i(input, dateObj, mappedObj);
    },
    o: function(date, utc) {
      return _pad(ns.fn.y.o(date, utc), 2);
    }
  },
  yyy: {
    exp: '\\d*\\d{3}',
    i: function(input, dateObj, mappedObj) {
      dateObj.year = _int(input);
    },
    o: function(date, utc) {
      return _pad(utc ? date.getUTCFullYear() : date.getFullYear(), 3);
    }
  },
  yyyy: {
    exp: '\\d*\\d{4}',
    i: function(input, dateObj, mappedObj) {
      ns.fn.yyy.i(input, dateObj, mappedObj);
    },
    o: function(date, utc) {
      return _pad(utc ? date.getUTCFullYear() : date.getFullYear(), 4);
    }
  },
  z: {
    exp: '[-+]?1?\\d',
    i: function(input, dateObj, mappedObj) {
      dateObj.offset = _int(input) * 60;
    },
    o: function(date, padding) {
      var off = date.getTimezoneOffset(),
          offH = Math.floor(Math.abs(off / 60));
      return (off < 0 ? '-' : '+') + _pad(offH, padding);
    }
  },
  zz: {
    exp: '[-+]?[0-1]\\d',
    i: function(input, dateObj, mappedObj) {
      ns.fn.z.i(input, dateObj, mappedObj);
    },
    o: function(date) {
      return ns.fn.z.o(date, 2);
    }
  },
  zzz: {
    exp: '[-+]?[0-1]\\d:\\d{2}',
    i: function(input, dateObj, mappedObj) {
      var parts = input.split(':');
      dateObj.offset = _int(parts[0]) * 60 + _int(parts[1]);
    },
    o: function(date) {
      var z = date.getTimezoneOffset(),
          sign = z < 0 ? '-' : '+',
          m = z % 60,
          h = (z - m) / 60;
      return sign + _pad(h, 2) + ':' + _pad(Math.abs(m), 2);
    }
  }
};

function _parseFormat(f) {
  var actors = [],
      buffer = '',
      i = -1,
      j = f.length,
      consume = false,
      bufferChar,
      c;
  while (c = f.charAt(++i)) {
    bufferChar = buffer.charAt(0);
    if (bufferChar == c || bufferChar == '"' || bufferChar == '\'') {
      buffer += c;
      if ((bufferChar == '"' && c == '"') || (bufferChar == '\'' && c == '\'')) {
        actors.push(buffer);
        buffer = '';
      }
    } else {
      if (buffer) {
        actors.push(buffer);
      }
      buffer = c;
    }
  }
  if (buffer) {
    actors.push(buffer);
  }
  return actors;
}

function _actorsToRegex(actors) {
  var s = ['^'],
      i = -1,
      actor,
      handler;
  while (actor = actors[++i]) {
    handler = ns.fn[actor];
    if (handler) {
      s.push('(', handler.exp, ')');
    } else {
      s.push('(', actor.replace(/(^")|(^')|('$)|("$)/g, '').replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'), ')');
    }
  }
  s.push('$');
  return new RegExp(s.join(''));
}

/**
 * @method parse
 * @static
 * Converts a string to a date
 *
 * @param {String} s  The date string
 * @param {String} f  The format of the date string
 * @return {Date}  The parsed date
 */
ns.parse = function(s, f) {
  var actors = _parseFormat(f),
      exp = _actorsToRegex(actors),
      dateObj = {year: 0, month: 0, date: 1, hour: 0, minute: 0, second: 0, ms: 0, offset: 0},
      mappedObj = {},
      i = -1,
      actor,
      match,
      handler;
  if (exp.test(s)) {
    match = exp.exec(s);
    while (actor = actors[++i]) {
      mappedObj[actor] = match[i + 1];
    }
  }
  for (actor in mappedObj) {
    handler = ns.fn[actor];
    if (handler) {
      handler.i(mappedObj[actor], dateObj, mappedObj);
    }
  }
  return new Date(
      ns.monthsAbbr[dateObj.month]
    + ' '
    + _pad(dateObj.date, 2)
    + ' '
    + _pad(dateObj.year, 4)
    + ' '
    + _pad(dateObj.hour, 2)
    + ':'
    + _pad(dateObj.minute, 2)
    + ':'
    + _pad(dateObj.second, 2)
    + (dateObj.ms > 0 ? '.' + _pad(dateObj.ms, 3) : '')
    + (dateObj.offset >= 0 ? '+' : '-')
    + _pad(Math.floor(Math.abs(dateObj.offset / 60)), 2)
    + _pad(Math.abs(dateObj.offset % 60), 2));
};

/**
 * @method stringify
 * @static
 * Converts a date to a string
 *
 * @sig
 * @param {Date} d  The date
 * @param {String} f  The string format of the date
 * @return {String}  The stringified date
 *
 * @sig
 * @param {Date} d  The date
 * @param {String} f  The string format of the date
 * @param {Boolean} utc  When true, use the UTC date to generate the string
 * @return {String}  The stringified date
 */
ns.stringify = function(d, f, utc) {
  var actors = _parseFormat(f),
      i = -1,
      s = [],
      actor,
      handler;
  while (actor = actors[++i]) {
    handler = ns.fn[actor];
    if (handler) {
      s.push(handler.o(d, utc));
    } else {
      s.push(actor.replace(/(^")|(^')|('$)|("$)/g, ''));
    }
  }
  return s.join('');
};

})(Lavaca.resolve('Lavaca.util.DateUtils', true));
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns) {

function _disposeOf(obj) {
  var n,
      o,
      i;
  for (n in obj) {
    if (obj.hasOwnProperty(n)) {
      o = obj[n];
      if (o) {
        if (typeof o.dispose == 'function') {
          o.dispose();
        } else if (o instanceof Array) {
          for (i = o.length - 1; i > -1; i--) {
            _disposeOf(o[i]);
          }
        }
      }
    }
    delete obj[n];
  }
}

/** 
 * @class Lavaca.util.Disposable
 * Abstract type for types that need to ready themselves for GC
 *
 * @constructor
 */
ns.Disposable = Lavaca.extend({
  /**
   * @method dispose
   * Readies the object to be garbage collected
   */
  dispose: function() {
    _disposeOf(this);
  }
});

})(Lavaca.resolve('Lavaca.util', true));
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, Disposable) {

var UNDEFINED;

/** 
 * @class Lavaca.util.Cache
 * @super Lavaca.util.Disposable
 * Object for storing data
 */
ns.Cache = Disposable.extend({
  /**
   * @method get
   * Retrieves an item from the cache
   *
   * @sig
   * @param {String} id  The key under which the item is stored
   * @return {Object}  The stored item (or null if no item is stored)
   *
   * @sig
   * @param {String} id  The key under which the item is stored
   * @param {Object} def  A default value that will be added, if there is no item stored
   * @return {Object}  The stored item (or null if no item is stored and no default)
   */
  get: function(id, def) {
    var result = this['@' + id];
    if (result === UNDEFINED && def !== UNDEFINED) {
      result = this['@' + id] = def;
    }
    return result === UNDEFINED ? null : result;
  },
  /**
   * @method set
   * Assigns an item to a key in the cache
   *
   * @param {String} id  The key under which the item will be stored
   * @param {Object} value  The object to store in the cache
   */
  set: function(id, value) {
    this['@' + id] = value;
  },
  /**
   * @method add
   * Adds an item to the cache
   *
   * @param {Object} value  The object to store in the cache
   * @return {String}  The auto-generated ID under which the value was stored
   */
  add: function(value) {
    var id = Lavaca.uuid();
    this.set(id, value);
    return id;
  },
  /**
   * @method remove
   * Removes an item from the cache (if it exists)
   *
   * @param {String} id  The key under which the item is stored
   */
  remove: function(id) {
    delete this['@' + id];
  },
  /**
   * @method each
   * Executes a callback for each cached item
   *
   * @sig
   * @param {Function} callback  A function to execute for each item, callback(key, item)
   *
   * @sig
   * @param {Function} callback  A function to execute for each item, callback(key, item)
   * @param {Object} thisp  The context of the callback
   */
  each: function(cb, thisp) {
    var prop;
    for (prop in this) {
      if (this.hasOwnProperty(prop) && prop.indexOf('@') == 0) {
        cb.call(thisp || this, prop.slice(1), this[prop]);
      }
    }
  },
  /**
   * @method toObject
   * Serializes the cache to a hash
   *
   * @return {Object}  The resulting key-value hash
   */
  toObject: function() {
    var result = {};
    this.each(function(prop, value) {
      result[prop] = value;
    });
    return result;
  },
  /**
   * @method toJSON
   * Serializes the cache to JSON
   *
   * @return {String}  The JSON string
   */
  toJSON: function() {
    return JSON.stringify(this.toObject());
  }
});

})(Lavaca.util, Lavaca.util.Disposable);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $, Disposable) {

function _absolute(url) {
  if (url && url.indexOf('http') != 0) {
    if (url.charAt(0) == '/') {
      url = location.protocol + '//'
        + location.hostname
        + (location.port ? ':' + location.port : '')
        + (url.indexOf('/') == 0 ? url : '/' + url);
    } else {
      url = location.toString().split('#')[0].split('?')[0].replace(/\w+\.\w+$/, '') + url;
    }
  }
  return url;
}

/**
 * @class Lavaca.util.Map
 * @super Lavaca.util.Disposable
 * Abstract type for lookup tables
 *
 * @constructor
 * @param {String} name  The name of the map
 * @param {String} src  The URL of the map's data (or null if code is supplied)
 * @param {String} code  The raw string data for the map (or null if src is supplied)
 */
ns.Map = Disposable.extend(function(name, src, code) {
  Disposable.call(this);
  /**
   * @field {Boolean} hasLoaded
   * @default false
   * Whether or not the map has loaded
   */
  this.hasLoaded = false;
  /**
   * @field {String} name
   * @default null
   * The name of the map
   */
  this.name = name;
  /**
   * @field {String} src
   * @default null
   * The source URL for the map
   */
  this.src = _absolute(src);
  /**
   * @field {String} code
   * @default null
   * The raw string data for the map
   */
  this.code = code;
  /**
   * @field {Lavaca.util.Cache} cache
   * @default new Lavaca.util.Cache()
   * The cache in which this map stores data
   */
  this.cache = new Lavaca.util.Cache();
}, {
  /**
   * @method is
   * Determines whether or not this is the desired lookup
   *
   * @param {String} name  The name of the lookup
   * @return {Boolean}  True if this is the lookup
   */
  is: function(name) {
    return this.name == name;
  },
  /**
   * @method get
   * Gets the value stored under a code
   *
   * @param {String} code  The code
   * @return {Object}  The value (or null)
   */
  get: function(code) {
    if (!this.hasLoaded) {
      if (this.code) {
        this.add(this.code);
      } else if (this.src) {
        this.load(this.src);
      }
      this.hasLoaded = true;
    }
    return this.cache.get(code);
  },
  /**
   * @method add
   * Adds parameters to this map
   *
   * @param {Object} data  The parameters to add
   */
  add: function(data) {
    for (var n in data) {
      this.cache.set(n, data[n]);
    }
  },
  /**
   * @method process
   * Processes server data to include in this lookup
   *
   * @param {String} text  The server data string
   */
  process: function(text) {
    this.add(typeof text == 'string' ? JSON.parse(text) : text);
  },
  /**
   * @method load
   * Adds JSON data to this map (synchronous)
   *
   * @param {String} url  The URL of the data
   */
  load: function(url) {
    var self = this;
    Lavaca.net.Connectivity.ajax({
      async: false,
      url: url,
      success: function(resp) {
        self.process(resp);
      }
    });
  }
});
/**
 * @method setDefault
 * @static
 * Sets the application's default config
 *
 * @param {Lavaca.util.Cache} cache  The map cache
 * @param {String} name  The name of the config
 */
ns.Map.setDefault = function(cache, name) {
  var map = name;
  if (typeof map == 'string') {
    map = cache.get(name);
  }
  cache.set('default', map);
};
/**
 * @method get
 * @static
 * Finds the most appropriate value for a code
 *
 * @param {Lavaca.util.Cache} cache  The maps cache
 * @param {String} name  The name of the map
 * @param {String} code  The name of the parameter
 * @param {String} defaultName  The name of the default map
 * @return {Object}  The value of the parameter
 */
ns.Map.get = function(cache, name, code, defaultName) {
  if (!code) {
    code = name;
    name = defaultName;
  }
  if (name) {
    var map = cache.get(name);
    if (map) {
      return map.get(code);
    }
  }
  return null;
};
/**
 * @method init
 * @static
 * Scans the document for all maps and prepares them
 *
 * @param {Lavaca.util.Cache} cache  The map cache
 * @param {String} mimeType  The MIME type of the scripts
 * @param {Function} construct  A function that returns a new map, in
 *   the form construct(name, src, code)
 * @param {jQuery} scope  The element to which to limit the scan
 */
ns.Map.init = function(cache, mimeType, construct, scope) {
  $(scope || document.documentElement)
    .find('script[type="' + mimeType + '"]')
    .each(function() {
      var item = $(this),
          src = item.attr('data-src'),
          name = item.attr('data-name'),
          isDefault = item.attr('data-default') !== null,
          code = item.text(),
          map;
      map = construct(name, src, code);
      cache.set(map.name, map);
      if (isDefault) {
        ns.Map.setDefault(cache, name);
      }
    });
};
/**
 * @method dispose
 * @static
 * Disposes of all maps
 *
 * @param {Lavaca.util.Cache} cache  The map cache
 */
ns.Map.dispose = function(cache) {
  cache.dispose();
};

})(Lavaca.util, Lavaca.$, Lavaca.util.Disposable);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $, Map) {

var _cache = new ns.Cache();

function _construct(name, src, code) {
  if (code) {
    code = JSON.parse(code);
  }
  return new ns.Config(name, src, code);
}

/**
 * @class Lavaca.util.Config
 * @super Lavaca.util.Map
 * Configuration management type
 */
ns.Config = Map.extend({
  // Empty (no overrides)
});
/**
 * @method setDefault
 * @static
 * Sets the application's default config
 *
 * @param {String} name  The name of the default config
 */
ns.Config.setDefault = function(name) {
  Map.setDefault(_cache, name);
};
/**
 * @method get
 * @static
 * Retrieves a value from the configuration
 *
 * @sig
 * @param {String} code  The name of the parameter
 * @return {Object}  The value of the parameter
 *
 * @sig
 * @param {String} name  The name of the config
 * @param {String} code  The name of the parameter
 * @return {Object}  The value of the parameter
 */
ns.Config.get = function(name, code) {
  return Map.get(_cache, name, code, 'default');
};
/**
 * @method init
 * @static
 * Scans the document for all translations and prepares them
 *
 * @sig
 *
 * @sig
 * @param {jQuery} scope  The element to which to limit the scan
 */
ns.Config.init = function(scope) {
  Map.init(_cache, 'text/x-config', _construct, scope);
};
/**
 * @method dispose
 * @static
 * Disposes of all translations
 */
ns.Config.dispose = function() {
  Map.dispose(_cache);
};

})(Lavaca.util, Lavaca.$, Lavaca.util.Map);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns) {

/** 
 * @class Lavaca.util.Promise
 * Utility type for asynchronous prograLavacaing
 *
 * @constructor
 *
 * @param {Object} thisp  What the "this" keyword resolves to in callbacks
 */
ns.Promise = Lavaca.extend(function(thisp) {
  /**
   * @field {Object} thisp
   * @default null
   * What the "this" keyword resolves to in callbacks
   */
  this.thisp = thisp;
  /**
   * @field {Array} resolvedQueue
   * @default []
   * Pending handlers for the success event
   */
  this.resolvedQueue = [];
  /**
   * @field {Array} rejectedQueue
   * @default []
   * Pending handlers for the error event
   */
  this.rejectedQueue = [];
}, {
  /**
   * @field {Boolean} succeeded
   * @default false
   * Flag indicating that the promise completed successfully
   */
  succeeded: false,
  /**
   * @field {Boolean} failed
   * @default false
   * Flag indicating that the promise failed to complete
   */
  failed: false,
  /**
   * @method success
   * Queues a callback to be executed when the promise succeeds
   *
   * @param {Function} callback  The callback to execute
   * @return {Lavaca.util.Promise}  This promise (for chaining)
   */
  success: function(callback) {
    if (callback) {
      if (this.succeeded) {
        callback.apply(this.thisp, this.resolveArgs);
      } else {
        this.resolvedQueue.push(callback);
      }
    }
    return this;
  },
  /**
   * @method error
   * Queues a callback to be executed when the promise fails
   *
   * @param {Function} callback  The callback to execute
   * @return {Lavaca.util.Promise}  This promise (for chaining)
   */
  error: function(callback) {
    if (callback) {
      if (this.failed) {
        callback.apply(this.thisp, this.rejectArgs);
      } else {
        this.rejectedQueue.push(callback);
      }
    }
    return this;
  },
  /**
   * @method always
   * Queues a callback to be executed when the promise is either rejected or resolved
   *
   * @param {Function} callback  The callback to execute
   * @return {Lavaca.util.Promise}  This promise (for chaining)
   */
  always: function(callback) {
    return this.then(callback, callback);
  },
  /**
   * @method then
   * Queues up callbacks after the promise is completed
   *
   * @param {Function} resolved  A callback to execute when the operation succeeds
   * @param {Function} rejected  A callback to execute when the operation fails
   * @return {Lavaca.util.Promise}  This promise (for chaining)
   */
  then: function(resolved, rejected) {
    return this
      .success(resolved)
      .error(rejected);
  },
  /**
   * @method resolve
   * Resolves the promise successfully
   *
   * @params {Object} value  Values to pass to the queued success callbacks
   * @return {Lavaca.util.Promise}  This promise (for chaining)
   */
  resolve: function(/* value1, value2, valueN */) {
    if (!this.succeeded && !this.failed) {
      this.succeeded = true;
      this.resolveArgs = [].slice.call(arguments, 0);
      var i = -1,
          callback;
      while (callback = this.resolvedQueue[++i]) {
        callback.apply(this.thisp, this.resolveArgs);
      }
    }
    return this;
  },
  /**
   * @method reject
   * Resolves the promise as a failure
   *
   * @params {String} err  Failure messages
   * @return {Lavaca.util.Promise}  This promise (for chaining)
   */
  reject: function(/* err1, err2, errN */) {
    if (!this.succeeded && !this.failed) {
      this.failed = true;
      this.rejectArgs = [].slice.call(arguments, 0);
      var i = -1,
          callback;
      while (callback = this.rejectedQueue[++i]) {
        callback.apply(this.thisp, this.rejectArgs);
      }
    }
    return this;
  },
  /**
   * @method when
   * Queues this promise to be resolved only after several other promises
   *   have been successfully resolved, or immediately rejected when one
   *   of those promises is rejected
   *
   * @params {Lavaca.util.Promise}  promise  One or more other promises
   * @return {Lavaca.util.Promise}  This promise (for chaining)
   */
  when: function(/* promise1, promise2, promiseN */) {
    var self = this,
        values = [],
        i = -1,
        pendingPromiseCount = arguments.length,
        promise;
    while (promise = arguments[++i]) {
      (function(index) {
        promise
          .success(function(v) {
            values[index] = v;
            if (--pendingPromiseCount < 1) {
              self.resolve.apply(self, values);
            }
          })
          .error(function() {
            self.reject.apply(self, arguments);
          });
      })(i);
    }
    promise = null;
    return this;
  },
  /**
   * @method resolver
   * Produces a callback that resolves the promise with any number of arguments
   *
   * @return {Function}  The callback
   */
  resolver: function() {
    var self = this;
    return function() {
      self.resolve.apply(self, arguments);
    };
  },
  /**
   * @method rejector
   * Produces a callback that rejects the promise with any number of arguments
   *
   * @return {Function}  The callback
   */
  rejector: function() {
    var self = this;
    return function() {
      self.reject.apply(self, arguments);
    };
  }
});
/**
 * @method when
 * @static
 * Creates a promise to be resolved only after several other promises
 *   have been successfully resolved, or immediately rejected when one
 *   of those promises is rejected
 *
 * @sig
 * @params {Lavaca.util.Promise}  promise  One or more other promises
 * @return {Lavaca.util.Promise}  The new promise
 *
 * @sig
 * @param {Object} thisp  The execution context of the promise
 * @params {Lavaca.util.Promise}  promise  One or more other promises
 * @return {Lavaca.util.Promise}  The new promise
 */
ns.Promise.when = function(thisp/*, promise1, promise2, promiseN */) {
  var thispIsPromise = thisp instanceof ns.Promise,
      promise = new ns.Promise(thispIsPromise ? window : thisp),
      args = [].slice.call(arguments, thispIsPromise ? 0 : 1);
  return promise.when.apply(promise, args);
};

})(Lavaca.resolve('Lavaca.util', true));
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, LZ77) {

var _htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&apos;'
};

function _noop(s) {
  return s;
}

/**
 * @class Lavaca.util.StringUtils
 * Static utility type for working with strings
 */

/**
 * @method format
 * @static
 * Substitutes arguments into a string
 *
 * @sig
 * @param {String} s  The format string. Substitutions should be in the form {0} to sub in
 *   the first arg, {1} for the second, and so on
 * @params {Object} arg  Arguments to be substituted in to the string
 * @return {String}  The format string with the arguments substituted into it
 *
 * @sig
 * @param {String} s  The format string. Substitutions should be in the form {0} to sub in
 *   the first arg, {1} for the second, and so on
 * @param {Array} args  Arguments to be substituted in to the string
 * @return {String}  The format string with the arguments substituted into it
 *
 * @sig
 * @param {String} s  The format string. Substitutions should be in the form {0} to sub in
 *   the first arg, {1} for the second, and so on
 * @param {Array} args  Arguments to be substituted in to the string
 * @param {Function} fn  A function to call on each argument, the result of which is substituted into the string
 * @return {String}  The format string with the arguments substituted into it
 */
ns.format = function(s /*[, arg0, arg1, argN]*/) {
  var args,
      fn = _noop,
      i,
      j;
  if (arguments[1] instanceof Array) {
    args = arguments[1];
    fn = arguments[2] || _noop;
  } else {
    args = [].slice.call(arguments, 1);
  }
  for (i = 0, j = args.length; i < j; i++) {
    s = s.split('{' + i + '}').join(fn(args[i] + ''));
  }
  return s;
};

/**
 * @method escapeHTML
 * @static
 * Escapes a string for inclusion in HTML
 *
 * @param {String} s  The string
 * @return {String}  The escaped string
 */
ns.escapeHTML = function(s) {
  s = '' + s;
  for (var n in _htmlEscapes) {
    s = s.split(n).join(_htmlEscapes[n]);
  }
  return s;
};

/**
 * @method compress
 * @static
 *
 * @sig
 * LZMA-encodes a string
 * @param {String} s  The string to encode
 * @return {String}  The LZMA-encoded string
 *
 * @sig
 * Converts an object to an LZMA-encoded JSON string
 * @param {Object} o  The object to encode
 * @return {String}  The LZMA-encoded JSON string
 */
ns.compress = function(s) {
  if (typeof s != 'string') {
    s = JSON.stringify(s);
  }
  return new LZ77().compress(s);
};

/**
 * @method decompress
 * @static
 * Decodes an LZMA-encoded string
 *
 * @param {String} s  The encoded string
 * @return {String}  The decoded string
 */
ns.decompress = function(s) {
  return new LZ77().decompress(s);
};

})(Lavaca.resolve('Lavaca.util.StringUtils', true), window.LZ77);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, Map) {

var _cache = new ns.Cache();

function _construct(name, src, code) {
  if (code) {
    code = JSON.parse(code);
  }
  var map = new ns.Translation(name, src, code);
  if (!_cache.get(map.language)) {
    _cache.set(map.language, map);
  }
  return map;
}

/**
 * @class Lavaca.util.Translation
 * @super Lavaca.util.Map
 * Translation dictionary
 *
 * @constructor
 * @param {String} name  The name of the map
 * @param {String} src  The URL of the map's data (or null if code is supplied)
 * @param {String} code  The raw string data for the map (or null if src is supplied)
 */
ns.Translation = Map.extend(function(name, src, code) {
  Map.apply(this, arguments);
  var locale = name = name.toLowerCase().split('_');
  /**
   * @field {String} language
   * @default null
   * The ISO 639-2 code for the translation's language
   */
  this.language = locale[0];
  /**
   * @field {String} country
   * @default ''
   * The ISO 3166-1 code for the translation's country
   */
  this.country = locale[1] || '';
  /**
   * @field {String} locale
   * @default null
   * The locale of this translation (either lang or lang_COUNTRY)
   */
  this.locale = this.country
    ? this.language + '_' + this.country
    : this.language;
}, {
  /**
   * @method is
   * Determines whether or not this translation works for a locale
   *
   * @sig
   * @param {String} language  The locale's language
   * @return {Boolean}  True if this translation applies
   *
   * @sig
   * @param {String} language  The locale's language
   * @param {String} country   (Optional) The locale's country
   * @return {Boolean}  True if this translation applies
   */
  is: function(language, country) {
    return language == this.language
      && (!country || !this.country || country == this.country);
  }
});
/**
 * @method setDefault
 * @static
 * Sets the application's default locale
 *
 * @param {String} locale  A locale string (ie, "en", "en_US", or "es_MX")
 */
ns.Translation.setDefault = function(locale) {
  _cache.remove('default');
  Map.setDefault(_cache, ns.Translation.forLocale(locale));
};
/**
 * @method forLocale
 * @static
 * Finds the most appropriate translation for a given locale
 *
 * @param {String} locale  The locale
 * @return {Lavaca.util.Translation}  The translation
 */
ns.Translation.forLocale = function(locale) {
  locale = (locale || 'default').toLowerCase();
  return _cache.get(locale)
    || _cache.get(locale.split('_')[0])
    || _cache.get('default');
};
/**
 * @method get
 * @static
 * Finds the most appropriate translation of a message for the default locale
 *
 * @sig
 * @param {String} code  The code under which the message is stored
 * @return {Lavaca.util.Translation}  The translation
 *
 * @sig
 * @param {String} locale  The locale
 * @param {String} code  The code under which the message is stored
 * @return {Lavaca.util.Translation}  The translation
 */
ns.Translation.get = function(locale, code) {
  if (!code) {
    code = locale;
    locale = 'default';
  }
  var translation = ns.Translation.forLocale(locale),
      result = null;
  if (translation) {
    result = translation.get(code);
  }
  if (result === null) {
    translation = ns.Translation.forLocale(locale.split('_')[0]);
    if (translation) {
      result = translation.get(code);
    }
  }
  if (result === null) {
    translation = ns.Translation.forLocale('default');
    if (translation) {
      result = translation.get(code);
    }
  }
  return result;
};
/**
 * @method init
 * @static
 * Scans the document for all translations and prepares them
 *
 * @sig
 * @param {String} locale  The default locale
 *
 * @sig
 * @param {String} locale  The default locale
 * @param {jQuery} scope  The element to which to limit the scan
 */
ns.Translation.init = function(locale, scope) {
  Map.init(_cache, 'text/x-translation', _construct, scope);
  ns.Translation.setDefault(locale);
};
/**
 * @method dispose
 * @static
 * Disposes of all translations
 */
ns.Translation.dispose = function() {
  Map.dispose(_cache);
};

})(Lavaca.util, Lavaca.util.Map);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, Disposable) {

/** 
 * @class Lavaca.events.EventDispatcher
 * @super Lavaca.util.Disposable
 * Basic event dispatcher type
 *
 * @constructor
 */
ns.EventDispatcher = Disposable.extend({
  /**
   * @field {Boolean} suppressEvents
   * @default false
   * When true, do not fire events
   */
  suppressEvents: false,
  /**
   * @method on
   *
   * Bind an event handler to this object
   *
   * @sig
   * @param {String} type  The name of the event
   * @param {Function} callback  The function to execute when the event occurs
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   *
   * @sig
   * @param {String} type  The name of the event
   * @param {Function} callback  The function to execute when the event occurs
   * @param {Object} thisp  The context of the handler
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   */
  on: function(type, callback, thisp) {
    var calls = this.callbacks || (this.callbacks = {}),
        list = calls[type] || (calls[type] = []);
    list[list.length] = {fn: callback, thisp: thisp};
    return this;
  },
  /**
   * @method off
   *
   * @sig
   * Unbinds all event handler from this object
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   *
   * @sig
   * Unbinds all event handlers for an event
   * @param {String} type  The name of the event
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   *
   * @sig
   * Unbinds a specific event handler
   * @param {String} type  The name of the event
   * @param {Function} callback  The function handling the event
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   *
   * @sig
   * Unbinds a specific event handler
   * @param {String} type  The name of the event
   * @param {Function} callback  The function handling the event
   * @param {Object} thisp  The context of the handler
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   */
  off: function(type, callback, thisp) {
    var calls = this.callbacks,
        list,
        handler,
        i = -1,
        newList,
        isCallback,
        isThisp;
    if (!type) {
      delete this.callbacks;
    } else if (calls) {
      if (!callback) {
        delete calls[type];
      } else {
        list = calls[type];
        if (list) {
          newList = calls[type] = [];
          while (handler = list[++i]) {
            isCallback = handler.fn == callback || handler.fn.fn == callback;
            isThisp = thisp && (handler.thisp == thisp || handler.fn.thisp == thisp);
            if (!isCallback || (isCallback && (!thisp || !isThisp))) {
              newList[newList.length] = handler;
            }
          }
        }
      }
    }
    return this;
  },
  /**
   * @method trigger
   * Dispatches an event
   *
   * @sig
   * @param {String} type  The type of event to dispatch
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   *
   * @sig
   * @param {String} type  The type of event to dispatch
   * @param {Object} params  Additional data points to add to the event
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   */
  trigger: function(type, params) {
    if (!this.suppressEvents && this.callbacks) {
      var list = this.callbacks[type],
          event = this.createEvent(type, params),
          i = -1,
          handler;
      if (list) {
        while (handler = list[++i]) {
          handler.fn.apply(handler.thisp || this, [event]);
        }
      }
    }
    return this;
  },
  /**
   * @method createEvent
   * Creates an event object
   *
   * @sig
   * @param {String} type  The type of event to create
   * @return {Object}  The event object
   *
   * @sig
   * @param {String} type  The type of event to create
   * @param {Object} params  Additional data points to add to the event
   * @return {Object}  The event object
   */
  createEvent: function(type, params) {
    return Lavaca.merge({}, params || {}, {
      type: type,
      target: params && params.target ? params.target : this,
      currentTarget: this
    });
  }
});

})(Lavaca.resolve('Lavaca.events', true), Lavaca.util.Disposable);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns) {

var _coordNames = ['screenX', 'screenY', 'clientX', 'clientY', 'pageX', 'pageY'];

/**
 * @class Lavaca.events.EventPoint
 * Coordinates describing a point on the screen
 *
 * @constructor
 *
 * @constructor
 * @param {Event} e The event from which to load coordinate data
 */
ns.EventPoint = Lavaca.extend(function(e) {
  this.init(e);
}, {
  /**
   * @field {Number} screenX
   * @default null
   * The X-coordinate of the point, in screen space
   */
  screenX: null,
  /**
   * @field {Number} screenY
   * @default null
   * The Y-coordinate of the point, in screen space
   */
  screenY: null,
  /**
   * @field {Number} clientX
   * @default null
   * The X-coordinate of the point, in window space
   */
  clientX: null,
  /**
   * @field {Number} clientY
   * @default null
   * The Y-coordinate of the point, in window space
   */
  clientY: null,
  /**
   * @field {Number} pageX
   * @default null
   * The X-coordinate of the point, in document space
   */
  pageX: null,
  /**
   * @field {Number} pageY
   * @default null
   * The Y-coordinate of the point, in document space
   */
  pageY: null,
  /**
   * @method init
   * Loads coordinate data from an event
   *
   * @param {Event} e  The event
   */
  init: function(e) {
    var i = -1,
        name;
    while (name = _coordNames[++i]) {
      this[name] = e ? e[name] : null;
    }
  }
});

})(Lavaca.resolve('Lavaca.events', true));
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns) {

/**
 * @class Lavaca.events.EventVector
 * An object indicating a direction
 *
 * @constructor
 * @param {Number} length  The length of the vector
 * @param {String} axis  The axis of the vector
 * @param {String} compass  The cardinal direction of the vector
 */
ns.EventVector = Lavaca.extend(function(length, axis, compass) {
  this.length = length;
  this.axis = axis;
  this.compass = compass;
}, {
  /**
   * @field {Number} length
   * @default 0
   * The number of pixels covered by the vector
   */
  length: 0,
  /**
   * @field {String} axis
   * @default 'vertical'
   * The axis to which the vector most closely aligns (either "horizontal" or "vertical")
   */
  axis: 'vertical',
  /**
   * @field {String} compass
   * @default 'north'
   * The cardinal direction toward which the vector primarily points ("north", "south", "east", or "west")
   */
  compass: 'north'
});

})(Lavaca.resolve('Lavaca.events', true));
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $, EventVector, EventPoint) {

// Note: TouchEvent is an implied type and doesn't actually exist

/**
 * @class Lavaca.events.TouchEvent
 * @super Event
 * Event data from when the user interacted with the screen by starting, moving, or ending a touch
 *
 * @field {Number} startTime
 * @default 0
 * The time (in ms) when the touch start event fired
 *
 * @field {Number} elapsed
 * @default 0
 * The number of milliseconds since the touch start event fired
 *
 * @field {Lavaca.events.EventPoint} startPoint
 * @default null
 * The point where the touch start event fired
 *
 * @field {Lavaca.events.EventPoint} lastPoint
 * @default null
 * The previous point in this chain of touch events
 *
 * @field {Lavaca.events.EventPoint} currentPoint
 * @default null
 * The most recent point in this chain of touch events
 *
 * @field {Boolean} hasMoved
 * @default false
 * Whether or not the pointer has moved
 *
 * @field {Lavaca.events.EventPoint} startDelta
 * @default null
 * The difference between the currentPoint and startPoint
 *
 * @field {Number} startDistance
 * @default 0
 * The number of pixels traversed from the startPoint to the currentPoint
 *
 * @field {Lavaca.events.EventVector} startVector
 * @default null
 * Information about the direction of the gesture, from the startPoint to the currentPoint
 *
 * @field {Lavaca.events.EventPoint} lastDelta
 * @default null
 * The difference between the currentPoint and lastPoint
 *
 * @field {Number} lastDistance
 * @default 0
 * The number of pixels traversed from the startPoint to the currentPoint
 *
 * @field {Lavaca.events.EventVector} lastVector
 * @default null
 * Information about the direction of the gesture, from the lastPoint to the currentPoint
 */

var _startName = 'mousedown',
    _moveName = 'mousemove',
    _endName = 'mouseup',
    _coordNames = ['screenX', 'screenY', 'clientX', 'clientY', 'pageX', 'pageY'],
    _supportsTouchEvents = false,
    _supportsGestureEvents = false,
    _moveHandlers = {},
    _endHandlers = {};

(function() {
  var el = document.createElement('div');
  el.setAttribute('ontouchstart', 'return;');
  el.setAttribute('ongesturestart', 'return;');
  if (_supportsTouchEvents = typeof el.ontouchstart == 'function') {
    _startName = 'touchstart';
    _moveName = 'touchmove';
    _endName = 'touchend';
  }
  _supportsGestureEvents = typeof el.ongesturestart == 'function';
})();

function _addMoveHandler(id, handler) {
  _moveHandlers[id] = function(e) { handler(e); };
}

function _removeMoveHandler(id) {
  delete _moveHandlers[id];
}

function _addEndHandler(id, handler) {
  _endHandlers[id] = function(e) { handler(e); };
}

function _removeEndHandler(id) {
  delete _endHandlers[id];
}

(function() {
  $(document.body)
    .on(_moveName, function(e) {
      for (var id in _moveHandlers) {
        _moveHandlers[id](e);
      }
    })
    .on(_endName, function(e) {
      for (var id in _endHandlers) {
        _endHandlers[id](e);
      }
    });
})();
 
function _getPoint(touchEvent, index) {
  if (touchEvent.touches) {
    touchEvent = touchEvent.touches[index || 0];
  }
  return new EventPoint(touchEvent);
}

function _clonePoint(point) {
  return _getPoint(point);
}

function _delta(a, b) {
  var result = {},
      i = -1,
      name;
  while (name = _coordNames[++i]) {
    result[name] = a[name] - b[name];
  }
  return new EventPoint(result);
}

function _distance(a, b) {
  return Math.sqrt((a.screenX - b.screenX) * (a.screenX - b.screenX) + (a.screenY - b.screenY) * (a.screenY - b.screenY));
}

function _equal(a, b) {
  return a.screenX === b.screenX && a.screenY === b.screenY;
}

function _withinThreshold(a, b) {
  return _distance(a, b) <= ns.moveThreshold;
}

function _vector(a, b) {
  var deltaX = a.screenX - b.screenX,
      deltaY = a.screenY - b.screenY;
  if (deltaX * deltaX > deltaY * deltaY) {
    return new EventVector(Math.abs(deltaX), 'horizontal', deltaX > 0 ? 'east' : 'west');
  } else {
    return new EventVector(Math.abs(deltaY), 'vertical', deltaY > 0 ? 'south' : 'north');
  }
}

function _getEventTouch(identifier, e) {
  var i = -1,
      touch;
  if (null !== identifier && e.changedTouches) {
    while (touch = e.changedTouches[++i]) {
      if (touch.identifier === identifier) {
        return touch;
      }
    }
    return null;
  } else {
    return e;
  }
}

function _preventDefault(e) {
  e.preventDefault();
}

function _Event(o) {
  if (o) {
    for (var name in o) {
      if (typeof o[name] != 'function') {
        this[name] = o[name];
      }
    }
    this.originalEvent = o;
  }
}
_Event.prototype = {
  preventDefault: function() {
    this.defaultPrevented = true;
    if (this.originalEvent) {
      this.originalEvent.preventDefault();
    }
  },
  stopPropagation: function() {
    if (this.originalEvent) {
      this.originalEvent.stopPropagation();
    }
  }
};

/**
 * @class Lavaca.events.Touch
 * Static utility class for Touch events
 */

/**
 * @field {Number} moveThreshold
 * @default 4
 * How many pixels the pointer may move and still count as a tap
 */
ns.moveThreshold = 4;

/**
 * @field {Number} tapholdDuration
 * @default 800
 * How many milliseconds the user must wait between touch start and touch end to count as a hold
 */
ns.tapholdDuration = 800;

/**
 * @method isSupported
 * @static
 * Whether or not touch events are supported by the browser
 *
 * @return {Boolean} True if touch events are supported
 */
ns.isSupported = function() {
  return _supportsTouchEvents;
};

/**
 * @method bind
 * @static
 * Binds touch start, move, and end handlers to an element, falling back to mouse events when touch isn't supported.
 * Event handlers are passed [[Lavaca.events.TouchEvent]] objects.
 *
 * @sig
 * @param {jQuery} el  The element to which to bind events
 * @param {Object} opts  Parameters to initialize touch event handling
 * @opt {Function} start  Callback to execute when the user begins touching the element
 * @opt {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @opt {Function} end  Callback to execute when the user stops touching the screen after touching the element
 *
 * @sig
 * @param {jQuery} el  The element to which to bind events
 * @param {Object} opts  Parameters to initialize touch event handling
 * @opt {Function} start  Callback to execute when the user begins touching the element
 * @opt {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @opt {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @param {Object} thisp  Context for the callback
 *
 * @sig
 * @param {jQuery} el  The element to which to bind events
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Object} opts  Parameters to initialize touch event handling
 * @opt {Function} start  Callback to execute when the user begins touching the element
 * @opt {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @opt {Function} end  Callback to execute when the user stops touching the screen after touching the element
 *
 * @sig
 * @param {jQuery} el  The element to which to bind events
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Object} opts  Parameters to initialize touch event handling
 * @opt {Function} start  Callback to execute when the user begins touching the element
 * @opt {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @opt {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @param {Object} thisp  Context for the callback
 *
 * @sig
 * @param {jQuery} el  The element to which to bind events
 * @param {Function} start  Callback to execute when the user begins touching the element
 * @param {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @param {Function} end  Callback to execute when the user stops touching the screen after touching the element
 *
 * @sig
 * @param {jQuery} el  The element to which to bind events
 * @param {Function} start  Callback to execute when the user begins touching the element
 * @param {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @param {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @param {Object} thisp  Context for the callback
 *
 * @sig
 * @param {jQuery} el  The element to which to bind events
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} start  Callback to execute when the user begins touching the element
 * @param {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @param {Function} end  Callback to execute when the user stops touching the screen after touching the element
 *
 * @sig
 * @param {jQuery} el  The element to which to bind events
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} start  Callback to execute when the user begins touching the element
 * @param {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @param {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @param {Object} thisp  Context for the callback
 */
ns.bind = function(el, delegate, start, move, end, thisp) {
  if (typeof delegate == 'function') {
    delegate = {
      start: delegate,
      move: start,
      end: move
    };
    thisp = end;
  }
  if (delegate && typeof delegate == 'object') {
    thisp = start;
    start = delegate;
    delegate = null;
  }
  if (start && typeof start == 'object') {
    move = start.move;
    end = start.end;
    start = start.start;
    thisp = move;
  }
  var startTime,
      startPoint,
      lastPoint,
      currentPoint,
      hasMoved = false,
      defaultPrevented = false,
      identifier,
      onMove,
      onEnd,
      eventMap = {},
      k;
  function _appendTouchData(o) {
    var result = new _Event(o);
    if (o) {
      result.startTime = startTime;
      result.elapsed = (new Date).getTime() - startTime;
      result.startPoint = startPoint;
      result.lastPoint = lastPoint;
      result.currentPoint = currentPoint;
      result.hasMoved = hasMoved || (hasMoved = !_withinThreshold(startPoint, currentPoint));
      if (startPoint && currentPoint) {
        result.startDelta = _delta(currentPoint, startPoint);
        result.startDistance = _distance(currentPoint, startPoint);
        result.startVector = _vector(currentPoint, startPoint);
      }
      if (currentPoint && lastPoint) {
        result.lastDelta = _delta(currentPoint, lastPoint);
        result.lastDistance = _distance(currentPoint, lastPoint);
        result.lastVector = _vector(currentPoint, lastPoint);
      }
    }
    return result;
  }
  // Prevent click so that all platforms have uniform touch event handling:
  // - Android doesn't prevent click if touchstart is prevented
  // - Desktop browsers don't prevent click if mousedown is prevented
  eventMap.click = function(e) {
    if (defaultPrevented) {
      e.preventDefault();
    }
  };
  eventMap[_startName] = function(e) {
    e = e.originalEvent || e;
    var el = this,
        uuid = Lavaca.uuid();
    startTime = (new Date).getTime();
    startPoint = lastPoint = currentPoint = _getPoint(e);
    hasMoved = false;
    if (e.changedTouches && e.changedTouches.length) {
      identifier = e.changedTouches[0].identifier;
    } else {
      idenfifier = null;
    }
    if (start) {
      start.call(thisp || el, _appendTouchData(e));
    }
    defaultPrevented = defaultPrevented || e.defaultPrevented;
    _addMoveHandler(uuid, function(e) {
      var touch = _getEventTouch(identifier, e);
      if (null !== touch) {
        currentPoint = _getPoint(touch);
        if (move) {
          e = _appendTouchData(e);
          e.currentTarget = el;
          move.call(thisp || el, e);
          defaultPrevented = defaultPrevented || e.defaultPrevented;
        }
        lastPoint = currentPoint;
      }
    });
    _addEndHandler(uuid, function(e) {
      var touch = _getEventTouch(identifier, e);
      if (null !== touch) {
        currentPoint = _getPoint(touch);
        if (end) {
          e = _appendTouchData(e);
          e.currentTarget = el;
          end.call(thisp || el, e);
          defaultPrevented = defaultPrevented || e.defaultPrevented;
        }
        _removeMoveHandler(uuid);
        _removeEndHandler(uuid);
        el = onMove = onEnd = null;
      }
    });
  };
  for (k in eventMap) {
    if (delegate) {
      el.on(k, delegate, eventMap[k]);
    } else {
      el.on(k, eventMap[k]);
    }
  }
  el = null;
};

/**
 * @method $.fn.touch
 * Binds touch start, move, and end handlers to an element, falling back to mouse events when touch isn't supported.
 * Event handlers are passed [[Lavaca.events.TouchEvent]] objects.
 *
 * @sig
 * @param {Object} opts  Parameters to initialize touch event handling
 * @opt {Function} start  Callback to execute when the user begins touching the element
 * @opt {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @opt {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {Object} opts  Parameters to initialize touch event handling
 * @opt {Function} start  Callback to execute when the user begins touching the element
 * @opt {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @opt {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @param {Object} thisp  Context for the callback
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Object} opts  Parameters to initialize touch event handling
 * @opt {Function} start  Callback to execute when the user begins touching the element
 * @opt {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @opt {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Object} opts  Parameters to initialize touch event handling
 * @opt {Function} start  Callback to execute when the user begins touching the element
 * @opt {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @opt {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @param {Object} thisp  Context for the callback
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {Function} start  Callback to execute when the user begins touching the element
 * @param {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @param {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {Function} start  Callback to execute when the user begins touching the element
 * @param {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @param {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @param {Object} thisp  Context for the callback
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} start  Callback to execute when the user begins touching the element
 * @param {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @param {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} start  Callback to execute when the user begins touching the element
 * @param {Function} move  Callback to execute when the user moves the pointer (without ending contact) after touching the element
 * @param {Function} end  Callback to execute when the user stops touching the screen after touching the element
 * @param {Object} thisp  Context for the callback
 * @return {jQuery}  This jQuery object (for chaining)
 */
$.fn.touch = function(delegate, start, move, end, thisp) {
  if (delegate instanceof Function) {
    thisp = end;
    end = move;
    move = start;
    start = delegate;
    delegate = null;
  }
  ns.bind(this, delegate, start, move, end, thisp);
  return this;
};

/**
 * @method $.fn.tap
 * Binds a handler to the tap event (roughly equivalent to a click event, consisting of a touch start and touch end
 * with no touch move). Event handlers are passed [[Lavaca.events.TouchEvent]] objects.
 *
 * @sig
 * @param {Function} callback  Callback to execute when the user taps the element
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {Function} callback  Callback to execute when the user taps the element
 * @param {Object} thisp  Context for the callback
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} callback  Callback to execute when the user taps the element
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} callback  Callback to execute when the user taps the element
 * @param {Object} thisp  Context for the callback
 * @return {jQuery}  This jQuery object (for chaining)
 */
$.fn.tap = function(delegate, callback, thisp) {
  if (typeof delegate == 'function') {
    thisp = callback;
    callback = delegate;
    delegate = null;
  }
  if (_supportsTouchEvents) {
    ns.bind(this, delegate, null, null, function(e) {
      if (!e.hasMoved && callback) {
        callback.apply(thisp || this, arguments);
      }
    });
  } else {
    this.on('click', delegate, function() { callback.apply(thisp || this, arguments); });
  }
  return this;
};

/**
 * @method $.fn.taphold
 * Binds a handler to the tap-and-hold event, where the user taps but waits a minimum amount of time before
 * ending the touch. Event handlers are passed [[Lavaca.events.TouchEvent]] objects.
 *
 * @sig
 * @param {Function} callback  The callback to execute when the user tap-holds the element
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {Function} callback  The callback to execute when the user tap-holds the element
 * @param {Number} duration  The minimum number of milliseconds before the tap counts as a taphold
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {Function} callback  The callback to execute when the user tap-holds the element
 * @param {Number} duration  The minimum number of milliseconds before the tap counts as a taphold
 * @param {Object} thisp  Context for the callback
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} callback  The callback to execute when the user tap-holds the element
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} callback  The callback to execute when the user tap-holds the element
 * @param {Number} duration  The minimum number of milliseconds before the tap counts as a taphold
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} callback  The callback to execute when the user tap-holds the element
 * @param {Number} duration  The minimum number of milliseconds before the tap counts as a taphold
 * @param {Object} thisp  Context for the callback
 * @return {jQuery}  This jQuery object (for chaining)
 */
$.fn.taphold = function(delegate, callback, duration, thisp) {
  if (typeof delegate == 'function') {
    thisp = duration;
    duration = callback;
    callback = delegate;
    delegate = null;
  }
  duration = duration || ns.tapholdDuration;
  this.tap(delegate, function(e) {
    if (e.elapsed >= duration && callback) {
      callback.apply(this, arguments);
    }
  }, thisp);
  return this;
};

/**
 * @method $.fn.swipe
 * Binds handlers to an element to execute when the user gestures in a direction. Event handlers are passed
 * [[Lavaca.events.TouchEvent]] objects.
 *
 * @sig
 * @param {Function} callback  The callback to execute when the user swipes the element
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} callback  The callback to execute when the user swipes the element
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {Function} callback  The callback to execute when the user swipes the element
 * @param {Object} opts  Parameters for the swipe
 * @opt {Number} minDistance  The minimum number of pixels that the touch end point may be from the touch start point
 * @default 30
 * @opt {Number} maxDistance  The maximum number of pixels that the touch end point may be from the touch start point
 * @default null
 * @opt {String} direction  The axis or cardinal direction to which swipes are limited (horizontal, vertical, north, south, east or west)
 * @default 'horizontal'
 * @opt {Number} timeLimit  The maximum number of milliseconds that the gesture may have taken to perform
 * @default 1000
 * @opt {Function} cancel  A callback to execute when the swipe gesture is invalidated because of time, distance or direction requirements
 * @default null
 * @opt {Function} start  A callback to execute when the user starts touching the element
 * @default null
 * @opt {Function} move  A callback to execute when the user moves after touching the element but before ending contact with the screen
 * @default null
 * @opt {Function} end  A callback to execute when the user ends contact with the screen after touching the element
 * @default null
 * @return {jQuery}  This jQuery object (for chaining)
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} callback  The callback to execute when the user swipes the element
 * @param {Object} opts  Parameters for the swipe
 * @opt {Number} minDistance  The minimum number of pixels that the touch end point may be from the touch start point
 * @default 30
 * @opt {Number} maxDistance  The maximum number of pixels that the touch end point may be from the touch start point
 * @default null
 * @opt {String} direction  The axis or cardinal direction to which swipes are limited (horizontal, vertical, north, south, east or west)
 * @default 'horizontal'
 * @opt {Number} timeLimit  The maximum number of milliseconds that the gesture may have taken to perform
 * @default 1000
 * @opt {Function} cancel  A callback to execute when the swipe gesture is invalidated because of time, distance or direction requirements
 * @default null
 * @opt {Function} start  A callback to execute when the user starts touching the element
 * @default null
 * @opt {Function} move  A callback to execute when the user moves after touching the element but before ending contact with the screen
 * @default null
 * @opt {Function} end  A callback to execute when the user ends contact with the screen after touching the element
 * @default null
 * @return {jQuery}  This jQuery object (for chaining)
 */
$.fn.swipe = function(delegate, callback, opts, thisp) {
  if (typeof delegate == 'function') {
    opts = callback;
    callback = delegate;
    delegate = null;
  }
  opts = opts || {};
  var minDistance = opts.minDistance || 30,
      maxDistance = opts.maxDistance || Number.MAX_VALUE,
      direction = opts.direction || 'horizontal',
      timeLimit = opts.timeLimit || 1000,
      onSwipeCancel = opts.cancel || null,
      onSwipeStart = opts.start || null,
      onSwipeMove = opts.move || null,
      onSwipeEnd = opts.end || null;
  function onMove(e) {
    if (e.elapsed <= timeLimit && onSwipeMove) {
      onSwipeMove.apply(thisp || this, arguments);
    }
  }
  function onEnd(e) {
    if (onSwipeEnd) {
      onSwipeEnd.apply(thisp || this, arguments);
    }
    if (e.elapsed <= timeLimit
        && (direction == e.startVector.compass || direction == e.startVector.axis)
        && e.startVector.length >= minDistance
        && e.startVector.length <= maxDistance) {
      if (callback) {
        callback.apply(thisp || this, arguments);
      }
    } else if (onSwipeCancel) {
      onSwipeCancel.apply(thisp || this, arguments);
    }
  }
  ns.bind(this, delegate, onSwipeStart, onMove, onEnd);
  return this;
};

})(Lavaca.resolve('Lavaca.events.Touch', true), Lavaca.$, Lavaca.events.EventVector, Lavaca.events.EventPoint);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $, Cordova) {

/**
 * @class Lavaca.env.Device
 * Static utility type for working with Cordova (aka PhoneGap) and other non-standard native functionality
 */

var _initHasRun = false,
    _onInit = [];
 
/**
 * @method isCordova
 * @static
 * Indicates whether or not the app is being run through Cordova
 *
 * @return {Boolean}  True if app is being run through Cordova
 */
ns.isCordova = function() {
  return !!Cordova;
};

/**
 * @method register
 * @static
 * Registers a plugin to be initialized when the device is ready
 *
 * @param {String} name
 * @param {Function} TPlugin  The plugin to register. The plugin should be a constructor function
 */
ns.register = function(name, TPlugin) {
  function install() {
    if (!window.plugins) {
      window.plugins = {};
    }
    window.plugins[name] = new TPlugin();
  }
  if (_initHasRun) {
    install();
  } else {
    _onInit.push(install);
  }
};

/**
 * @method exec
 * @static
 * Executes a Cordova command, if Cordova is available
 *
 * @param {String} className  The name of the native class
 * @param {String} methodName  The name of the class method to call
 * @param {Array} args  Arguments to pass the method
 * @return {Lavaca.util.Promise}  A promise
 */
ns.exec = function(className, methodName, args) {
  var promise = new Lavaca.util.Promise(window);
  if (Cordova) {
    Cordova.exec(promise.resolver(), promise.rejector(), className, methodName, args);
  } else {
    promise.reject();
  }
  return promise;
};

/**
 * @method init
 * @static
 * Executes a callback when the device is ready to be used
 *
 * @param {Function} callback  The handler to execute when the device is ready
 */
ns.init = function(callback) {
  if (document.addEventListener) {
    // Android fix
    document.addEventListener('deviceready', callback, false);
  } else {
    $(document).on('deviceready', callback);
  }
};

$(document).ready(function() {
  var i = -1,
      installPlugin,
      e;
  while (installPlugin = _onInit[++i]) {
    installPlugin();
  }
  _initHasRun = true;
  if (!Cordova) {
    if (document.createEvent) {
      e = document.createEvent('Events');
      e.initEvent('deviceready', true, false);
      document.dispatchEvent(e);
    } else if (document.fireEvent) {
      e = document.createEventObject();
      e.eventType = 'deviceready';
      document.fireEvent('ondeviceready', e);
    }
  }
});

})(Lavaca.resolve('Lavaca.env.Device', true), Lavaca.$, window.Cordova || window.cordova);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, Device) {

/**
 * @class Lavaca.env.Badge
 * @super Lavaca.events.EventDispatcher
 * A badge management utility (also accessible via window.plugins.badge)
 *
 * @event change
 *
 * @constructor
 */
ns.Badge = Lavaca.events.EventDispatcher.extend({
  /**
   * @method get
   * Gets the current badge count
   *
   * @return {Lavaca.util.Promise}  A promise whose success callbacks will receive the current badge count
   */
  get: function() {
    return Device.exec('Badge', 'get');
  },
  /**
   * @method set
   * Sets the current badge count
   *
   * @param {Number} value  The new badge count
   * @return {Lavaca.util.Promise}  A promise whose success callbacks will receive the new badge count
   */
  set: function(value) {
    var self = this;
    return Device.exec('Badge', 'set', [value]).success(function(v) {
      self.trigger('change', {count: v});
    });
  },
  /**
   * @method increment
   *
   * @sig
   * Increases the current badge count by 1
   * @return {Lavaca.util.Promise}  A promise whose success callbacks will receive the new badge count
   *
   * @sig
   * Increases the current badge count by an amount
   * @param {Number} delta  The amount by which to increase the count
   * @return {Lavaca.util.Promise}  A promise whose success callbacks will receive the new badge count
   */
  increment: function(delta) {
    delta = delta || 1;
    var self = this,
        promise = new Lavaca.util.Promise();
    this.get()
      .success(function(v) {
        self.set(v + delta)
          .success(promise.resolver())
          .error(promise.rejector());
      })
      .error(promise.rejector());
    return promise;
  },
  /**
   * @method decrement
   *
   * @sig
   * Decreases the current badge count by 1
   * @return {Lavaca.util.Promise}  A promise whose success callbacks will receive the new badge count
   *
   * @sig
   * Decreases the current badge count by an amount
   * @param {Number} delta  The amount by which to decrease the count
   * @return {Lavaca.util.Promise}  A promise whose success callbacks will receive the new badge count
   */
  decrement: function(delta) {
    return self.increment(-(delta || 1));
  },
  /**
   * @method clear
   * Removes the badge
   *
   * @return {Lavaca.util.Promise}  A promise whose success callbacks will receive the new badge count
   */
  clear: function() {
    return this.set(0);
  }
});

Device.register('badge', ns.Badge);

})(Lavaca.env, Lavaca.env.Device);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, Device) {

/**
 * @class Lavaca.env.ChildBrowser
 * @super Lavaca.events.EventDispatcher
 * A sub-browser management utility (also accessible via window.plugins.childBrowser)
 *
 * @event open
 * @event close
 * @event change
 *
 * @constructor
 */
ns.ChildBrowser = Lavaca.events.EventDispatcher.extend({
  /**
   * @method showWebPage
   * Opens a web page in the child browser (or navigates to it)
   *
   * @param {String} loc  The URL to open
   * @return {Lavaca.util.Promise}  A promise
   */
  showWebPage: function(loc) {
    if (Device.isCordova()) {
      return Device
        .exec('ChildBrowser', 'showWebPage', [loc])
        .error(function() {
          window.location.href = loc;
        });
    } else {
      window.open(loc);
      return new Lavaca.util.Promise(window).resolve();
    }
  },
  /**
   * @method close
   * Closes the child browser, if it's open
   *
   * @return {Lavaca.util.Promise}  A promise
   */
  close: function() {
    return Device.exec('ChildBrowser', 'close', []);
  }
});

Device.register('childBrowser', ns.ChildBrowser);

})(Lavaca.env, Lavaca.env.Device);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, Device, Promise) {

var UNDEFINED;

function _cordovaDialog(fn, title, message, buttons, promise) {
  if (message === UNDEFINED) {
    message = title;
    title = '';
  }
  if (!buttons) {
    buttons = [];
  }
  buttons = [].concat(buttons);
  var i = -1,
      numButtons = buttons.length,
      button,
      args = [message, function(v) {
          if (fn == 'confirm'
              && (v === UNDEFINED || v === numButtons || (numButtons === 0 && v == 2))) {
            promise.reject((numButtons || 2) - 1);
          } else {
            promise.resolve(v - 1);
          }
        }, title],
      labels = [];
  if (fn == 'confirm') {
    buttons.push(buttons.shift());
  }
  while (button = buttons[++i]) {
    labels.push(button.name);
    if (button.exec) {
      promise[fn == 'confirm' && i == buttons.length - 1 ? 'error' : 'success']((function(n, callback) {
        return function(v) {
          if (v === UNDEFINED) {
            v = numButtons;
          }
          if (v == n) {
            callback(n);
          }
        };
      })(i, button.exec));
    }
  }
  args.push(labels.join(','));
  navigator.notification[fn].apply(navigator.notification, args);
}

/**
 * @class Lavaca.env.Notification
 * @super Lavaca.events.EventDispatcher
 * Notification alerts utility (also accessible via window.plugins.notification)
 *
 * @constructor
 */
ns.Notification = Lavaca.events.EventDispatcher.extend({
  /**
   * @method alert
   * @static
   * Displays an alert dialog
   *
   * @param {String} title  The title to display in the dialog
   * @param {String} message  The message to display in the dialog
   * @param {Array} buttons  A list of buttons and associated callbacks to execute,
   *    depending on which button was clicked. For example: [{name: 'Do this', exec: function() {
   *    console.log('did this'); }}, {name: 'Do that', exec: function() { console.log('did that'); }}]
   * @return {Lavaca.util.Promise}  A promise that's resolved with the index of the clicked button
   */
  alert: function(title, message, buttons) {
    var promise = new Promise();
    if (Device.isCordova()) {
      _cordovaDialog('alert', title, message, buttons, promise);
    } else if (window.alert) {
      button = (buttons || [])[0];
      if (button && button.exec) {
        promise.then(button.exec);
      }
      alert(message || title);
      promise.resolve(0);
    } else {
      promise.reject();
    }
    return promise;
  },
  /**
   * @method confirm
   * @static
   * Displays a confirm dialog
   *
   * @param {String} title  The title to display in the dialog
   * @param {String} message  The message to display in the dialog
   * @param {Array} buttons  A list of buttons and associated callbacks to execute,
   *    depending on which button was clicked. For example: [{name: 'Do this', exec: function() {
   *    console.log('did this'); }}, {name: 'Do that', exec: function() { console.log('did that'); }}]
   * @return {Lavaca.util.Promise}  A promise. When the first button is clicked, the promise is rejected. When any
   *    successive button is clicked, the promise is resolved with the index of the clicked button.
   */
  confirm: function(title, message, buttons) {
    var promise = new Promise();
    if (Device.isCordova()) {
      _cordovaDialog('confirm', title, message, buttons, promise);
    } else if (window.confirm) {
      if (buttons) {
        promise
          .success((buttons[1] || {}).exec)
          .error((buttons[0] || {}).exec);
      }
      confirm(message) ? promise.resolve(1) : promise.reject(0);
    } else {
      promise.reject();
    }
    return promise;
  }
});

Device.register('notification', ns.Notification);

})(Lavaca.env, Lavaca.env.Device, Lavaca.util.Promise);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $) {

var _props = {
      animation: ['animation', 'animationend', 'keyframes'],
      webkitAnimation: ['-webkit-animation', 'webkitAnimationEnd', '-webkit-keyframes'],
      MozAnimation: ['-moz-animation', 'animationend', '-moz-keyframes'],
      OAnimation: ['-o-animation', 'oAnimationEnd', '-o-keyframes'],
      MSAnimation: ['-ms-animation', 'MSAnimationEnd', '-ms-keyframes']
    },
    _prop,
    _cssProp,
    _declaration,
    _event;

(function() {
  var style = document.createElement('div').style,
      s,
      opts;
  for (s in _props) {
    if (s in style) {
      opts = _props[s];
      _prop = s;
      _cssProp = opts[0];
      _event = opts[1];
      _declaration = opts[2];
      break;
    }
  }
})();

/**
 * @class Lavaca.fx.Animation
 * Static utility type for working with CSS keyframe animations
 */

/**
 * @method isSupported
 * @static
 * Whether or not animations are supported by the browser
 *
 * @return {Boolean}  True if CSS keyframe animations are supported
 */
ns.isSupported = function() {
  return !!_prop;
};

/**
 * @method keyframesToCSS
 * @static
 * Converts a list of keyframes to a CSS animation
 *
 * @param {String} name  The name of the keyframe animation
 * @param {Object} keyframes  A list of timestamped keyframes in the form {'0%': {color: 'red'}, '100%': 'color: blue'}
 * @return {String}  The CSS keyframe animation declaration
 */
ns.keyframesToCSS = function(name, keyframes) {
  var Transform = Lavaca.fx.Transform,
      css = ['@', _declaration, ' ', name, '{'],
      time,
      keyframe,
      prop,
      value;
  for (time in keyframes) {
    css.push(time, '{');
    keyframe = keyframes[time];
    if (typeof keyframe == 'string') {
      css.push(keyframe);
    } else {
      for (prop in keyframe) {
        value = keyframe[prop];
        if (prop == 'transform' && Transform) {
          prop = Transform.cssProperty();
          value = Transform.toCSS(value);
        }
        css.push(prop, ':', value, ';');
      }
    }
    css.push('}');
  }
  css.push('}');
  return css.join('');
};

/**
 * @method generateKeyframes
 * @static
 * Generates a keyframe animation
 *
 * @sig
 * @param {Object} keyframes  A list of timestamped keyframes in the form {'0%': {color: 'red'}, '100%': 'color: blue'}
 * @return {String}  The name fo the animation
 *
 * @sig
 * @param {String} name  The name of the animation
 * @param {Object} keyframes  A list of timestamped keyframes in the form {'0%': {color: 'red'}, '100%': 'color: blue'}
 * @return {String}  The name fo the animation
 */
ns.generateKeyframes = function(name, keyframes) {
  if (typeof name == 'object') {
    keyframes = name;
    name = 'a' + (new Date).getTime();
  }
  var css = ns.keyframesToCSS(name, keyframes);
  $('<style>' + css + '</style>').appendTo('head');
  return name;
};

/**
 * @method cssProperty
 * @static
 * Gets the name of the animation CSS property
 *
 * @return {String}  The name of the CSS property
 */
ns.cssProperty = function() {
  return _cssProp;
};

/**
 * @method $.fn.keyframe
 * Applies a keyframe animation to an element
 *
 * @sig
 * @param {String} name  The name of the animation
 * @param {Object} options  Options for the animation
 * @opt {Number} duration  The number of milliseconds that the animation lasts
 * @opt {String} easing  The name of a CSS easing function
 * @default 'linear'
 * @opt {Number} delay  The number of milliseconds before the animation should start
 * @default 0
 * @opt {Object} iterations  Either the number of iterations to play the animation or 'infinite'
 * @default 1
 * @opt {String} direction  The name of a CSS animation direction
 * @default 'normal'
 * @opt {Function} complete  A function to execute when the animation has completed
 * @default null
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {Object} keyframes  A list of timestamped keyframes in the form {'0%': {color: 'red'}, '100%': 'color: blue'}
 * @param {Object} options  Options for the animation
 * @opt {Number} duration  The number of milliseconds that the animation lasts
 * @opt {String} easing  The name of a CSS easing function
 * @default 'linear'
 * @opt {Number} delay  The number of milliseconds before the animation should start
 * @default 0
 * @opt {Object} iterations  Either the number of iterations to play the animation or 'infinite'
 * @default 1
 * @opt {String} direction  The name of a CSS animation direction
 * @default 'normal'
 * @opt {Function} complete  A function to execute when the animation has completed
 * @default null
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {String} name  The name of the animation
 * @param {Number} duration  The number of milliseconds that the animation lasts
 * @param {String} easing  The name of a CSS easing function
 * @param {Number} delay  The number of milliseconds before the animation should start
 * @param {Object} iterations  Either the number of iterations to play the animation or 'infinite'
 * @param {String} direction  The name of a CSS animation direction
 * @param {Function} callback  A function to execute when the animation has completed
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {Object} keyframes  A list of timestamped keyframes in the form {'0%': {color: 'red'}, '100%': 'color: blue'}
 * @param {Number} duration  The number of milliseconds that the animation lasts
 * @param {String} easing  The name of a CSS easing function
 * @param {Number} delay  The number of milliseconds before the animation should start
 * @param {Object} iterations  Either the number of iterations to play the animation or 'infinite'
 * @param {String} direction  The name of a CSS animation direction
 * @param {Function} callback  A function to execute when the animation has completed
 * @return {jQuery}  The jQuery object, for chaining
 */
$.fn.keyframe = function(name, duration, easing, delay, iterations, direction, callback) {
  if (ns.isSupported()) {
    if (typeof name == 'object') {
      name = ns.generateKeyframes(name);
    }
    if (typeof duration == 'object') {
      callback = duration.complete;
      direction = duration.direction;
      iterations = duration.iterations;
      delay = duration.delay;
      easing = duration.easing;
      duration = duration.duration;
    }
    direction = direction || 'normal';
    iterations = iterations || 1;
    delay = delay || 0;
    easing = easing || 'linear';
    duration = duration || 1;
    if (typeof duration == 'number') {
      duration += 'ms';
    }
    if (typeof delay == 'number') {
      delay += 'ms';
    }
    if (callback) {
      this.nextAnimationEnd(callback);
    }
    this.css(ns.cssProperty(), [name, duration, easing, delay, iterations, direction].join(' '));
  }
  return this;
};

/**
 * @method $.fn.animationEnd
 * Binds an animation end handler to an element.
 *
 * @sig
 * @param {Function} callback  Callback for when the animation ends
 * @return {jQuery}  This jQuery object, for chaining
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handler will be bound
 * @param {Function} callback  Callback for when the animation ends
 * @return {jQuery}  This jQuery object, for chaining
 */
$.fn.animationEnd = function(delegate, callback) {
  if (_event) {
    return this.on(_event, delegate, callback);
  } else {
    return this;
  }
};

/**
 * @method $.fn.nextAnimationEnd
 * Binds an animation end handler to an element's next animation end event
 *
 * @sig
 * @param {Function} callback  Callback for when the animation ends
 * @return {jQuery}  This jQuery object, for chaining
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handler will be bound
 * @param {Function} callback  Callback for when the animation ends
 * @return {jQuery}  This jQuery object, for chaining
 */
$.fn.nextAnimationEnd = function(delegate, callback) {
  if (_event) {
    return this.one(_event, delegate, callback);
  } else {
    return this;
  }
};

})(Lavaca.resolve('Lavaca.fx.Animation', true), Lavaca.$);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $) {

var _props = {
      transform: 'transform',
      webkitTransform: '-webkit-transform',
      MozTransform: '-moz-transform',
      OTransform: '-o-transform',
      MSTransform: '-ms-transform'
    },
    _prop,
    _cssProp,
    _3d = false,
    UNDEFINED;

(function() {
  var style = document.createElement('div').style,
      s;
  for (s in _props) {
    if (s in style) {
      _prop = s;
      _cssProp = _props[s];
      style[s] = 'translate3d(0,0,0)';
      _3d = style[s].indexOf('translate3d') > -1 && navigator.userAgent.indexOf('Android') == -1;
      break;
    }
  }
})();

function _isUndefined(value) {
  return value === UNDEFINED;
}

function _toOriginUnit(v) {
  return typeof v == 'number' ? v * 100 + '%' : v;
}

function _scrubRotateValue(v) {
  return typeof v == 'number' ? v + 'deg' : v;
}

function _scrubTranslateValue(v) {
  return typeof v == 'number' ? v + 'px' : v;
}

function _scrubScaleValue(v) {
  return typeof v == 'number' ? v + ',' + v : v;
}

function _scrubTransformValue(prop, value) {
  var isRotate = prop.indexOf('rotate') == 0,
      isScale = prop == 'scale',
      isTranslate = prop.indexOf('translate') == 0,
      isAxisSpecific = /(X|Y|Z)$/.test(prop),
      p,
      css = [];
  if (typeof value == 'object') {
    for (p in value) {
      css.push(prop
        + p.toUpperCase()
        + '('
        + (isTranslate
            ? _scrubTranslateValue(value[p])
            : isRotate
              ? _scrubRotateValue(value[p])
              : isScale
                ? _scrubScaleValue(value[p])
                : value[p])
        + ')');
    }
  } else {
    if (isScale) {
      value = _scrubScaleValue(value);
    } else if (isRotate) {
      value = _scrubRotateValue(value);
    } else if (isTranslate) {
      value = _scrubTranslateValue(value);
    }
    css.push(prop + '(' + value + ')');
  }
  return css.join(' ');
}

/**
 * @class Lavaca.fx.Transform
 * Static utility type for working with CSS transforms
 */

/**
 * @method isSupported
 * @static
 * Whether or not transforms are supported by the browser
 *
 * @return {Boolean}  True when transforms are supported
 */
ns.isSupported = function() {
  return !!_prop;
};

/**
 * @method is3dSupported
 * @static
 * Whether or not 3D transforms are supported by the browser
 *
 * @return {Boolean}  True when 3D transforms are supported
 */
ns.is3dSupported = function() {
  return _3d;
};

/**
 * @method toCSS
 * @static
 * Converts a transform hash into a CSS string
 *
 * @param {Object} opts  A hash of CSS transform values, with properties in
 *      the form {translateX: 1, translateY: 1} or {translate: {x: 1, y: 1}}
 * @opt {Object} translate  An object or string containing the translation values
 * @opt {Object} translateX  A string (in any unit) or number (in pixels) representing the X translation value
 * @opt {Object} translateY  A string (in any unit) or number (in pixels) representing the Y translation value
 * @opt {Object} translateZ  A string (in any unit) or number (in pixels) representing the Z translation value
 * @opt {String} translate3d  A string containing the 3D translation values
 * @opt {Object} rotate  An object, string, or number (in degrees) containing the rotation value(s)
 * @opt {Object} rotateX  A string (in any unit) or number (in degrees) representing the X rotation value
 * @opt {Object} rotateY  A string (in any unit) or number (in degrees) representing the Y rotation value
 * @opt {Object} rotateZ  A string (in any unit) or number (in degrees) representing the Z rotation value
 * @opt {String} rotate3d  A string containing the 3D rotation values
 * @opt {Object} scale  An object, string or number (in percentage points) containing the scale value(s)
 * @opt {Object} scaleX  A string (in any unit) or number (in percentage points) representing the X scale value
 * @opt {Object} scaleY  A string (in any unit) or number (in percentage points) representing the Y scale value
 * @opt {Object} scaleZ  A string (in any unit) or number (in percentage points) representing the Z scale value
 * @opt {String} scale3d  Astring containing the 3D scale values
 * @opt {Object} skew  An object or string containing the skew values
 * @opt {Object} skewX  A string (in any unit) or number (in pixels) representing the X skew value
 * @opt {Object} skewY  A string (in any unit) or number (in pixels) representing the Y skew value
 * @opt {String} matrix  A string containing the matrix transform values
 * @opt {String} matrix3d  A string containing the 3D matrix transform values
 * @opt {String} perspective  A string containing the perspective transform values
 * @return {String}  The generated CSS string
 */
ns.toCSS = function(opts) {
  var css = [],
      prop;
  if (typeof opts == 'object') {
    for (prop in opts) {
      css.push(_scrubTransformValue(prop, opts[prop]));
    }
  } else {
    css.push(opts);
  }
  return css.join(' ');
};

/**
 * @method cssProperty
 * @static
 * Gets the name of the transform CSS property
 *
 * @return {String}  The name of the CSS property
 */
ns.cssProperty = function() {
  return _cssProp;
};

/**
 * @method $.fn.transform
 * Transforms an element
 *
 * @sig
 * @param {String} value  The CSS transform string
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {Object} opt  A hash of CSS transform values, with properties in
 *      the form {translateX: 1, translateY: 1} or {translate: {x: 1, y: 1}}
 * @opt {Object} translate  An object or string containing the translation values
 * @opt {Object} translateX  A string (in any unit) or number (in pixels) representing the X translation value
 * @opt {Object} translateY  A string (in any unit) or number (in pixels) representing the Y translation value
 * @opt {Object} translateZ  A string (in any unit) or number (in pixels) representing the Z translation value
 * @opt {String} translate3d  A string containing the 3D translation values
 * @opt {Object} rotate  An object, string, or number (in degrees) containing the rotation value(s)
 * @opt {Object} rotateX  A string (in any unit) or number (in degrees) representing the X rotation value
 * @opt {Object} rotateY  A string (in any unit) or number (in degrees) representing the Y rotation value
 * @opt {Object} rotateZ  A string (in any unit) or number (in degrees) representing the Z rotation value
 * @opt {String} rotate3d  A string containing the 3D rotation values
 * @opt {Object} scale  An object, string or number (in percentage points) containing the scale value(s)
 * @opt {Object} scaleX  A string (in any unit) or number (in percentage points) representing the X scale value
 * @opt {Object} scaleY  A string (in any unit) or number (in percentage points) representing the Y scale value
 * @opt {Object} scaleZ  A string (in any unit) or number (in percentage points) representing the Z scale value
 * @opt {String} scale3d  Astring containing the 3D scale values
 * @opt {Object} skew  An object or string containing the skew values
 * @opt {Object} skewX  A string (in any unit) or number (in pixels) representing the X skew value
 * @opt {Object} skewY  A string (in any unit) or number (in pixels) representing the Y skew value
 * @opt {String} matrix  A string containing the matrix transform values
 * @opt {String} matrix3d  A string containing the 3D matrix transform values
 * @opt {String} perspective  A string containing the perspective transform values
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {String} value  The CSS transform string
 * @param {String} origin  The CSS transform origin
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {Object} opt  A hash of CSS transform values, with properties in
 *      the form {translateX: 1, translateY: 1} or {translate: {x: 1, y: 1}}
 * @opt {Object} translate  An object or string containing the translation values
 * @opt {Object} translateX  A string (in any unit) or number (in pixels) representing the X translation value
 * @opt {Object} translateY  A string (in any unit) or number (in pixels) representing the Y translation value
 * @opt {Object} translateZ  A string (in any unit) or number (in pixels) representing the Z translation value
 * @opt {String} translate3d  A string containing the 3D translation values
 * @opt {Object} rotate  An object, string, or number (in degrees) containing the rotation value(s)
 * @opt {Object} rotateX  A string (in any unit) or number (in degrees) representing the X rotation value
 * @opt {Object} rotateY  A string (in any unit) or number (in degrees) representing the Y rotation value
 * @opt {Object} rotateZ  A string (in any unit) or number (in degrees) representing the Z rotation value
 * @opt {String} rotate3d  A string containing the 3D rotation values
 * @opt {Object} scale  An object, string or number (in percentage points) containing the scale value(s)
 * @opt {Object} scaleX  A string (in any unit) or number (in percentage points) representing the X scale value
 * @opt {Object} scaleY  A string (in any unit) or number (in percentage points) representing the Y scale value
 * @opt {Object} scaleZ  A string (in any unit) or number (in percentage points) representing the Z scale value
 * @opt {String} scale3d  Astring containing the 3D scale values
 * @opt {Object} skew  An object or string containing the skew values
 * @opt {Object} skewX  A string (in any unit) or number (in pixels) representing the X skew value
 * @opt {Object} skewY  A string (in any unit) or number (in pixels) representing the Y skew value
 * @opt {String} matrix  A string containing the matrix transform values
 * @opt {String} matrix3d  A string containing the 3D matrix transform values
 * @opt {String} perspective  A string containing the perspective transform values
 * @param {String} origin  The CSS transform origin
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {String} value  The CSS transform string
 * @param {Object} origin  The CSS transform origin, in the form {x: N, y: N},
 *      where N is a decimal percentage between -1 and 1 or N is a pixel value > 1 or < -1.
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {Object} opt  A hash of CSS transform values, with properties in
 *      the form {translateX: 1, translateY: 1} or {translate: {x: 1, y: 1}}
 * @opt {Object} translate  An object or string containing the translation values
 * @opt {Object} translateX  A string (in any unit) or number (in pixels) representing the X translation value
 * @opt {Object} translateY  A string (in any unit) or number (in pixels) representing the Y translation value
 * @opt {Object} translateZ  A string (in any unit) or number (in pixels) representing the Z translation value
 * @opt {String} translate3d  A string containing the 3D translation values
 * @opt {Object} rotate  An object, string, or number (in degrees) containing the rotation value(s)
 * @opt {Object} rotateX  A string (in any unit) or number (in degrees) representing the X rotation value
 * @opt {Object} rotateY  A string (in any unit) or number (in degrees) representing the Y rotation value
 * @opt {Object} rotateZ  A string (in any unit) or number (in degrees) representing the Z rotation value
 * @opt {String} rotate3d  A string containing the 3D rotation values
 * @opt {Object} scale  An object, string or number (in percentage points) containing the scale value(s)
 * @opt {Object} scaleX  A string (in any unit) or number (in percentage points) representing the X scale value
 * @opt {Object} scaleY  A string (in any unit) or number (in percentage points) representing the Y scale value
 * @opt {Object} scaleZ  A string (in any unit) or number (in percentage points) representing the Z scale value
 * @opt {String} scale3d  Astring containing the 3D scale values
 * @opt {Object} skew  An object or string containing the skew values
 * @opt {Object} skewX  A string (in any unit) or number (in pixels) representing the X skew value
 * @opt {Object} skewY  A string (in any unit) or number (in pixels) representing the Y skew value
 * @opt {String} matrix  A string containing the matrix transform values
 * @opt {String} matrix3d  A string containing the 3D matrix transform values
 * @opt {String} perspective  A string containing the perspective transform values
 * @param {Object} origin  The CSS transform origin, in the form {x: N, y: N},
 *      where N is a decimal percentage between -1 and 1 or N is a pixel value > 1 or < -1.
 * @return {jQuery}  The jQuery object, for chaining
 */
$.fn.transform = function(value, origin) {
  if (ns.isSupported()) {
    value = ns.toCSS(value);
    if (origin) {
      if (typeof origin == 'object') {
        origin = _toOriginUnit(origin.x) + (_isUndefined(origin.y) ? '' : ' ' + _toOriginUnit(origin.y));
      }
    }
    this.each(function() {
      this.style[_prop] = value;
      if (origin) {
        this.style[_prop + 'Origin'] = origin;
      }
    });
  }
  return this;
};

})(Lavaca.resolve('Lavaca.fx.Transform', true), Lavaca.$);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $) {

var _props = {
      transition: ['transition', 'transitionend'],
      webkitTransition: ['-webkit-transition', 'webkitTransitionEnd'],
      MozTransition: ['-moz-transition', 'MozTransitionEnd'],
      OTransition: ['-o-transition', 'OTransitionEnd'],
      MSTransition: ['-ms-transition', 'MSTransitionEnd']
    },
    _prop,
    _cssProp,
    _event;

(function() {
  var style = document.createElement('div').style,
      s;
  for (s in _props) {
    if (s in style) {
      _prop = s;
      _cssProp = _props[s][0];
      _event = _props[s][1];
      break;
    }
  }
})();

/**
 * @class Lavaca.fx.Transition
 * Static utility type for working with CSS transitions
 */

/**
 * @method isSupported
 * @static
 * Whether or not transitions are supported by the browser
 *
 * @return {Boolean}  True when CSS transitions are supported
 */
ns.isSupported = function() {
  return !!_prop;
};

/**
 * @method toCSS
 * @static
 * Generates a CSS transition property string from several values
 *
 * @sig
 * @param {Object} props  A hash in which the keys are the names of the CSS properties
 * @param {Number} duration  The amount of time in milliseconds that the transition lasts
 * @return {String}  The generated CSS string
 *
 * @sig
 * @param {Array} props  An array of CSS property names
 * @param {Number} duration  The amount of time in milliseconds that the transition lasts
 * @return {String}  The generated CSS string
 *
 * @sig
 * @param {Object} props  A hash in which the keys are the names of the CSS properties
 * @param {Number} duration  The amount of time in milliseconds that the transition lasts
 * @param {String} easing  The interpolation for the transition
 * @return {String}  The generated CSS string
 *
 * @sig
 * @param {Array} props  An array of CSS property names
 * @param {Number} duration  The amount of time in milliseconds that the transition lasts
 * @param {String} easing  The interpolation for the transition
 * @return {String}  The generated CSS string
 */
ns.toCSS = function(props, duration, easing) {
  easing = easing || 'linear';
  var css = [],
      isArray = props instanceof Array,
      prop;
  for (prop in props) {
    if (isArray) {
      prop = props[prop];
    }
    css.push(prop + ' ' + duration + 'ms ' + easing);
  }
  return css.join(',');
};

/**
 * @method cssProperty
 * @static
 * Gets the name of the transition CSS property
 *
 * @return {String}  The name of the CSS property
 */
ns.cssProperty = function() {
  return _cssProp;
};

/**
 * @method $.fn.transition
 * Causes an element to undergo a transition
 *
 * @sig
 * @param {Object} props  The CSS property values at the end of the transition
 * @param {Number} duration  The amount of time in milliseconds that the transition lasts
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {Object} props  The CSS property values at the end of the transition
 * @param {Number} duration  The amount of time in milliseconds that the transition lasts
 * @param {String} easing  The interpolation for the transition
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {Object} props  The CSS property values at the end of the transition
 * @param {Number} duration  The amount of time in milliseconds that the transition lasts
 * @param {Function} callback  A function to execute when the transition completes
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {Object} props  The CSS property values at the end of the transition
 * @param {Number} duration  The amount of time in milliseconds that the transition lasts
 * @param {String} easing  The interpolation for the transition
 * @param {Function} callback  A function to execute when the transition completes
 * @return {jQuery}  The jQuery object, for chaining
 */
$.fn.transition = function(props, duration, easing, callback) {
  if (easing instanceof Function) {
      callback = easing;
      easing = null;
  }
  if (ns.isSupported()) {
    var css = ns.toCSS(props, duration, easing);
    if (callback) {
      this.nextTransitionEnd(callback);
    }
    this.each(function() {
      this.style[_prop] = css;
    });
    this.css(props);
  } else {
    this.css(props);
    if (callback) {
      callback.call(this[0], {});
    }
  }
  return this;
};

/**
 * @method $.fn.transitionEnd
 * Binds a transition end handler to an element.
 *
 * @sig
 * @param {Function} callback  Callback for when the transition ends
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} callback  Callback for when the transition ends
 * @return {jQuery}  The jQuery object, for chaining
 */
$.fn.transitionEnd = function(delegate, callback) {
  if (_event) {
    return this.on(_event, delegate, callback);
  } else {
    return this;
  }
};

/**
 * @method $.fn.nextTransitionEnd
 * Binds a transition end handler to an element's next transition end event.
 *
 * @sig
 * @param {Function} callback  Callback for when the transition ends
 * @return {jQuery}  The jQuery object, for chaining
 *
 * @sig
 * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound
 * @param {Function} callback  Callback for when the transition ends
 * @return {jQuery}  The jQuery object, for chaining
 */
$.fn.nextTransitionEnd = function(delegate, callback) {
  if (_event) {
    return this.one(_event, delegate, callback);
  } else {
    return this;
  }
};

})(Lavaca.resolve('Lavaca.fx.Transition', true), Lavaca.$);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, Disposable, Promise, StringUtils, $) {

/**
 * @class Lavaca.mvc.Controller
 * @super Lavaca.util.Disposable
 * Base type for controllers
 *
 * @constructor
 * @param {Lavaca.mvc.Controller} other  Another controller from which to take context information
 *
 * @constructor
 * @param {Lavaca.mvc.Router} router  The application's router
 * @param {Lavaca.mvc.ViewManager} viewManager  The application's view manager
 */
ns.Controller = Disposable.extend(function(router, viewManager) {
  if (router instanceof ns.Controller) {
    this.router = router.router;
    this.viewManager = router.viewManager;
  } else {
    this.router = router;
    this.viewManager = viewManager;
  }
}, {
  /**
   * @field {Lavaca.mvc.Router} router
   * @default null
   * The application's router
   */
  router: null,
  /**
   * @field {Lavaca.mvc.ViewManager} viewManager
   * @default null
   * The application's view manager
   */
  viewManager: null,
  /**
   * @method exec
   * Executes an action on this controller
   *
   * @sig
   * @param {String} action  The name of the controller method to call
   * @param {Object} params  Key-value arguments to pass to the action
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig
   * @param {String} action  The name of the controller method to call
   * @param {Object} params  Key-value arguments to pass to the action
   * @param {Object} state  A history record object
   * @return {Lavaca.util.Promise}  A promise
   */
  exec: function(action, params, state) {
    this.params = params;
    this.state = state;
    var promise = new Promise(this),
        model,
        result;
    if (state) {
      model = state.state;
      promise.success(function() {
        document.title = state.title;
      });
    }
    result = this[action](params, model);
    if (result instanceof Promise) {
      promise.when(result);
    } else {
      promise.resolve();
    }
    return promise;
  },
  /**
   * @method ajax
   * Makes an AJAX request
   *
   * @param {Object} opts  jQuery AJAX options
   * @return {Lavaca.util.Promise}  A promise
   */
  ajax: function(opts) {
    return Promise.when(this, Lavaca.net.Connectivity.ajax(opts));
  },
  /**
   * @method view
   * Loads a view
   *
   * @param {String} cacheKey  The key under which to cache the view
   * @param {Function} TView  The type of view to load (should derive from [[Lavaca.mvc.View]])
   * @param {Object} model  The data object to pass to the view
   * @param {Number} layer  The integer indicating what UI layer the view sits on
   * @return {Lavaca.util.Promise}  A promise
   */
  view: function(cacheKey, TView, model, layer) {
    return Promise.when(this, this.viewManager.load(cacheKey, TView, model, layer));
  },
  /**
   * @method ajaxThenView
   * Makes an AJAX request and then loads a view if successful
   *
   * @param {Object} opts  jQuery AJAX options
   * @param {Function} responseToModel  A function that converts the AJAX response to
   *   a model for the view
   * @param {String} cacheKey  The key under which to cache the view
   * @param {Function} TView  The type of view (should derive from [[Lavaca.mvc.View]])
   * @param {Number} layer  The layer on which the view sits
   * @return {Lavaca.util.Promise}  A promise
   */
  ajaxThenView: function(opts, responseToModel, cacheKey, TView, layer) {
    var promise = new Promise(this),
        self = this;
    this.ajax(opts)
      .success(function(resp) {
        promise.when(this.view(cacheKey, TView, responseToModel.apply(self, arguments), layer));
      })
      .error(function() {
        promise.reject.apply(promise, arguments);
      });
    return promise;
  },
  /**
   * @method history
   * Adds a state to the browser history
   *
   * @param {Object} state  A data object associated with the page state
   * @param {String} title  The title of the page state
   * @param {String} url  The URL of the page state
   */
  history: function(state, title, url) {
    var needsHistory = !this.state;
    return function() {
      if (needsHistory) {
        Lavaca.net.History.push(state, title, url);
      }
    };
  },
  /**
   * @method translate
   * Convenience method for accessing translated messages
   *
   * @sig
   * @param {String} code  The key of the translated message
   * @return {String} The translated message
   *
   * @sig
   * @param {String} code  The key of the translated message
   * @param {Array} args  Values to substitute into the message using [[Lavaca.util.StringUtils]].format()
   * @return {String}  The translated message
   */
  translate: function(code, args) {
    var result = Lavaca.util.Translation.get(code);
    if (result && args) {
      result = StringUtils.format.apply(null, [result].concat(args));
    }
    return result;
  },
  /**
   * @method url
   * Convenience method for formatting URLs
   *
   * @param {String} str  The URL string
   * @param {Array} args  Format arguments to insert into the URL
   * @return {String}  The formatted URL
   */
  url: function(str, args) {
    return StringUtils.format(str, args, encodeURIComponent);
  },
  /**
   * @method redirect
   * Directs the user to another route
   *
   * @sig
   * @param {String} str  The URL string
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig
   * @param {String} str  The URL string
   * @param {Array} args  Format arguments to insert into the URL
   * @return {Lavaca.util.Promise}  A promise
   */
  redirect: function(str, args) {
    return this.router.unlock().exec(this.url(str, args || []));
  },
  /**
   * @method ajaxThenRedirect
   * Makes an AJAX request and then redirects to an action if successful
   *
   * @param {Object} opts  jQuery AJAX options
   * @param {Function} responseToURL  A function to call after the AJAX operation completes
   *    that returns the URL to which to redirect
   * @return {Lavaca.util.Promise}  A promise
   */
  ajaxThenRedirect: function(opts, responseToURL) {
    var promise = new Promise(this),
        self = this;
    this.ajax(opts)
      .success(function(resp) {
        promise.when(this.redirect(responseToURL.apply(self, arguments)));
      })
      .error(function() {
        promise.reject.apply(promise, arguments);
      });
    return promise;
  },
  /**
   * @method dispose
   * Readies the controller for garbage collection
   */
  dispose: function() {
    // Do not dispose of view manager or router
    this.router
      = this.viewManager
      = null;
    Disposable.prototype.dispose.apply(this, arguments);
  }
});

})(Lavaca.resolve('Lavaca.mvc', true), Lavaca.util.Disposable, Lavaca.util.Promise, Lavaca.util.StringUtils, Lavaca.$);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, EventDispatcher, Cache, Promise, ArrayUtils) {

var UNDEFINED;

function _triggerAttributeEvent(model, event, attribute, previous, value, messages) {
  model.trigger(event, {
    attribute: attribute,
    previous: previous === UNDEFINED ? null : previous,
    value: value === UNDEFINED ? model.get(attribute) : value,
    messages: messages || []
  });
};

function _setFlagOn(model, name, flag) {
  var keys = model.flags[flag];
  if (!keys) {
    keys = model.flags[flag] = [];
  }
  if (!ArrayUtils.contains(keys, name)) {
    keys.push(name);
  }
}

function _suppressChecked(model, suppress, callback) {
  suppress = !!suppress;
  var props = ['suppressValidation', 'suppressEvents', 'suppressTracking'],
      old = {},
      i = -1,
      prop,
      result;
  while (prop = props[++i]) {
    old[prop] = model[prop];
    model[prop] = suppress || model[prop];
  }
  result = callback.call(model);
  i = -1;
  while (prop = props[++i]) {
    model[prop] = old[prop];
  }
  return result;
}

// Virtual type
/**
 * @class Lavaca.mvc.AttributeEvent
 * @super Event
 * Event type used when an attribute is modified
 *
 * @field {String} attribute
 * @default null
 * The name of the event-causing attribute
 *
 * @field {Object} previous
 * @default null
 * The value of the attribute before the event
 *
 * @field {Object} value
 * @default null
 * The value of the attribute after the event
 *
 * @field {Array} messages
 * @default []
 * A list of validation messages the change caused
 */

/** 
 * @class Lavaca.mvc.Model
 * @super Lavaca.events.EventDispatcher
 * Basic model type
 *
 * @event change
 * @event invalid
 * @event fetchSuccess
 * @event fetchError
 * @event saveSuccess
 * @event saveError
 *
 * @constructor
 *
 * @constructor
 * @param {Object} map  A parameter hash to apply to the model
 */
ns.Model = EventDispatcher.extend(function(map) {
  EventDispatcher.call(this);
  this.attributes = new Cache();
  this.rules = new Cache();
  this.unsavedAttributes = [];
  this.flags = {};
  if (map) {
    this.suppressEvents
      = this.suppressTracking
      = true;
    this.apply(map);
    this.suppressEvents
      = this.suppressTracking
      = false;
  }
}, {
  /**
   * @field {Boolean} suppressValidation
   * @default false
   * When true, attributes are not validated
   */
  suppressValidation: false,
  /**
   * @field {Boolean} suppressTracking
   * @default false
   * When true, changes to attributes are not tracked
   */
  suppressTracking: false,
  /**
   * @method get
   * Gets the value of a attribute
   *
   * @param {String} attribute  The name of the attribute
   * @return {Object}  The value of the attribute, or null if there is no value
   */
  get: function(attribute) {
    return this.attributes.get(attribute);
  },
  /**
   * @method canSet
   * Determines whether or not an attribute can be assigned
   *
   * @param {String} attribute  The name of the attribute
   * @return {Boolean}  True if you can assign to the attribute
   */
  canSet: function(attribute) {
    return true;
  },
  /**
   * @method set
   * Sets the value of the attribute, if it passes validation
   *
   * @event invalid
   * @event change
   *
   * @sig
   * @param {String} attribute  The name of the attribute
   * @param {Object} value  The new value
   * @return {Boolean}  True if attribute was set, false otherwise
   *
   * @sig
   * @param {String} attribute  The name of the attribute
   * @param {Object} value  The new value
   * @param {String} flag  A metadata flag describing the attribute
   * @param {Boolean} suppress  When true, validation, events and tracking are suppressed
   * @return {Boolean}  True if attribute was set, false otherwise
   */
  set: function(attribute, value, flag, suppress) {
    return _suppressChecked(this, suppress, function() {
      if (!this.canSet(attribute)) {
        return false;
      }
      var previous = this.attributes.get(attribute),
          messages = this.suppressValidation ? [] : this.validate(attribute, value);
      if (messages.length) {
        _triggerAttributeEvent(this, 'invalid', attribute, previous, value, messages);
        return false;
      } else {
        if (previous !== value) {
          this.attributes.set(attribute, value);
          if (flag) {
            _setFlagOn(this, attribute, flag);
          }
          _triggerAttributeEvent(this, 'change', attribute, previous, value);
          if (!this.suppressTracking
              && !Lavaca.util.ArrayUtils.contains(this.unsavedAttributes, attribute)) {
            this.unsavedAttributes.push(attribute);
          }
        }
        return true;
      }
    });
  },
  /**
   * @method has
   * Determines whether or not this model has a named attribute
   *
   * @param {String} attribute  The name of the attribute
   * @return {Boolean}  True if the attribute exists and has a value
   */
  has: function(attribute) {
    return this.get(attribute) !== null;
  },
  /**
   * @field {String} idAttribute
   * @default 'id'
   * The name of the ID attribute
   */
  idAttribute: 'id',
  /**
   * @method id
   * Gets the ID of the model
   *
   * @return {String}  The ID of the model
   */
  id: function() {
    return this.get(this.idAttribute);
  },
  /**
   * @method isNew
   * Determines whether or not this model has been saved before
   *
   * @return {Boolean}  True when the model has no ID associated with it
   */
  isNew: function() {
    return null === this.id();
  },
  /**
   * @method parse
   * Ensures that a map is suitable to be applied to this model
   *
   * @param {Object} map  The string or key-value hash to parse
   * @return {Object}  The parsed version of the map
   */
  parse: function(map) {
    if (typeof map == 'string') {
      map = JSON.parse(map);
    }
    return map;
  },
  /**
   * @method apply
   * Sets each attribute of this model according to the map
   *
   * @sig
   * @param {Object} map  The string or key-value map to parse and apply
   *
   * @sig
   * @param {Object} map  The string or key-value map to parse and apply
   * @param {Boolean} suppress  When true, validation, events and tracking are suppressed
   */
  apply: function(map, suppress) {
    _suppressChecked(this, suppress, function() {
      map = this.parse(map);
      for (var n in map) {
        this.set(n, map[n]);
      }
    });
  },
  /**
   * @method clear
   *
   * @sig
   * Removes all data from the model
   *
   * @sig
   * Removes all flagged data from the model
   * @param {String} flag  The metadata flag describing the data to remove
   */
  clear: function(flag) {
    if (flag) {
      var attrs = this.flags[flag],
          i = -1,
          attr,
          item;
      if (attrs) {
        while (attr = attrs[++i]) {
          ArrayUtils.remove(this.unsavedAttributes, attr);
          item = this.get(attr);
          if (item && item.dispose) {
            item.dispose();
          }
          this.set(attr, null);
        }
      }
    } else {
      this.attributes.dispose();
      this.attributes = new Cache();
      this.unsavedAttributes.length = 0;
    }
  },
  /**
   * @method clone
   * Makes a copy of this model
   *
   * @return {Lavaca.mvc.Model}  The copy
   */
  clone: function() {
    return new this.constructor(this.attributes.toObject());
  },
  /**
   * @method addRule
   * Adds a validation rule to this model
   *
   * @param {String} attribute  The name of the attribute to which the rule applies
   * @param {Function} callback  The callback to use to validate the attribute, in the
   *   form callback(attribute, value)
   * @param {String} message  A text message used when a value fails the test
   */
  addRule: function(attribute, callback, message) {
    this.rules.get(attribute, []).push({rule: callback, message: message});
  },
  /** 
   * @method validate
   *
   * @sig Validates all attributes on the model
   * @return {Object}  A map of attribute names to validation error messages
   *
   * @sig Runs validation tests for a specific attribute
   * @param {String}  The name of the attribute to test
   * @return {Array}  A list of validation error messages
   *
   * @sig Runs validation against a potential value for a attribute
   * @param {String} attribute  The name of the attribute
   * @param {Object} value  The potential value for the attribute
   * @return {Array}  A list of validation error messages
   */
  validate: function(attribute, value) {
    var messages,
        rules,
        i = -1,
        rule;
    if (attribute) {
      messages = [];
      value = value === UNDEFINED ? this.get(attribute, value) : value;
      rules = this.rules.get(attribute);
      if (rules) {
        while (rule = rules[++i]) {
          if (!rule.rule(attribute, value)) {
            messages.push(rule.message);
          }
        }
      }
      return messages;
    } else {
      messages = {};
      this.rules.each(function(attributeName, rules) {
        messages[attribute] = this.validate(attribute);
      }, this);
      return messages;
    }
  },
  /**
   * @method onFetchSuccess
   * Processes the data received from a fetch request
   *
   * @param {Object} response  The response data
   */
  onFetchSuccess: function(response) {
    response = this.parse(response);
    this.apply(response, true);
    this.trigger('fetchSuccess', {response: response});
  },
  /**
   * @method onFetchError
   * Triggered when the model is unable to fetch data
   *
   * @param {Object} value  The error value
   */
  onFetchError: function(response) {
    this.trigger('fetchError', {response: response});
  },
  /**
   * @method fetch
   * Loads the data for this model from the server (Note: Does not clear the model first)
   *
   * @event fetchSuccess
   * @event fetchError
   *
   * @sig
   * @param {String} url  The URL from which to load the data
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig
   * @param {String} url  The URL from which to load the data
   * @param {Object} options  jQuery AJAX settings
   * @return {Lavaca.util.Promise}  A promise
   */
  fetch: function(url, options) {
    options = Lavaca.clone(options || {});
    options.url = url;
    return Promise.when(this, Lavaca.net.Connectivity.ajax(options))
      .success(this.onFetchSuccess)
      .error(this.onFetchError);
  },
  /**
   * @method save
   * Saves the model
   *
   * @event saveSuccess
   * @event saveError
   *
   * @sig
   * @param {Function} callback  A function callback(model, changedAttributes, attributes)
   *   that returns either a promise or a truthy value
   *   indicating whether the operation failed or succeeded
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig
   * @param {Function} callback  A function callback(model, changedAttributes, attributes)
   *   that returns either a promise or a truthy value
   *   indicating whether the operation failed or succeeded
   * @param {Object} thisp  The context for the callback
   * @return {Lavaca.util.Promise}  A promise
   */
  save: function(callback, thisp) {
    var promise = new Promise(this),
        attributes = this.toObject(),
        changedAttributes = {},
        i = -1,
        attribute,
        result;
    while (attribute = this.unsavedAttributes[++i]) {
      changedAttributes[attribute] = attributes[attribute];
    }
    promise
      .success(function(value) {
        var idAttribute = this.idAttribute;
        if (this.isNew() && value[idAttribute] !== UNDEFINED) {
          this.set(idAttribute, value[idAttribute]);
        }
        this.unsavedAttributes = [];
        this.trigger('saveSuccess', {response: value});
      })
      .error(function(value) {
        this.trigger('saveError', {response: value});
      });
    result = callback.call(thisp || this, this, changedAttributes, attributes);
    if (result instanceof Promise) {
      promise.when(result);
    } else if (result) {
      promise.resolve(result);
    } else {
      promise.reject(result);
    }
    return promise;
  },
  /**
   * @method saveToServer
   * Saves the model to the server via POST
   *
   * @param {String} url  The URL to which to post the data
   * @return {Lavaca.util.Promise}  A promise
   */
  saveToServer: function(url) {
    return this.save(function(model, changedAttributes, attributes) {
      var id = this.id(),
          data;
      if (this.isNew()) {
        data = attributes;
      } else {
        changedAttributes[this.idAttribute] = id;
        data = changedAttributes;
      }
      return Promise.when(this, Lavaca.net.Connectivity.ajax({
          url: url,
          cache: false,
          type: 'POST',
          data: data,
          dataType: 'json'
        }));
    });
  },
  /**
   * @method toObject
   * Converts this model to a key-value hash
   *
   * @return {Object}  The key-value hash
   */
  toObject: function() {
    return this.attributes.toObject();
  },
  /**
   * @method toJSON
   * Converts this model to JSON
   *
   * @return {String}  The JSON string representing the model
   */
  toJSON: function() {
    return JSON.stringify(this.toObject());
  },
  /**
   * @method on
   *
   * Bind an event handler to this object
   *
   * @sig
   * @param {String} type  The name of the event
   * @param {Function} callback  The function to execute when the event occurs
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   *
   * @sig
   * @param {String} type  The name of the event
   * @param {String} attr  An attribute to which to limit the scope of events
   * @param {Function} callback  The function to execute when the event occurs
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   *
   * @sig
   * @param {String} type  The name of the event
   * @param {Function} callback  The function to execute when the event occurs
   * @param {Object} thisp  The context of the handler
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   *
   * @sig
   * @param {String} type  The name of the event
   * @param {String} attr  An attribute to which to limit the scope of events
   * @param {Function} callback  The function to execute when the event occurs
   * @param {Object} thisp  The context of the handler
   * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)
   */
  on: function(type, attr, callback, thisp) {
    if (typeof attr == 'function') {
      thisp = callback;
      callback = attr;
      attr = null;
    }
    function handler(e) {
      if (!attr || e.attribute == attr) {
        callback.call(thisp || this, e);
      }
    }
    handler.fn = callback;
    handler.thisp = thisp;
    return EventDispatcher.prototype.on.call(this, type, handler, thisp);
  }
});
/**
 * @field {String} SENSITIVE
 * @static
 * @default 'sensitive'
 * Flag indicating that data is sensitive
 */
ns.Model.SENSITIVE = 'sensitive';

})(Lavaca.resolve('Lavaca.mvc', true), Lavaca.events.EventDispatcher, Lavaca.util.Cache, Lavaca.util.Promise, Lavaca.util.ArrayUtils);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, Model, Cache, Promise, ArrayUtils) {

var UNDEFINED;

function _triggerItemEvent(collection, event, previousIndex, index, model) {
  collection.trigger(event, {
    previousIndex: previousIndex,
    index: index,
    model: model
  });
}

// Virtual type
/**
 * @class Lavaca.mvc.ItemEvent
 * @super Event
 * Event type used when a model in a collection has an event
 *
 * @field {Lavaca.mvc.Collection} target
 * @default null
 * The collection that contains (or contained) the model that caused the event
 *
 * @field {Lavaca.mvc.Model} model
 * @default null
 * The model that caused the event
 *
 * @field {Number} index
 * @default null
 * The index of the event-causing model in the collection
 *
 * @field {Number} previousIndex
 * @default null
 * The index of the event-causing model before the event
 */

/**
 * @class Lavaca.mvc.Collection
 * @super Lavaca.mvc.Model
 * Basic model collection type
 *
 * @event change
 * @event invalid
 * @event fetchSuccess
 * @event fetchError
 * @event saveSuccess
 * @event saveError
 * @event changeItem
 * @event invalidItem
 * @event saveSuccessItem
 * @event saveErrorItem
 * @event moveItem
 *
 * @constructor
 *
 * @constructor
 * @param {Array} models  A list of models to add to the collection
 *
 * @constructor
 * @param {Array} models  A list of models to add to the collection
 * @param {Object} map  A parameter hash to apply to the collection
 */
ns.Collection = Model.extend(function(models, map) {
  Model.call(this, map);
  this.models = [];
  this.changedOrder = false;
  this.addedItems = [];
  this.removedItems = [];
  this.changedItems = [];
  if (models) {
    this.suppressEvents = true;
    this.add.apply(this, models);
    this.suppressEvents = false;
  }
}, {
  /**
   * @field {Function} TModel
   * @default [[Lavaca.mvc.Model]]
   * The type of model object to use for items in this collection
   */
  TModel: ns.Model,
  /** 
   * @field {String} itemsProperty
   * @default 'items'
   * The name of the property containing the collection's items when using toObject()
   */
  itemsProperty: 'items',
  /**
   * @method clear
   * Removes and disposes of all models in the collection
   */
  clear: function() {
    Model.prototype.clear.apply(this, arguments);
    var i = -1,
        model;
    while (model = this.models[++i]) {
      this.remove(model);
    }
    this.changedOrder = false;
    this.addedItems.length
      = this.removedItems.length
      = this.changedItems.length
      = this.models.length = 0;
  },
  /**
   * @method prepare
   * Readies data to be an item in the collection
   *
   * @param {Object} data  The model or object to be added
   * @return {Lavaca.mvc.Model}  The model derived from the data
   */
  prepare: function(data) {
    var model = data instanceof this.TModel
          ? data
          : this.TModel.prototype instanceof ns.Collection
            ? new this.TModel(data[this.TModel.prototype.itemsProperty], data)
            : new this.TModel(data),
        index = ArrayUtils.indexOf(this.models, model);
    if (index == -1) {
      model
        .on('change', this.onItemEvent, this)
        .on('invalid', this.onItemEvent, this)
        .on('saveSuccess', this.onItemEvent, this)
        .on('saveError', this.onItemEvent, this);
    }
    return model;
  },
  /**
   * @method canSet
   * Determines whether or not an attribute can be assigned
   *
   * @param {String} attribute  The name of the attribute
   * @return {Boolean}  True if you can assign to the attribute
   */
  canSet: function(attribute) {
    return attribute != this.itemsProperty;
  },
  /**
   * @method add
   * Adds one or more items to the collection
   *
   * @event add
   *
   * @params {Object} item  The items to add to the collection
   * @return {Boolean}  True if an item was added, false otherwise
   */
  add: function(/* item1, item2, itemN */) {
    var result = false,
        i,
        j,
        model,
        isModel,
        index;
    for (i = 0, j = arguments.length; i < j; i++) {
      model = arguments[i];
      isModel = model instanceof this.TModel;
      model = this.prepare(model);
      index = ArrayUtils.indexOf(this.models, model);
      if (!isModel || !ArrayUtils.contains(this.models, model)) {
        this.models.push(model);
        if (!this.suppressTracking) {
          ArrayUtils.remove(this.removedItems, model);
          ArrayUtils.remove(this.changedItems, model);
          ArrayUtils.pushIfNotExists(this.addedItems, model);
        }
        _triggerItemEvent(this, 'addItem', null, index, model);
        result = true;
      }
    }
    return result;
  },
  /**
   * @method moveTo
   * Moves an item
   *
   * @sig
   * @param {Lavaca.mvc.Model} model  The model to move
   * @param {Number} newIndex  The new index at which the model should be placed
   *
   * @sig
   * @param {Number} oldIndex  The current index of the model
   * @param {Number} newIndex  The new index at which the model should be placed
   */
  moveTo: function(oldIndex, newIndex) {
    if (oldIndex instanceof this.TModel) {
      oldIndex = ArrayUtils.indexOf(this.models, oldIndex);
    }
    if (oldIndex > -1) {
      var model = this.models.splice(oldIndex, 1)[0];
      if (model) {
        this.models.splice(newIndex, 0, model);
        if (!this.suppressTracking) {
          this.changedOrder = true;
        }
        _triggerItemEvent(this, 'moveItem', oldIndex, newIndex, model);
      }
    }
  },
  /**
   * @method remove
   * Removes an item from the collection
   *
   * @event remove
   *
   * @sig
   * @params {Lavaca.mvc.Model} item  The models to remove from the collection
   * @return {Boolean}  True if an item was removed, false otherwise
   *
   * @sig
   * @param {Object} attributes  A set of attributes matching any models to remove
   * @return {Boolean}  True if at least one item was removed, false otherwise
   *
   * @sig
   * @param {Function} test  A function to check each model in the collection in the form
   *     test(index, model). If the test function returns true, the model will be removed
   * @return {Boolean}  True if at least one item was removed, false otherwise
   */
  remove: function(item) {
    if (item instanceof this.TModel) {
      var index = ArrayUtils.remove(this.models, item);
      if (index > -1) {
        if (!this.suppressTracking) {
          ArrayUtils.remove(this.addedItems, item);
          ArrayUtils.remove(this.changedItems, item);
          ArrayUtils.pushIfNotExists(this.removedItems, item);
        }
        item
          .off('change', this.onItemEvent)
          .off('invalid', this.onItemEvent)
          .off('saveSuccess', this.onItemEvent)
          .off('saveError', this.onItemEvent);
        _triggerItemEvent(this, 'removeItem', index, null, item);
        return true;
      } else {
        return false;
      }
    } else {
      var items = this.filter(item),
          i = -1,
          removed = false;
      while (item = items[++i]) {
        removed = this.remove(item) || removed;
      }
      return removed;
    }
  },
  /**
   * @method filter
   *
   * @sig
   * Compiles a list of items matching an attribute hash
   * @param {Object} The attributes to test against each model
   * @return {Array}  A list of this collection's models that matched the attributes
   *
   * @sig
   * Compiles a list of items matching an attribute hash
   * @param {Object} attributes  The attributes to test against each model
   * @param {Number} maxResults  The maximum number of results to return
   * @return {Array}  A list of this collection's models that matched the attributes
   *
   * @sig
   * Compiles a list of items passing a test
   * @param {Function} test  A function to check each model in the collection in the form
   *     test(index, model). If the test function returns true, the model will be included
   *     in the result
   * @return {Array}  A list of this collection's models that passed the test
   *
   * @sig
   * Compiles a list of items passing a test
   * @param {Function} test  A function to check each model in the collection in the form
   *     test(index, model). If the test function returns true, the model will be included
   *     in the result
   * @param {Number} maxResults  The maximum number of results to return
   * @return {Array}  A list of this collection's models that passed the test
   */
  filter: function(test, maxResults) {
    maxResults = maxResults === UNDEFINED ? Number.MAX_VALUE : maxResults;
    var result = [],
        i = -1,
        item,
        attrs,
        n;
    if (typeof test != 'function') {
      attrs = test;
      test = function(index, item) {
        for (n in attrs) {
          if (item.get(n) != attrs[n]) {
            return false;
          }
        }
        return true;
      };
    }
    while (item = this.models[++i]) {
      if (test(i, item)) {
        result.push(item);
        if (--maxResults < 1) {
          break;
        }
      }
    }
    return result;
  },
  /**
   * @method first
   *
   * @sig
   * Finds the first item matching an attribute hash
   * @param {Object} attributes  The attributes to test against each model
   * @return {Lavaca.mvc.Model}  The first model that matched the attributes (or null)
   *
   * @sig
   * Finds the first item that passed a functional test
   * @param {Function} test  A function to check each model in the collection in the form
   *     test(index, model). If the test function returns true, the model will be included
   *     as the result
   * @return {Lavaca.mvc.Model}  The first model that passed the test (or null)
   */
  first: function(test) {
    return this.filter(test, 1)[0] || null;
  },
  /**
   * @method itemAt
   * Gets the item at a specific index
   *
   * @param {Number} index  The index of the item
   * @return {Lavaca.mvc.Model}  The model at that index
   */
  itemAt: function(index) {
    return this.models[index];
  },
  /**
   * @method count
   * Gets the number of items in the collection
   *
   * @return {Number}  The number of items in the collection
   */
  count: function() {
    return this.models.length;
  },
  /**
   * @method each
   * Executes a callback for each model in the collection
   *
   * @sig
   * @param {Function} callback  A function to execute for each item, callback(index, model)
   *
   * @sig
   * @param {Function} callback  A function to execute for each item, callback(index, model)
   * @param {Object} thisp  The context of the callback
   */
  each: function(cb, thisp) {
    var i = -1,
        item;
    while (item = this.itemAt(++i)) {
      cb.call(thisp || this, i, item);
    }
  },
  /**
   * @method onItemEvent
   * Handler invoked when an item in the collection has an event. Triggers an [[Lavaca.mvc.ItemEvent]].
   *
   * @param {Lavaca.mvc.ModelEvent} e  The item event
   */
  onItemEvent: function(e) {
    var model = e.target,
        index = ArrayUtils.indexOf(this.models, model);
    if (e.type == 'change') {
      ArrayUtils.pushIfNotExists(this.changedItems, model);
    } else if (e.type == 'saveSuccess') {
      ArrayUtils.remove(this.changedItems, model);
    }
    this.trigger(e.type + 'Item', Lavaca.merge({}, e, {
      target: model,
      model: model,
      index: index,
      previousIndex: null
    }));
  },
  /**
   * @method onFetchSuccess
   * Processes the data received from a fetch request
   *
   * @param {Object} response  The response data
   */
  onFetchSuccess: function(response) {
    response = this.parse(response);
    var list = response;
    if (!(list instanceof Array)) {
      this.apply(response);
      list = response[this.itemsProperty];
    }
    this.add.apply(this, list);
    this.trigger('fetchSuccess', {response: response});
  },
  /**
   * @method saveToServer
   * Saves the model to the server via POST
   *
   * @param {String} url  The URL to which to post the data
   * @return {Lavaca.util.Promise}  A promise
   */
  saveToServer: function(url) {
    return this.save(function(model, changedAttributes, attributes) {
      var id = this.id(),
          data;
      if (this.isNew()) {
        data = attributes;
      } else {
        changedAttributes[this.idAttribute] = id;
        data = changedAttributes;
      }
      return (new Promise(this)).when(Lavaca.net.Connectivity.ajax({
        url: url,
        cache: false,
        type: 'POST',
        data: data,
        dataType: 'json'
      }));
    });
  },
  /**
   * @method toObject
   * Converts this model to a key-value hash
   *
   * @param {Boolean} idOnly  When true, only include item IDs for pre-existing items
   * @return {Object}  The key-value hash
   */
  toObject: function(idOnly) {
    var obj = Model.prototype.toObject.apply(this, arguments),
        prop = this.itemsProperty,
        items = obj[prop] = [],
        i = -1,
        item;
    while (item = this.models[++i]) {
      items[obj[prop].length] = idOnly && !item.isNew() ? item.id() : item.toObject();
    }
    return obj;
  }
});

})(Lavaca.mvc, Lavaca.mvc.Model, Lavaca.util.Cache, Lavaca.util.Promise, Lavaca.util.ArrayUtils);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, Disposable) {

var UNDEFINED;

function _multivariablePattern() {
  return new RegExp('\\{\\*(.*?)\\}', 'g');
}

function _variablePattern() {
  return new RegExp('\\{([^\\/]*?)\\}', 'g');
}

function _variableCharacters() {
  return new RegExp('[\\{\\}\\*]', 'g');
}

function _datePattern() {
  return new RegExp('^\\d{4}-[0-1]\\d-[0-3]\\d$', 'g');
}

function _patternToRegExp(pattern) {
  if (pattern == '/') {
    return new RegExp('^\\/(\\?.*)?(#.*)?$', 'g');
  }
  if (pattern.charAt(0) == '/') {
    pattern = pattern.slice(1);
  }
  pattern = pattern.split('/');
  var exp = '^',
      i = -1,
      part;
  while (part = pattern[++i]) {
    if (_multivariablePattern().test(part)) {
      exp += '(/([^/?#]+))*?';
    } else if (_variablePattern().test(part)) {
      exp += '/([^/?#]+)';
    } else {
      exp += '/' + part;
    }
  }
  exp += '(\\?.*)?(#\.*)?$';
  return new RegExp(exp, 'g');
}

function _scrubURLValue(value) {
  value = decodeURIComponent(value);
  if (!isNaN(value)) {
    value = Number(value);
  } else if (value.toLowerCase() == 'true') {
    value = true;
  } else if (value.toLowerCase() == 'false') {
    value = false;
  } else if (_datePattern().test(value)) {
    value = value.split('-');
    value = new Date(Number(value[0]), Number(value[1]) - 1, Number(value[2]));
  }
  return value;
}

/**
 * @class Lavaca.mvc.Route
 * @super Lavaca.util.Disposable
 * A relationship between a URL pattern and a controller action
 *
 * @constructor
 * @param {String} pattern  The route URL pattern
 *   Route URL patterns should be in the form /path/{foo}/path/{*bar}.
 *   The path variables, along with query string parameters, will be passed
 *   to the controller action as a params object. In this case, when passed
 *   the URL /path/something/path/1/2/3?abc=def, the params object would be
 *   {foo: 'something', bar: [1, 2, 3], abc: 'def'}.
 * @param {Function} TController  The type of controller that performs the action
 *   (Should derive from [[Lavaca.mvc.Controller]])
 * @param {String} action  The name of the controller method to call
 * @param {Object} params  Key-value pairs that will be merged into the params
 *   object that is passed to the controller action
 */
ns.Route = Disposable.extend(function(pattern, TController, action, params) {
  Disposable.call(this);
  this.pattern = pattern;
  this.TController = TController;
  this.action = action;
  this.params = params || {};
}, {
  /**
   * @method matches
   * Tests if this route applies to a URL
   *
   * @param {String} url  The URL to test
   * @return {Boolean}  True when this route matches the URL
   */
  matches: function(url) {
    return _patternToRegExp(this.pattern).test(url);
  },
  /**
   * @method parse
   * Converts a URL into a params object according to this route's pattern
   *
   * @param {String} url  The URL to convert
   * @return {Object}  The params object
   */
  parse: function(url) {
    var result = Lavaca.clone(this.params),
        pattern = this.pattern.slice(1),
        urlParts = url.split('#'),
        i,
        query,
        path,
        pathItem,
        patternItem,
        buffer,
        name;
    result.url = url;
    result.route = this;
    urlParts = urlParts[1] ? urlParts[1].split('?') : urlParts[0].split('?');
    query = urlParts[1];
    if (query) {
      i = -1;
      query = query.split('&');
      while (pathItem = query[++i]) {
        pathItem = pathItem.split('=');
        name = decodeURIComponent(pathItem[0]);
        if (result[name] !== UNDEFINED) {
          if (!(result[name] instanceof Array)) {
            result[name] = [result[name]];
          }
          result[name].push(_scrubURLValue(pathItem[1]));
        } else {
          result[name] = _scrubURLValue(pathItem[1]);
        }
      }
    }
    i = 0;
    path = urlParts[0].replace(/(^(http(s?)\:\/\/[^\/]+)?\/?)|(\/$)/, '');
    var breakApartPattern = new RegExp(pattern.replace(_multivariablePattern(), '(.+)').replace(_variablePattern(), '([^/]+)')),
        brokenPath = breakApartPattern.exec(path),
        brokenPattern = breakApartPattern.exec(pattern);
    while (pathItem = brokenPath[++i]) {
      patternItem = brokenPattern[i];
      if (_multivariablePattern().test(patternItem)) {
        pathItem = pathItem.split('/');
      }
      result[patternItem.replace(_variableCharacters(), '')] = pathItem;
    }
    return result;
  },
  /**
   * @method exec
   * Executes this route's controller action
   *
   * @sig
   * @param {String} url  The URL that supplies parameters to this route
   * @param {Lavaca.mvc.Router} router  The router used by the application
   * @param {Lavaca.mvc.ViewManager}  viewManager The view manager used by the application
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig
   * @param {String} url  The URL that supplies parameters to this route
   * @param {Lavaca.mvc.Router} router  The router used by the application
   * @param {Lavaca.mvc.ViewManager}  viewManager The view manager used by the application
   * @param {Object} state  A history record object
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig
   * @param {String} url  The URL that supplies parameters to this route
   * @param {Lavaca.mvc.Router} router  The router used by the application
   * @param {Lavaca.mvc.ViewManager}  viewManager The view manager used by the application
   * @param {Object} state  A history record object
   * @param {Object} params  Additional parameters to pass to the controller action
   * @return {Lavaca.util.Promise}  A promise
   */
  exec: function(url, router, viewManager, state, params) {
    var controller = new this.TController(router, viewManager),
        urlParams = this.parse(url),
        promise = controller.exec(this.action, Lavaca.merge(urlParams, params), state);
    function dispose() {
      Lavaca.delay(controller.dispose, controller);
    }
    promise.then(dispose, dispose);
    return promise;
  }
});

})(Lavaca.resolve('Lavaca.mvc', true), Lavaca.util.Disposable);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, Disposable, Promise) {

var _hasNavigated = false;

/**
 * @class Lavaca.mvc.Router
 * @super Lavaca.util.Disposable
 * URL manager
 *
 * @constructor
 * @param {Lavaca.mvc.ViewManager} viewManager  The view manager
 */
ns.Router = Disposable.extend(function(viewManager) {
  Disposable.call(this);
  /**
   * @field {Array} routes
   * @default []
   * The [[Lavaca.mvc.Route]]s used by this router
   */
  this.routes = [];
  /**
   * @field {Lavaca.mvc.ViewManager} viewManager
   * @default null
   * The view manager used by this router
   */
  this.viewManager = viewManager;
  this.onpopstate = function(e) {
    if (this.hasNavigated) {
      this.exec(e.url, e);
    }
  };
  Lavaca.net.History.on('popstate', this.onpopstate, this);
}, {
  /**
   * @field {Boolean} locked
   * @default false
   * When true, the router is prevented from executing a route
   */
  locked: false,
  /**
   * @field {Boolean} hasNavigated
   * @default false
   * Whether or not this router has been used to navigate
   */
  hasNavigated: false,
  /**
   * @method add
   *
   * @sig Adds multiple routes
   * @param {Object} map  A hash in the form {pattern: [TController, action, params]}
   *   or {pattern: {controller: TController, action: action, params: params}
   * @return {Lavaca.mvc.Router}  The router (for chaining)
   *
   * @sig Adds a route
   * @param {String} pattern  The route URL pattern
   * @param {Function} TController  The type of controller to perform the action (should derive from [[Lavaca.mvc.Controller]])
   * @param {String} action  The name of the controller method to call
   * @return {Lavaca.mvc.Router}  The router (for chaining)
   *
   * @sig Adds a route
   * @param {String} pattern  The route URL pattern
   * @param {Function} TController  The type of controller to perform the action (should derive from [[Lavaca.mvc.Controller]])
   * @param {String} action  The name of the controller method to call
   * @param {Object} params  Key-value pairs that will be passed to the action
   * @return {Lavaca.mvc.Router}  The router (for chaining)
   */
  add: function(pattern, TController, action, params) {
    if (typeof pattern == 'object') {
      for (var p in pattern) {
        var args = pattern[p];
        if (args instanceof Array) {
          TController = args[0];
          action = args[1];
          params = args[2];
        } else {
          TController = args.controller;
          action = args.action;
          params = args.params;
        }
        this.add(p, TController, action, params);
      }
    } else {
      this.routes.push(new ns.Route(pattern, TController, action, params));
    }
    return this;
  },
  /**
   * @method exec
   * Executes the action for a given URL
   *
   * @sig
   * @param {String} url  The URL
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig
   * @param {String} url  The URL
   * @param {Object} state  A history record object
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig
   * @param {String} url  The URL
   * @param {Object} state  A history record object
   * @param {Object} params  Additional parameters to pass to the route
   * @return {Lavaca.util.Promise}  A promise
   */
  exec: function(url, state, params) {
    if (this.locked) {
      return (new Promise(this)).reject('locked');
    } else {
      this.locked = true;
    }
    if (!url) {
      url = '/';
    }
    if (url.indexOf('http') == 0) {
      url = url.replace(/^http(s?):\/\/.+?/, '');
    }
    var i = -1,
        route,
        promise = new Promise(this);
    promise.always(function() {
      this.unlock();
    });
    if (!this.hasNavigated) {
      promise.success(function() {
        this.hasNavigated = true;
      });
    }
    while (route = this.routes[++i]) {
      if (route.matches(url)) {
        return promise.when(route.exec(url, this, this.viewManager, state, params));
      }
    }
    return promise.reject(url, state);
  },
  /**
   * @method unlock
   * Unlocks the router so that it can be used again
   *
   * @return {Lavaca.mvc.Router}  This router (for chaining)
   */
  unlock: function() {
    this.locked = false;
    return this;
  },
  /**
   * @method dispose
   * Readies the router for garbage collection
   */
  dispose: function() {
    if (this.onpopstate) {
      Lavaca.net.History.off('popstate', this.onpopstate);
      this.onpopstate = null;
    }
    Disposable.prototype.dispose.apply(this, arguments);
  }
});

})(Lavaca.resolve('Lavaca.mvc', true), Lavaca.util.Disposable, Lavaca.util.Promise);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $, EventDispatcher, Promise) {

var UNDEFINED;

/**
 * @class Lavaca.mvc.View
 * @super Lavaca.events.EventDispatcher
 * Base view type
 *
 * @event rendersuccess
 * @event rendererror
 * @event enter
 * @event exit
 *
 * @constructor
 * @param {Object} model  The model used by the view
 * @param {Number} layer  The index of the layer on which the view sits
 *
 * @constructor
 * @param {Object} model  The model used by the view
 * @param {Number} layer  The index of the layer on which the view sits
 * @param {Object} eventMap  A dictionary of selectors and event types in the form
 *   {eventType: {delegate: 'xyz', callback: func}}
 * @param {Object} widgetMap  A dictionary of selectors and widget types in the form
 *   {selector: widgetType}
 */
ns.View = EventDispatcher.extend(function(model, layer, eventMap, widgetMap) {
  EventDispatcher.call(this);
  /**
   * @field {Object} model
   * @default null
   * The model used by the view
   */
  this.model = model || null;
  /**
   * @field {Number} layer
   * @default 0
   * The index of the layer on which the view sits
   */
  this.layer = layer || 0;
  /**
   * @field {Object} eventMap
   * @default {}
   * A dictionary of selectors and event types in the form
   *   {eventType: {delegate: 'xyz', callback: func}}
   */
  this.eventMap = eventMap || {};
  /**
   * @field {Object} widgetMap
   * @default {}
   * A dictionary of selectors and widget types in the form
   *   {selector: widgetType}
   */
  this.widgetMap = widgetMap || {};
  /**
   * @field {Lavaca.util.Cache} widgets
   * @default new Lavaca.util.Cache()
   * Interactive elements used by the view
   */
  this.widgets = new Lavaca.util.Cache();
  this
    .on('rendersuccess', this.onRenderSuccess)
    .on('rendererror', this.onRenderError);
}, {
  /**
   * @field {jQuery} el
   * @default null
   * The element associated with the view
   */
  el: null,
  /**
   * @field {jQuery} shell
   * @default null
   * The element containing the view
   */
  shell: null,
  /**
   * @field {String} template
   * @default null
   * The name of the template associated with the view
   */
  template: null,
  /**
   * @field {String} className
   * @default null
   * A class name added to the view container
   */
  className: null,
  /**
   * @method wrapper
   * Creates the view's wrapper element
   *
   * @return {jQuery}  The wrapper element
   */
  wrapper: function() {
    return $('<div class="view"></div>');
  },
  /**
   * @method interior
   * Creates the view's interior content wrapper element
   *
   * @return {jQuery} The interior content wrapper element
   */
  interior: function() {
    return $('<div class="view-interior"></div>');
  },
  /**
   * @method render
   * Renders the view using its template and model
   *
   * @event rendersuccess
   * @event rendererror
   *
   * @return {Lavaca.util.Promise}  A promise
   */
  render: function() {
    var self = this,
        promise = new Promise(this),
        template = Lavaca.ui.Template.get(this.template),
        model = this.model;
    if (model instanceof ns.Model) {
      model = model.toObject();
    }
    if (this.el) {
      this.el.detach();
    }
    this.shell = this.wrapper();
    this.el = this.interior();
    this.shell.append(this.el);
    this.shell.attr('data-layer-index', this.layer);
    if (this.className) {
      this.shell.addClass(this.className);
    }
    promise
      .success(function(html) {
        this.trigger('rendersuccess', {html: html});
      })
      .error(function(err) {
        this.trigger('rendererror', {err: err});
      });
    this.shell.addClass('tmpl-' + this.template.toLowerCase().replace(/\s/g, '-'));
    template
      .render(model)
      .success(promise.resolver())
      .error(promise.rejector());
    return promise;
  },
  /**
   * @method clearModelEvents
   * Unbinds events from the model
   */
  clearModelEvents: function() {
    var type,
        callback;
    if (this.eventMap
        && this.eventMap.model
        && this.model
        && this.model instanceof EventDispatcher) {
      for (type in this.eventMap.model) {
        callback = this.eventMap.model[type];
        if (typeof callback == 'object') {
          callback = callback.on;
        }
        this.model.off(type, callback, this);
      }
    }
  },
  /**
   * @method applyEvents
   * Binds events to the view
   */
  applyEvents: function() {
    var el = this.el,
        callbacks,
        callback,
        delegate,
        type,
        opts;
    for (delegate in this.eventMap) {
      callbacks = this.eventMap[delegate];
      for (type in callbacks) {
        callback = callbacks[type];
        if (typeof callback == 'object') {
          opts = callback;
          callback = callback.on;
        } else {
          opts = UNDEFINED;
        }
        if (delegate == 'model') {
          if (this.model && this.model instanceof EventDispatcher) {
            this.model.on(type, callback, this);
          }
        } else if (type == 'tap' && el.tap) {
          el.tap(delegate, callback);
        } else if (type == 'taphold' && el.taphold) {
          el.taphold(delegate, callback, opts ? opts.duration : UNDEFINED);
        } else if (type == 'swipe' && el.swipe) {
          el.swipe(delegate, callback, opts);
        } else if (type == 'animationEnd' && el.animationEnd) {
          el.animationEnd(delegate, callback)
        } else if (type == 'transitionEnd' && el.transitionEnd) {
          el.transitionEnd(delegate, callback)
        } else {
          el.on(type, delegate, callback);
        }
      }
    }
  },
  /**
   * @method mapEvent
   *
   * @sig
   * Maps multiple delegated events for the view
   * @param {Object} map  A hash of the delegates, event types, and handlers
   *     that will be bound when the view is rendered. The map should be in
   *     the form <code>{delegate: {eventType: callback}}</code>. For example,
   *     <code>{'.button': {click: onClickButton}}</code>. The events defined in
   *     [[Lavaca.events.Touch]], [[Lavaca.fx.Animation]], and [[Lavaca.fx.Transition]]
   *     are also supported. To pass in options to a Lavaca event, use a wrapper object:
   *     <code>{'.taphold-me': {taphold: {on: onTapHoldButton, duration: 1000}}}</code>
   *     or <code>{'.swipe-me': {swipe: {on: onSwipeButton, direction: 'vertical'}}}</code>
   * @return {Lavaca.mvc.View}  This view (for chaining)
   *
   * @sig
   * Maps an event for the view
   * @param {String} delegate  The element to which to delegate the event
   * @param {String} type  The type of event
   * @param {Function} callback  The event handler
   * @return {Lavaca.mvc.View}  This view (for chaining)
   */
  mapEvent: function(delegate, type, callback) {
    var o;
    if (typeof delegate == 'object') {
      o = delegate;
      for (delegate in o) {
        for (type in o[delegate]) {
          this.mapEvent(delegate, type, o[delegate][type]);
        }
      }
    } else {
      o = this.eventMap[delegate];
      if (!o) {
        o = this.eventMap[delegate] = {};
      }
      o[type] = callback;
    }
    return this;
  },
  /**
   * @method createWidgets
   * Initializes widgets on the view
   */
  createWidgets: function() {
    var cache = this.widgets,
        widget,
        n,
        o;
    for (n in this.widgetMap) {
      o = this.widgetMap[n];
      (n == 'self' ? this.el : this.el.find(n))
        .each(function(index, item) {
          widget = new o($(item));
          cache.set(widget.id, widget);
        });
    }
  },
  /**
   * @method mapWidget
   *
   * @sig
   * Assigns multiple widget types to elements on the view
   * @param {Object} map  A hash of selectors to widget types to be bound when the view is rendered.
   *     The map should be in the form {selector: TWidget}. For example, {'form': Lavaca.ui.Form}
   * @return {Lavaca.mvc.View}  This view (for chaining)
   *
   * @sig
   * Assigns a widget type to be created for elements matching a selector when the view is rendered
   * @param {String} selector  The selector for the root element of the widget
   * @param {Function} TWidget  The [[Lavaca.ui.Widget]]-derived type of widget to create
   * @return {Lavaca.mvc.View}  This view (for chaining)
   */
  mapWidget: function(selector, TWidget) {
    if (typeof selector == 'object') {
      var widgetTypes = selector;
      for (selector in widgetTypes) {
        this.mapWidget(selector, widgetTypes[selector]);
      }
    } else {
      this.widgetMap[selector] = TWidget;
    }
    return this;
  },
  /**
   * @method insertInto
   * Adds this view to a container
   *
   * @param {jQuery} container  The containing element
   */
  insertInto: function(container) {
    if (!this.shell.parent()[0] != container[0]) {
      var layers = container.children('[data-layer-index]'),
          i = -1,
          layer,
          insertionPoint;
      while (layer = layers[++i]) {
        layer = $(layer);
        if (layer.attr('data-layer-index') > this.index) {
          this.shell.insertBefore(layer);
          return;
        }
      }
      container.append(this.shell);
    }
  },
  /**
   * @method enter
   * Executes when the user navigates to this view
   *
   * @param {jQuery} container  The parent element of all views
   * @param {Array} exitingViews  The views that are exiting as this one enters
   * @return {Lavaca.util.Promise}  A promise
   */
  enter: function(container, exitingViews) {
    var promise = new Promise(this),
        renderPromise;
    container = $(container);
    if (!this.hasRendered) {
      renderPromise = this
        .render()
        .error(promise.rejector());
    }
    this.insertInto(container);
    if (renderPromise) {
      promise.when(renderPromise);
    } else {
      Lavaca.delay(promise.resolver());
    }
    promise.then(function() {
      this.trigger('enter');
    });
    return promise;
  },
  /**
   * @method exit
   * Executes when the user navigates away from this view
   *
   * @param {jQuery} container  The parent element of all views
   * @param {Array} enteringViews  The views that are entering as this one exits
   * @return {Lavaca.util.Promise}  A promise
   */
  exit: function(container, enteringViews) {
    var promise = new Promise(this);
    this.shell.detach();
    Lavaca.delay(promise.resolver());
    promise.then(function() {
      this.trigger('exit');
    });
    return promise;
  },
  /**
   * @method onRenderSuccess
   * Executes when the template renders successfully
   *
   * @param {Event} e  The render event. This object should have a string property named "html"
   *   that contains the template's rendered HTML output.
   */
  onRenderSuccess: function(e) {
    this.el.html(e.html);
    this.applyEvents(this.el);
    this.createWidgets(this.el);
    this.hasRendered = true;
  },
  /**
   * @method onRenderError
   * Executes when the template fails to render
   *
   * @param {Event} e  The error event. This object should have a string property named "err"
   *   that contains the error message.
   */
  onRenderError: function(e) {
    Lavaca.log(e.err);
  },
  /**
   * @method dispose
   * Readies the view for garbage collection
   */
  dispose: function() {
    if (this.model) {
      this.clearModelEvents();
    }
    // Do not dispose of template or model
    this.template
      = this.model
      = null;
    EventDispatcher.prototype.dispose.apply(this, arguments);
  }
});

})(Lavaca.resolve('Lavaca.mvc', true), Lavaca.$, Lavaca.events.EventDispatcher, Lavaca.util.Promise);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, util, $, Promise, Disposable, ArrayUtils) {

/**
 * @class Lavaca.mvc.ViewManager
 * @super Lavaca.util.Disposable
 * Manager responsible for drawing views
 *
 * @constructor
 *
 * @constructor
 * @param {jQuery} el  The element that contains all layers
 */
ns.ViewManager = Disposable.extend(function(el) {
  Disposable.call(this);
  /**
   * @field {jQuery} el
   * @default null
   * The element that contains all view layers
   */
  this.el = $(el || document.body);
  /**
   * @field {Lavaca.util.Cache} views
   * @default new Lavaca.util.Cache()
   * A cache containing all views
   */
  this.views = new util.Cache();
  /**
   * @field {Array} layers
   * @default []
   * A list containing all layers
   */
  this.layers = [];
  /**
   * @field {Array} exitingViews
   * @default []
   * A list containing all views that are currently exiting
   */
  this.exitingViews = [];
  /**
   * @field {Array} enteringViews
   * @default []
   * A list containing all views that are currently entering
   */
  this.enteringViews = [];
}, {
  /**
   * @field {Boolean} locked
   * @default false
   * When true, the view manager is prevented from loading views.
   */
  locked: false,
  /**
   * @method load
   * Loads a view
   *
   * @param {String} cacheKey  The cache key associated with the view
   * @param {Function} TView  The type of view to load (should derive from [[Lavaca.mvc.View]])
   * @param {Array} args  Initialization arguments for the view
   * @param {Number} layer  The index of the layer on which the view will sit
   * @return {Lavaca.util.Promise}  A promise
   */
  load: function(cacheKey, TView, model, layer) {
    if (this.locked) {
      return (new Promise(this)).reject('locked');
    } else {
      this.locked = true;
    }
    layer = layer || 0;
    var self = this,
        view = this.views.get(cacheKey),
        promise = new Promise(this),
        enterPromise = new Promise(promise),
        renderPromise = null,
        exitPromise = null;
    promise.always(function() {
      this.locked = false;
    });
    if (!view) {
      view = new TView(model, layer);
      renderPromise = view.render();
      if (cacheKey !== null) {
        this.views.set(cacheKey, view);
        view.cacheKey = cacheKey;
      }
    }
    function lastly() {
      self.enteringViews = [view];
      promise.success(function() {
        Lavaca.delay(function() {
          self.enteringViews = [];
        });
      });
      exitPromise = self.dismissLayersAbove(layer - 1, view);
      if (self.layers[layer] != view) {
        enterPromise
          .when(view.enter(self.el, self.exitingViews), exitPromise)
          .then(promise.resolve);
        self.layers[layer] = view;
      } else {
        promise.when(exitPromise);
      }
    }
    if (renderPromise) {
      renderPromise.then(lastly, promise.rejector());
    } else {
      lastly();
    }
    return promise;
  },
  /**
   * @method dismiss
   * Removes all views on a layer
   *
   * @sig
   * @param {Number} index  The index of the layer to remove
   *
   * @sig
   * @param {jQuery} el  An element on the layer to remove (or the layer itself)
   *
   * @sig
   * @param {Lavaca.mvc.View} view  The view on the layer to remove
   */
  dismiss: function(layer) {
    if (typeof layer == 'number') {
      this.dismissLayersAbove(layer - 1);
    } else if (layer instanceof Lavaca.mvc.View) {
      this.dismiss(layer.layer);
    } else {
      layer = $(layer);
      var index = layer.attr('data-layer-index');
      if (index === null) {
        layer = layer.closest('[data-layer-index]');
        index = layer.attr('data-layer-index');
      }
      if (index !== null) {
        this.dismiss(Number(index));
      }
    }
  },
  /**
   * @method dismissLayersAbove
   *
   * Removes all layers above a given index
   *
   * @sig
   * @param {Number}  index The index above which to clear
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig
   * @param {Number} index  The index above which to clear
   * @param {Lavaca.mvc.View}  exceptForView A view that should not be dismissed
   * @return {Lavaca.util.Promise}  A promise
   */
  dismissLayersAbove: function(index, exceptForView) {
    var promise = new Promise(this),
        dismissedLayers = false,
        i,
        layer;
    for (i = this.layers.length - 1; i > index; i--) {
      if ((layer = this.layers[i]) && (!exceptForView || exceptForView != layer)) {
        (function(layer) {
          this.exitingViews.push(layer);
          promise
            .when(layer.exit(this.el, this.enteringViews))
            .success(function() {
              Lavaca.delay(function() {
                ArrayUtils.remove(this.exitingViews, layer);
                if (!layer.cacheKey || (exceptForView && exceptForView.cacheKey == layer.cacheKey)) {
                  layer.dispose();
                }
              }, this);
            });
          this.layers[i] = null;
        }).call(this, layer);
        dismissedLayers = true;
      }
    }
    if (!dismissedLayers) {
      promise.resolve();
    }
    return promise;
  },
  /**
   * @method flush
   * Empties the view cache
   */
  flush: function() {
    // Don't dispose of any views that are currently displayed
    var i = -1,
        layer;
    while (layer = this.layers[++i]) {
      if (layer.cacheKey) {
        this.views.remove(layer.cacheKey);
      }
    }
    this.views.dispose();
    this.views = new util.Cache();
  },
  /**
   * @method dispose
   * Readies the view manager for garbage collection
   */
  dispose: function() {
    Disposable.prototype.dispose.call(this);
  }
});

})(Lavaca.resolve('Lavaca.mvc', true), Lavaca.util, Lavaca.$, Lavaca.util.Promise, Lavaca.util.Disposable, Lavaca.util.ArrayUtils);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, EventDispatcher, $) {

function _stopEvent(e) {
  e.preventDefault();
  e.stopPropagation();
}

/**
 * @class Lavaca.mvc.Application
 * @super Lavaca.events.EventDispatcher
 * Base application type
 *
 * @constructor
 * Creates an application
 *
 * @sig
 *
 * @sig
 * @param {Function} callback  A callback to execute when the application is initialized but not yet ready
 */
ns.Application = EventDispatcher.extend(function(callback) {
  Lavaca.env.Device.init($.proxy(this.init, this));
  $(window).on('unload', $.proxy(this.dispose, this));
  if (callback) {
    this.on('init', callback);
  }
}, {
  /**
   * @field {Function} TViewManager
   * @default Lavaca.mvc.ViewManager
   * The type of the view manager used by the application
   */
  TViewManager: Lavaca.mvc.ViewManager,
  /**
   * @field {Function} TRouter
   * @default Lavaca.mvc.Router
   * The type of the router used by the application
   */
  TRouter: Lavaca.mvc.Router,
  /**
   * @field {Function} TState
   * @default Lavaca.mvc.Model
   * The type of the state model used by the application
   */
  TState: Lavaca.mvc.Model,
  /**
   * @field {Boolean} animations
   * @default true
   * Flag indicating whether animations are turned on or off. On Android devices, this defaults to <code>false</code>.
   */
  animations: navigator.userAgent.indexOf('Android') == -1,
  /**
   * @field {String} initRoute
   * @default "/"
   * The default URL that the app will navigate to
   */
  initRoute: '/',
  /**
   * @field {Object} initState
   * @default null
   * The default state object to supply the initial route
   */
  initState: null,
  /**
   * @field {Object} initParams
   * @default null
   * The default params object to supply the initial route
   */
  initParams: null,
  /**
   * @field {String} initLocale
   * @default "en_US"
   * The default locale to use
   */
  initLocale: 'en_US',
  /**
   * @field {String} viewRootSelector
   * @default "#view-root"
   * The selector used to identify the DOM element that will contain views
   */
  viewRootSelector: '#view-root',
  /**
   * @method onInvalidRoute
   * Handler for when the user attempts to navigate to an invalid route
   * @param {Object} err  The routing error
   */
  onInvalidRoute: function(err) {
    // If the error is equal to "locked", it means that the router or view manager was
    // busy while while the user was attempting to navigate
    if (err != 'locked') {
      plugins.notification.alert('An error occurred while trying to display this URL.');
    }
  },
  /**
   * @method onTapLink
   * Handler for when the user taps on a <A> element
   * @param {Event} e  The event object
   */
  onTapLink: function(e) {
    var link = $(e.currentTarget),
        url = link.attr('href'),
        rel = link.attr('rel'),
        target = link.attr('target');
    if (/^((mailto)|(tel)|(sms))\:/.test(url)) {
      location.href = url;
      return true;
    } else {
      e.preventDefault();
    }
    if (rel == 'back') {
      Lavaca.net.History.back();
    } else if (rel == 'nofollow' || target == '_blank') {
      e.stopPropagation();
      plugins.childBrowser.showWebPage(url);
    } else if (rel == 'cancel') {
      this.viewManager.dismiss(e.currentTarget);
    } else if (url) {
      this.router.exec(url, null, link.dataAttrs()).error(this.onInvalidRoute);
    }
  },
  /**
   * @method ajax
   * Makes an AJAX request if the user is online. If the user is offline, the returned
   * promise will be rejected with the string argument "offline". (Alias for [[Lavaca.net.Connectivity]].ajax)
   *
   * @param {Object} opts  jQuery-style AJAX options
   * @return {Lavaca.util.Promise}  A promise
   */
  ajax: function() {
    return Lavaca.net.Connectivity.ajax.apply(Lavaca.net.Connectivity, arguments);
  },
  /**
   * @method init
   * @event init
   * @event ready
   * Initializes the application
   *
   * @return {Lavaca.util.Promise}  A promise that resolves when the application is ready for use
   */
  init: function() {
    var promise = new Lavaca.util.Promise(this);
    /** 
     * @field {Lavaca.mvc.Model} state
     * @default null
     * Model used for application state management
     */
    this.state = new this.TState();
    Lavaca.util.Config.init();
    this.state.set('lang', localStorage.getItem('app:lang') || this.initLocale);
    Lavaca.util.Translation.init(app.state.get('lang'));
    Lavaca.ui.Template.init();
    /**
     * @field {Lavaca.mvc.ViewManager} viewManager
     * @default null
     * View manager used to transition between UI states
     */
    this.viewManager = new this.TViewManager(this.viewRootSelector);
    /**
     * @field {Lavaca.mvc.Router} router
     * @default null
     * Router used to manage application traffic and URLs
     */
    this.router = new this.TRouter(this.viewManager);
    $(document.body)
      .tap('a', this.onTapLink, this)
      .tap('.ui-blocker', _stopEvent);
    this.trigger('init');
    if (!this.router.hasNavigated) {
      promise.when(this.router.exec(this.initRoute, this.initState, this.initParams));
      if (this.initState) {
        Lavaca.net.History.replace(this.initState.state, this.initState.title, this.initState.url); 
      }
    } else {
      promise.resolve();
    }
    return promise.then(function() {
      this.trigger('ready');
    });
  },
  /**
   * @method dispose
   * @event dispose
   * Readies the application to be garbage collected
   */
  dispose: function() {
    this.trigger('dispose');
    Lavaca.util.Config.dispose();
    Lavaca.util.Translation.dispose();
    Lavaca.ui.Template.dispose();
    EventDispatcher.prototype.dispose.call(this);
  }
});

})(Lavaca.mvc, Lavaca.events.EventDispatcher, Lavaca.$);
(function(ns, Disposable) {

function _notImplemented() {
  throw 'Not implemented';
}

/**
 * @class Lavaca.storage.Store
 * @super Lavaca.util.Disposable
 * An object for manage local storage
 */
ns.Store = Disposable.extend(function(id) {
  /**
   * @field {String} id
   * The ID of the store
   */
  this.id = id;
}, {
  /**
   * @method get
   * Retrieves an object from storage, given its ID
   * @param {String} id  The ID of the stored object
   * @return {Object}  The stored object
   */
  get: function(id) {
    _notImplemented();
  },
  /**
   * @method set
   * Stores an object locally
   * @param {String} id  The ID of the object to store
   * @param {Object} value  The value to store
   */
  set: function(id, value) {
    _notImplemented();
  },
  /**
   * @method remove
   * Removes an object from storage
   * @param {String} id  The ID of the object to remove from storage
   */
  remove: function(id) {
    _notImplemented();
  },
  /**
   * @method all
   * Retrieves all items in this store
   * @return {Array}  A list of stored objects
   */
  all: function() {
    _notImplemented();
  }
});

})(Lavaca.resolve('Lavaca.storage', true), Lavaca.util.Disposable);
(function(ns, StringUtils, ArrayUtils) {

function _saveManifest(store) {
  localStorage.setItem(store.id + '@manifest', JSON.stringify(store.manifest));
}

/**
 * @class Lavaca.storage.LocalStore
 * @super Lavaca.storage.Store
 * An object for manage local storage
 */
ns.LocalStore = ns.Store.extend(function(id) {
  ns.Store.call(this, id);
  /** 
   * @field {Array} manifest
   * A list of keys found in the store
   */
  this.manifest = JSON.parse(localStorage.getItem(this.id + '@manifest') || '[]');
}, {
  /**
   * @method key
   * Generates a storage key
   * @param {String} id  The ID of the item for which to generate a key
   * @return {String}  The key
   */
  key: function(id) {
    return this.id + ':' + id;
  },
  /**
   * @method get
   * Retrieves an object from storage, given its ID
   * @param {String} id  The ID of the stored object
   * @return {Object}  The stored object
   */
  get: function(id) {
    var obj = localStorage.getItem(this.key(id));
    if (obj) {
      return JSON.parse(StringUtils.decompress(obj));
    } else {
      return null;
    }
  },
  /**
   * @method set
   * Stores an object locally
   * @param {String} id  The ID of the object to store
   * @param {Object} value  The value to store
   */
  set: function(id, value) {
    localStorage.setItem(this.key(id), StringUtils.compress(JSON.stringify(value)));
    ArrayUtils.pushIfNotExists(this.manifest, id);
    _saveManifest(this);
  },
  /**
   * @method remove
   * Removes an object from storage
   * @param {String} id  The ID of the object to remove from storage
   */
  remove: function(id) {
    localStorage.removeItem(this.key(id));
    ArrayUtils.remove(this.manifest, id);
    _saveManifest(this);
  },
  /**
   * @method all
   * Retrieves all items in this store
   * @return {Array}  A list of stored objects
   */
  all: function() {
    var result = [],
        i = -1,
        id;
    while (id = this.manifest[++i]) {
      result.push(this.get(id));
    }
    return result;
  }
});

})(Lavaca.resolve('Lavaca.storage'), Lavaca.util.StringUtils, Lavaca.util.ArrayUtils);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $) {

/**
 * @class Lavaca.net.Connectivity
 * A utility type for working under different network connectivity situations.
 */

var _navigatorOnlineSupported = typeof navigator.onLine == 'boolean',
    _offlineAjaxHandlers = [],
    _offlineErrorCode = 'offline',
    _isAndroid = navigator.userAgent.indexOf('Android') > -1;

function _onAjaxError(arg) {
  if (arg == _offlineErrorCode) {
    var i = -1,
        callback;
    while (callback = _offlineAjaxHandlers[++i]) {
      callback(arg);
    }
  }
}

/**
 * @method isOffline
 * @static
 * Attempts to detect whether or not the browser is connected
 *
 * @return {Boolean}  True if the browser is offline; false if the browser is online
 *    or if connection status cannot be determined
 */
ns.isOffline = function() {
  var connectionType = Lavaca.resolve('navigator.network.connection.type');
  if (connectionType !== null) {
    return connectionType == Lavaca.resolve('Connection.NONE');
  } else {
    return _navigatorOnlineSupported ? !navigator.onLine : false;
  }
};

/**
 * @method ajax
 * @static
 * Makes an AJAX request if the user is online. If the user is offline, the returned
 * promise will be rejected with the string argument "offline"
 *
 * @param {Object} opts  jQuery-style AJAX options
 * @return {Lavaca.util.Promise}  A promise
 */
ns.ajax = function(opts) {
  var promise = new Lavaca.util.Promise(),
      origSuccess = opts.success,
      origError = opts.error;
  opts.success = function() {
    if (origSuccess) {
      origSuccess.apply(this, arguments);
    }
    promise.resolve.apply(promise, arguments);
  };
  opts.error = function() {
    if (origError) {
      origError.apply(this, arguments);
    }
    promise.reject.apply(promise, arguments);
  };
  if (ns.isOffline()) {
    promise.reject(_offlineErrorCode);
  } else {
    $.ajax(opts);
  }
  promise.error(_onAjaxError);
  return promise;
};

/**
 * @method registerOfflineAjaxHandler
 * @static
 * Adds a callback to be executed whenever any Lavaca.net.Connectivity.ajax() call is
 * blocked as a result of a lack of internet connection.
 *
 * @param {Function} callback  The callback to execute
 */
ns.registerOfflineAjaxHandler = function(callback) {
  _offlineAjaxHandlers.push(callback);
};

})(Lavaca.resolve('Lavaca.net.Connectivity', true), Lavaca.$);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, EventDispatcher, history) {

var _isAndroid = navigator.userAgent.indexOf('Android') > -1,
    _standardsMode = !_isAndroid && typeof history.pushState == 'function',
    _hasPushed = false,
    _lastHash,
    _hist,
    _pushCount = 0;

function _insertState(hist, position, id, state, title, url) {
  hist.position = position;
  var record = {
        id: id,
        state: state,
        title: title,
        url: url
      };
  hist.sequence[position] = record;
  location.hash = _lastHash = url + '#@' + id;
  return record;
}

/**
 * @class Lavaca.net.History
 * @super Lavaca.events.EventDispatcher
 * HTML5 history abstraction layer
 *
 * @event popstate
 *
 * @constructor
 */
ns.History = EventDispatcher.extend(function() {
  EventDispatcher.call(this);
  /**
   * @field {Array} sequence
   * A list containing history states generated by the app (not used for HTML5 history)
   */
  this.sequence = [];
  /**
   * @field {Number} position
   * The current index in the history sequence (not used for HTML5 history)
   */
  this.position = -1;
  this.replace({}, document.title, location.pathname);
  var self = this;
  if (_standardsMode) {
    /**
     * @field {Function} onPopState
     * Auto-generated callback executed when a history event occurs
     */
    this.onPopState = function(e) {
      if (e.state) {
        _pushCount--;
        self.trigger('popstate', {
          state: e.state.state,
          title: e.state.title,
          url: e.state.url
        });
      }
    };
    window.addEventListener('popstate', this.onPopState, false);
  } else {
    this.onPopState = function() {
      var hash = location.hash,
          code,
          index,
          record,
          item,
          i = -1;
      if (hash) {
        hash = hash.replace(/^#/, '');
      }
      if (hash != _lastHash) {
        _lastHash = hash;
        if (hash) {
          _pushCount--;
          code = hash.split('#@')[1];
          while (item = self.sequence[++i]) {
            if (item.id == code) {
              record = item;
              this.position = i;
              break;
            }
          }
          if (record) {
            location.hash = record.url + '#@' + record.id;
            document.title = record.title;
            self.trigger('popstate', {
              state: record.state,
              title: record.title,
              url: record.url
            });
          }
        }
      }
    };
    if (window.attachEvent) {
      window.attachEvent('onhashchange', this.onPopState);
    } else {
      window.addEventListener('hashchange', this.onPopState, false);
    }
  }
}, {
  /**
   * @method current
   * Retrieve the current history record
   *
   * @return {Object}  The current history record
   */
  current: function() {
    return this.sequence[this.position] || null;
  },
  /**
   * @method hasHistory
   * Determines whether or not there are history states
   *  
   * @returns {Boolean} True when there is a history state
   */
  hasHistory: function() {
    return _pushCount > 0;
  },
  /**
   * @method push
   * Adds a record to the history
   *
   * @param {Object} state  A data object associated with the page state
   * @param {String} title  The title of the page state
   * @param {String} url  The URL of the page state
   */
  push: function(state, title, url) {
    _pushCount++;
    if (_hasPushed) {
      document.title = title;
      if (_standardsMode) {
        history.pushState({state: state, title: title, url: url}, title, url);
      } else {
        _insertState(this, ++this.position, Lavaca.uuid(), state, title, url);
      }
    } else {
      this.replace(state, title, url);
    }
  },
  /**
   * @method replace
   * Replaces the current record in the history
   *
   * @param {Object} state  A data object associated with the page state
   * @param {String} title  The title of the page state
   * @param {String} url  The URL of the page state
   */
  replace: function(state, title, url) {
    _hasPushed = true;
    document.title = title;
    if (_standardsMode) {
      history.replaceState({state: state, title: title, url: url}, title, url);
    } else {
      if (this.position < 0) {
        this.position = 0;
      }
      var currentRecord = this.current() || {id: Lavaca.uuid()};
      _insertState(this, this.position, currentRecord.id, state, title, url);
    }
  },
  /**
   * @method dispose
   * Unbind the history object and ready it for garbage collection
   */
  dispose: function() {
    if (this.onPopState) {
      if (_standardsMode) {
        window.removeEventListener('popstate', this.onPopState, false);
      } else if (window.detachEvent) {
        window.detachEvent('onhashchange', this.onPopState);
      } else {
        window.removeEventListener('hashchange', this.onPopState, false);
      }
    }
    EventDispatcher.prototype.dispose.call(this);
  }
});
/**
 * @method init
 * @static
 * Initialize a singleton history abstraction layer
 *
 * @sig
 * @return {Lavaca.mvc.History}  The history instance
 *
 * @sig
 * @param {Boolean} useHash  When true, use the location hash to manage history state instead of HTML5 history
 * @return {Lavaca.mvc.History}  The history instance
 */
ns.History.init = function(useHash) {
  if (!_hist) {
    if (useHash) {
      ns.History.overrideStandardsMode();
    }
    _hist = new ns.History();
  }
  return _hist;
};
/**
 * @method push
 * @static
 * Adds a record to the history
 *
 * @param {Object} state  A data object associated with the page state
 * @param {String} title  The title of the page state
 * @param {String} url  The URL of the page state
 */
ns.History.push = function() {
  ns.History.init().push.apply(_hist, arguments);
};
/**
 * @method replace
 * @static
 * Replaces the current record in the history
 *
 * @param {Object} state  A data object associated with the page state
 * @param {String} title  The title of the page state
 * @param {String} url  The URL of the page state
 */
ns.History.replace = function() {
  ns.History.init().replace.apply(_hist, arguments);
};
/**
 * @method back
 * @static
 * Goes to the previous history state
 */
ns.History.back = function() {
  history.back();
};
/**
 * @method forward
 * @static
 * Goes to the next history state
 */
ns.History.forward = function() {
  history.forward();
};
/**
 * @method dispose
 * @static
 * Unbind the history object and ready it for garbage collection
 */
ns.History.dispose = function() {
  if (_history) {
    _hist.dispose();
    _hist = null;
  }
};
/**
 * @method on
 * @static
 * Binds an event handler to the singleton history
 *
 * @param {String} type  The type of event
 * @param {Function} callback  The function to execute when the event occurs
 * @return {Lavaca.mvc.History}  The history object (for chaining)
 */
ns.History.on = function() {
  return ns.History.init().on.apply(_hist, arguments);
};
/**
 * @method off
 * @static
 * Unbinds an event handler from the singleton history
 *
 * @param {String} type  The type of event
 * @param {Function} callback  The function to stop executing when the
 *    event occurs
 * @return {Lavaca.mvc.History}  The history object (for chaining)
 */
ns.History.off = function() {
  return ns.History.init().off.apply(_hist, arguments);
};
/**
 * @method overrideStandardsMode
 * @static
 * Sets Histroy to hash mode
 */
ns.History.overrideStandardsMode = function() {
  _standardsMode = false;
};

})(Lavaca.resolve('Lavaca.net', true), Lavaca.events.EventDispatcher, window.history);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $, Map) {

var _cache = new Lavaca.util.Cache(),
    _types = [];

function _construct(name, src, code) {
  return new ns.Template(name, src, code);
}

/**
 * @class Lavaca.ui.Template
 * @super Lavaca.util.Map
 * Abstract type for templates
 */
ns.Template = Map.extend({
  /**
   * @method compile
   * Compiles the template
   */
  compile: function() {
    // Do nothing
  },
  /**
   * @method render
   * Renders the template to a string
   *
   * @param {Object} model  The data model to provide to the template
   * @return {Lavaca.util.Promise}  A promise
   */
  render: function(model) {
    throw 'Abstract';
  },
  /**
   * @method process
   * Parses server data to include in this lookup
   *
   * @param {String} text  The server data string
   */
  process: function(text) {
    this.code = text;
  }
});
/**
 * @method get
 * @static
 * Finds the template with a given name
 *
 * @param {String} name  The name of the template
 * @return {Lavaca.ui.Template}  The template (or null if no such template exists)
 */
ns.Template.get = function(name) {
  return _cache.get(name);
};
/**
 * @method init
 * @static
 * Scans the document for all templates with registered types and
 *   prepares template objects from them
 *
 * @sig
 *
 * @sig
 * @param {jQuery} scope  The element to which to limit the scan
 */
ns.Template.init = function(scope) {
  var i = -1,
      type;
  while (type = _types[++i]) {
    function construct(name, src, code) {
      return new type.js(name, src, code);
    }
    Map.init(_cache, type.mime, construct, scope);
  }
};
/**
 * @method dispose
 * @static
 * Disposes of all templates
 */
ns.Template.dispose = function() {
  Map.dispose(_cache);
};
/**
 * @method render
 * @static
 * Finds the named template and renders it to a string
 *
 * @param {String} name  The name of the template
 * @param {Object} model  The data model to provide to the template
 * @return {Lavaca.util.Promise}  A promise
 */
ns.Template.render = function(name, model) {
  var template = ns.Template.get(name);
  if (!template) {
    throw 'No template named "' + name + '"';
  } else {
    return template.render(model);
  }
};
/**
 * @method register
 * @static
 * Registers a type of template to look for on intilization
 *
 * @param {String} mimeType  The mime-type associated with the template
 * @param {Function} TTemplate  The JavaScript type used for the template (should derive from [[Lavaca.ui.Template]])
 */
ns.Template.register = function(mimeType, TTemplate) {
  _types[_types.length] = {mime: mimeType, js: TTemplate};
};

})(Lavaca.resolve('Lavaca.ui', true), Lavaca.$, Lavaca.util.Map);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, xdust, Template, Translation) {

/**
 * @class Lavaca.ui.DustTemplate
 * @super Lavaca.ui.Template
 * Base type for templates that use the x-dust engine
 *
 * @constructor
 * @param {String} name  The unique name of the template
 * @param {String} src  A URL from which to load the template
 * @param {String} code  The raw string code of the template's body
 */
ns.DustTemplate = Template.extend(function(name, src, code) {
  Template.apply(this, arguments);
  var helper = this.prepareHelper(),
      n;
  for (n in helper) {
    xdust.helpers[n] = helper[n];
  }
}, {
  /**
   * @method prepareHelper
   * Gets the basis for the template helper object
   *
   * @return {Object}  A map of helper function names to functions
   */
  prepareHelper: function() {
    return {
      msg: this.helperMsg,
      include: this.helperInclude
    };
  },
  /**
   * @method helperMsg
   * Helper function, exposed in dust templates, that uses
   *   [[Lavaca.util.Translation]] to get localized strings. Accessed as:
   *
   * <dl>
   *
   * <dt>{#msg}code{/msg}</dt>
   *   <dd>code&mdash;The key under which the message is stored</dd>
   *
   * <dt>{#msg}code{:or}default{/msg}</dt>
   *   <dd>code&mdash;The key under which the message is stored</dd>
   *   <dd>default&mdash;Text to use if no message exists</dd>
   *
   * <dt>{#msg locale="en_US"}code{/msg}</dt>
   *   <dd>locale&mdash;The locale from which to get the message ("en_US")</dd>
   *   <dd>code&mdash;The key under which the message is stored</dd>
   *
   * <dt>{#msg p0="first" p1=variable}code{/msg}</dt>
   *   <dd>p0, p1, &hellip; pN&mdash;String format parameters for the message
   *       (See [[Lavaca.util.StringUtils]].format()</dd>
   *   <dd>code&mdash;The key under which the message is stored</dd>
   *
   * </dl>
   *
   * @param {RenderChain} chain  Dust render chain
   * @param {Context} context  Dust context
   * @param {Object} model  Model object passed to template
   * @return {String}  Rendered output
   */
  helperMsg: function(chain, context, model) {
    var node = chain.tail,
        code = node.renderBody('block', chain, context, model),
        locale = node.params[locale],
        args = [Translation.get(code, locale) || ''],
        i = -1,
        arg;
    while (arg = node.params['p' + (++i)]) {
      args.push(arg.render(chain, context, model));
    }
    return Lavaca.util.StringUtils.format.apply(this, args);
  },
  /**
   * @method helperInclude
   * Helper function, exposed in dust templates, that uses
   *   [[Lavaca.ui.Template]] to include other templates. Accessed as:
   *
   * <dl>
   *
   * <dt>{#include name="template-name"/}</dt>
   *   <dd>name&mdash;The name under which the template can be referenced</dd>
   *
   * </dl>
   *
   * <strong>Note:</strong> You should always use the include helper instead of
   * the dust.js partial syntax. The dust.js partial syntax may not work as expected.
   *
   * @param {RenderChain} chain  Dust render chain
   * @param {Context} context  Dust context
   * @param {Object} model  Model object passed to template
   * @return {String}  Rendered output
   */
  helperInclude: function(chain, context, model) {
    var node = chain.tail,
        name = node.params['name'].render(chain, context, model),
        result;
    // Note - this is potentially an async call
    Template
      .render(name, model)
      .then(function(html) {
        result = html;
      });
    return result;
  },
  /**
   * @method compile
   * Compiles the template
   */
  compile: function() {
    Template.prototype.compile.call(this);
    xdust.compile(this.code, this.name);
  },
  /**
   * @method render
   * Renders the template to a string
   *
   * @param {Object} model  The data model to provide to the template
   * @return {Lavaca.util.Promise}  A promise
   */
  render: function(model) {
    var promise = new Lavaca.util.Promise(this);
    if (!this.code && this.src) {
      this.load(this.src);
    }
    if (this.code && !this.compiled) {
      this.compile();
      this.compiled = true;
    }
    xdust.render(this.name, model, function(err, html) {
      if (err) {
        promise.reject(err);
      } else {
        promise.resolve(html);
      }
    });
    return promise;
  },
  /**
   * @method dispose
   * Makes this template ready for disposal
   */
  dispose: function() {
    delete xdust.templates[this.name];
    Template.prototype.dispose.call(this);
  }
});

// Register the Dust template type for later use
ns.Template.register('text/x-dust-template', ns.DustTemplate);

})(Lavaca.ui, xdust, Lavaca.ui.Template, Lavaca.util.Translation);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $, EventDispatcher) {

/**
 * @class Lavaca.ui.Widget
 * @super Lavaca.events.EventDispatcher
 * Base type for all UI elements
 *
 * @constructor
 *
 * @param {jQuery} el  The DOM element that is the root of the widget
 */
ns.Widget = EventDispatcher.extend(function(el) {
  EventDispatcher.call(this);
  /**
   * @field {jQuery} el
   * @default null
   * The DOM element that is the root of the widget
   */
  this.el = el = $(el);
  var id = el.attr('id');
  if (!id) {
    id = 'widget-' + Lavaca.uuid();
    el.attr('id', id);
  }
  /**
   * @field {String} id
   * @default (Autogenerated)
   * The el's ID
   */
  this.id = id;
});

})(Lavaca.resolve('Lavaca.ui', true), Lavaca.$, Lavaca.events.EventDispatcher);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $, Widget, Promise) {

var UNDEFINED;

function _required(value, input, form) {
  return value ? null : 'error_required';
}

function _pattern(value, input, form) {
  if (value) {
    var pattern = new RegExp(input.attr('pattern'));
    if (!pattern.test(value)) {
      return 'error_pattern';
    }
  }
  return null;
}

function _email(value, input, form) {
  if (value && !/^\w+@\w+(\.\w+)*\.\w+$/.test(value)) {
    return 'error_email';
  }
  return null;
}

function _tel(value, input, form) {
  if (value && !/^\d?(\d{3})?\d{7}$/.test(value.replace(/\D/g, ''))) {
    return 'error_email';
  }
  return null;
}

function _number(value, input, form) {
  if (value && !/^\d+(\.\d+)?$/.test(value)) {
    return 'error_number';
  }
  return null;
}

function _url(value, input, form) {
  if (value && !/^https?:\/\/\w+(\.\w+)*\.\w(:\d+)?\/\S+$/.test(value)) {
    return 'error_url';
  }
  return null;
}

/**
 * @class Lavaca.ui.Form
 * @super Lavaca.ui.Widget
 * Basic form type
 *
 * @constructor
 * @param {jQuery} el  The DOM element that is the root of the widget
 */
ns.Form = Widget.extend(function() {
  Widget.apply(this, arguments);
  var self = this;
  this.pendingSync = {};
  this._onChangeInput = function(e) {
    self.onChangeInput(e);
  };
  this._onSubmit = function(e) {
    self.onSubmit(e);
  };
  this.el.on('submit', this._onSubmit);
  this.addRule(this.defaultRules());
}, {
  /**
   * @method onSubmit
   * Event handler for when the form is submitted
   *
   * @param {Event} e  The submit event
   */
  onSubmit: function(e) {
    e.preventDefault();
    this.validate()
      .success(this.onSubmitSuccess)
      .error(this.onSubmitError);
  },
  /**
   * @method onSubmitSuccess
   * Event handler for when the user attempts to submit a valid form
   *
   * @param {Object} values  Key-value map of the form's input names and values
   */
  onSubmitSuccess: function(values) {
    // Placeholder
  },
  /**
   * @method onSubmitError
   * Event handler for when the user attempts to submit an invalid form
   *
   * @param {Object} invalidInputs  A key-value map of all invalid inputs
   */
  onSubmitError: function(invalidInputs) {
    // Placeholder
  },
  /**
   * @method onChangeInput
   * Event handler for when an input on the form changes
   *
   * @param {Event} e  The change event
   */
  onChangeInput: function(e) {
    if (this.model) {
      var input = $(e.target),
          name = input.attr('name'),
          value = input.val();
      this.pendingSync[name] = true;
      this.model.set(name, value);
      this.pendingSync[name] = false;
    }
  },
  /**
   * @method onChangeModel
   * Event handler for when an attribute on the bound model changes
   *
   * @param {Event} e  The change event
   */
  onChangeModel: function(e) {
    if (!this.pendingSync[e.attribute]) {
      this.set(e.attribute, e.value);
    }
  },
  /**
   * @method bind
   * Binds this form to a model, forcing the two to stay in sync.
   *
   * @param {Lavaca.mvc.Model} model  The model
   */
  bind: function(model) {
    this.unbind();
    this.model = model;
    model.on('change', this.onChangeModel, this);
    this.el.on('change', this._onChangeInput);
  },
  /**
   * @method unbind
   * Unbinds this form from its model
   */
  unbind: function() {
    if (this.model) {
      this.el.off('change', this._onChangeInput);
      this.model.off('change', this.onchangeModel, this);
      this.model = null;
    }
  },
  /**
   * @method input
   * Retrieve an input from the form with a given name
   *
   * @param {String} name  The name of the input
   * @return {jQuery}  The input
   */
  input: function(name) {
    return this.el.find('input, select, textarea').filter('[name="' + name + '"]');
  },
  /**
   * @method get
   * Gets the value of an input on the form
   *
   * @param {String} name  The name of the input
   * @return {String}  The value of the input
   */
  get: function(name) {
    return this.input(name).val();
  },
  /**
   * @method set
   * Sets an input on the form's value
   *
   * @param {String} name  The name of the input
   * @param {Object} value  The new value of the input
   */
  set: function(name, value) {
    this.input(name).val(value || null);
  },
  /**
   * @method defaultRules
   * The default validation rules for the form
   *
   * @return {Object}  The form's default rules1
   */
  defaultRules: function() {
    return {
      '[required]': _required,
      '[pattern]': _pattern,
      '[type=email]': _email,
      '[type=tel]': _tel,
      '[type=number]': _number,
      '[type=url]': _url
    };
  },
  /**
   * @method addRule
   *
   * @sig Adds multiple validation rules to this form
   * @param {Object} map  A hash of selectors and callbacks to add as rules
   *
   * @sig Adds a validation rule to this form
   * @param {String} selector  A jQuery selector associated with the rule
   * @param {Function} callback  A function that tests the value of inputs matching the
   *   selector in the form callback(value, input, form) and
   *   return a string message if validation fails
   */
  addRule: function(selector, callback) {
    if (!this.rules) {
      this.rules = [];
    }
    if (typeof selector == 'object') {
      for (var n in selector) {
        this.addRule(n, selector[n]);
      }
    } else {
      this.rules.push({selector: selector, callback: callback});
    }
  },
  /**
   * @method values
   * Collects all input values on the form
   *
   * @return {Object}  A hash of input names and their values
   */
  values: function() {
    var inputs = this.el.find('input, select, textarea'),
        result = {},
        i = -1,
        input,
        name,
        current,
        value,
        type;
    while (input = inputs[++i]) {
      input = $(input);
      type = input.attr('type');
      if ((type == 'radio' || type == 'checkbox') && !input[0].checked) {
        continue;
      }
      name = input.attr('name');
      current = result[name];
      value = input.val();
      if (current instanceof Array) {
        current.push(value);
      } else if (current !== UNDEFINED) {
        result[name] = [current, value];
      } else {
        result[name] = value;
      }
    }
    return result;
  },
  /**
   * @method validate
   *
   * @sig Checks the entire form to see if it's in a valid state
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig Checks the entire form to see if it's in a valid state
   * @param {Function} succcess  A callback to execute when the form is valid
   * @param {Function} error  A callback to execute when the form is invalid
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig Checks a specifc input to see if it's in a valid state
   * @param {jQuery} input  An input to check
   * @return {Lavaca.util.Promise}  A promise
   *
   * @sig Checks a specifc input to see if it's in a valid state
   * @param {Function} succcess  A callback to execute when the input is valid
   * @param {Function} error  A callback to execute when the input is invalid
   * @param {jQuery} input  An input to check
   * @return {Lavaca.util.Promise}  A promise
   */
  validate: function(success, error, input) {
    if (success && typeof success != 'function') {
      input = success;
      success = null;
    }
    if (input) {
      input = $(input);
    }
    var result = null,
        promise = new Promise(this),
        i = -1,
        j,
        rule,
        inputs,
        ip,
        message,
        name,
        label,
        id,
        value;
    while (rule = this.rules[++i]) {
      if (input) {
        inputs = input.filter(rule.selector);
      } else {
        inputs = this.el.find(rule.selector);
      }
      j = -1;
      while (ip = inputs[++j]) {
        ip = $(ip);
        value = ip.val();
        message = rule.callback.call(this, value, ip, this);
        if (message) {
          name = ip.attr('name');
          if (!result) {
            result = {};
          }
          if (!result[name]) {
            id = ip.attr('id');
            label = null;
            if (id) {
              label = this.el.find('label[for="' + id + '"]').text();
            }
            result[name] = {
              id: id,
              name: name,
              label: label,
              el: ip,
              value: value,
              messages: []
            };
          }
          result[name].messages.push(message);
        }
      }
    }
    if (result) {
      promise.reject(result);
    } else {
      promise.resolve(this.values());
    }
    return promise
      .error(function(inputs) {
        this.trigger('invalid', {inputs: inputs});
      })
      .success(function(values) {
        this.trigger('valid', values);
      })
      .success(success)
      .error(error);
  },
  /**
   * @method dispose
   * Ready the form for garbage collection
   */
  dispose: function() {
    this.unbind();
    Widget.prototype.dispose.call(this);
  }
});
/**
 * @method withSubmit
 * @static
 * Extends the form with new submit handlers
 *
 * @param {Function} success  The success handler
 * @param {Function} error  The error handler
 * @return {Function}  A new [[Lavaca.ui.Form]]-derived type
 */
ns.Form.withSubmit = function(success, error) {
  return ns.Form.extend({
    onSubmitSuccess: function(values) {
      success.call(this, values);
    },
    onSubmitError: function(inputs) {
      error.call(this, inputs);
    }
  });
};

})(Lavaca.ui, Lavaca.$, Lavaca.ui.Widget, Lavaca.util.Promise);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $, Widget) {

/**
 * @class Lavaca.ui.LoadingIndicator
 * @super Lavaca.ui.Widget
 * Type that shows/hides a loading indicator
 *
 * @constructor
 * @param {jQuery} el  The DOM element that is the root of the widget
 */
ns.LoadingIndicator = Widget.extend({
  /**
   * @field {String} className
   * @default 'loading'
   * Class name applied to the root
   */
  className: 'loading',
  /**
   * @method show
   * Activates the loading indicator
   */
  show: function() {
    this.el.addClass(this.className);
  },
  /**
   * @method hide
   * Deactivates the loading indicator
   */
  hide: function() {
    this.el.removeClass(this.className);
  }
});
/** 
 * @method init
 * @static
 * Creates a loading indicator and binds it to the document's AJAX events
 *
 * @sig
 *
 * @sig
 * @param {Function} TLoadingIndicator  The type of loading indicator to create (should derive from [[Lavaca.ui.LoadingIndicator]])
 */
ns.LoadingIndicator.init = function(TLoadingIndicator) {
  TLoadingIndicator = TLoadingIndicator || ns.LoadingIndicator;
  var indicator = new TLoadingIndicator(document.body);
  function show() {
    indicator.show();
  }
  function hide() {
    indicator.hide();
  }
  $(document)
    .on('ajaxStart', show)
    .on('ajaxStop', hide)
    .on('ajaxError', hide);
  return indicator;
};

})(Lavaca.ui, Lavaca.$, Lavaca.ui.Widget);
/*
Lavaca 1.0.4
Copyright (c) 2012 Mutual Mobile

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function(ns, $, Widget, iScroll) {

var _props = ['overflowScrolling', 'webkitOverflowScrolling', 'MozOverflowScrolling', 'OOverflowScrolling', 'MSOverflowScrolling'],
    _prop,
    _isSupported;

(function() {
  var style = document.createElement('div').style,
      i = -1,
      s;
  while (s = _props[++i]) {
    if (s in style) {
      _prop = s;
      break;
    }
  }
})();

/**
 * @class Lavaca.ui.Scrollable
 * @super Lavaca.ui.Widget
 * Overflow Scroll Container for mobile using overflow scrolling: touch or iScroll
 *
 * @constructor
 * @param {jQuery} el  The DOM element that is the root of the widget
 */
ns.Scrollable = Widget.extend(function() {
  Widget.apply(this, arguments);
  if (!this.iScrollOptions) {
    this.iScrollOptions = {};
  }
  if (this.supportsOverflow) {
    this.initOverflowScroll();
  } else {
    this.className = 'synthetic-scroll';
    this.initIScroll();
  }
}, {
  /**
   * @field {Boolean} supportsOverflow
   * @default false
   * True when overflowScrolling is supported in the Browser 
   */
  supportsOverflow: !!_prop,
  /**
   * @field {String} className
   * @default 'overflow-scroll'
   * Activates the loading indicator
   */
  className: 'overflow-scroll',
  /**
   * @field {Object} iScrollOptions
   * @default null
   * iScroll options hash
   */
  iScrollOptions: null,
  /**
   * @method wrapper
   * Creates a wrapper for iScroll's scrolling content
   *
   * @return {jQuery}  The wrapper element
   */
  wrapper: function() {
    return $('<div class="scroll-wrapper"></div>');
  },
  /**
   * @method createOverflowScroll
   * Initializes native overflow scrolling
   */
  initOverflowScroll: function() {
    this.el.addClass(this.className);
    this.preventParentScroll();
  },
  /**
   * @method createOverflowScroll
   * Instantiates iScroll
   */
  initIScroll: function() {
    var wrapper = this.wrapper(),
      options = {},
      opt,
      value;
    for (opt in this.iScrollOptions) {
      value = this.iScrollOptions[opt];
      if (typeof value == 'function') {
        value = $.proxy(value, this);
      }
      options[opt] = value;
    }
    value = options.onBeforeScrollStart;
    options.onBeforeScrollStart = function(e) {
      var nodeType = (e.explicitOriginalTarget || e.target).nodeName;
      if (nodeType != 'SELECT' && nodeType != 'OPTION' && nodeType != 'INPUT' && nodeType != 'TEXTAREA' && nodeType != 'LABEL') {
        e.preventDefault();
        e.stopPropagation();
      }
      if (value) {
        value.apply(this, arguments);
      }
    };
    this.el.addClass(this.className);
    wrapper.append(this.el.children());
    this.el.append(wrapper);
    this.iScroll = new iScroll(this.el[0], options);
    this.refresh();
  },
  /**
   * @method refresh
   * Delegates to public iScroll method with delay.
   * Must be called every time content changes inside of scrolling container.
   */
   refresh: function() {
     if (!this.supportsOverflow) {
       Lavaca.delay(function() {
         this.iScroll.refresh();
       }, this, 10);
     }
   },
   /**
    * @method preventParentScroll
    * Prevents a page from scrolling when overflow container reaches boundries
    *
   * Based on ScrollFix v0.1
   * http://www.joelambert.co.uk
   *
   * Copyright 2011, Joe Lambert.
   * Free to use under the MIT license.
   * http://www.opensource.org/licenses/mit-license.php
   */
  preventParentScroll: function() {
    var el = this.el[0];
    this.el.on('touchstart', function(e) {
      startTopScroll = el.scrollTop;
      if (startTopScroll <= 0) {
        el.scrollTop = 1;
      }
      if (startTopScroll + el.offsetHeight >= el.scrollHeight) {
        el.scrollTop = el.scrollHeight - el.offsetHeight - 1;
      }
    });
  },
   /**
    * @method dispose
    * Cleans up the widget
    */
   dispose: function() {
     if (this.isScroll) {
       this.iScroll.destroy();
     }
     Widget.prototype.dispose.call(this);
   }
});

})(Lavaca.ui, Lavaca.$, Lavaca.ui.Widget, iScroll);